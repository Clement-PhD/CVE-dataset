use std::fs;
use std::fs::File;
use std::io::Write;
use std::path::Path;
use serde::{Serialize, Deserialize};

use crate::error::DownloadError;

#[derive(Debug, Serialize, Deserialize, PartialEq)]
pub enum WarningType {
    NotModified,
    CantDownloaded,
    CantPatched,
    CantApplyPatch,
    NoPatch,
    NoUrl,
}


#[derive(Debug, Serialize, Deserialize)]
pub struct WarningPayload {
    warning_type: WarningType,
    file_name: String,
    message: String,
}

impl WarningPayload {
    pub fn new(warning_type: WarningType, file_name: &str, message: String) -> Self {
        WarningPayload {
            warning_type,
            file_name: file_name.to_string(),
            message,
        }
    }

    pub fn get_warning_type(&self) -> &WarningType {
        &self.warning_type
    }

    pub fn get_file_name(&self) -> &str {
        &self.file_name
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CveWarnings {
    cve: String,
    warnings: Vec<WarningPayload>,
}

impl CveWarnings {
    pub fn new(cve: String) -> Self {
        CveWarnings {
            cve,
            warnings: Vec::new(),
        }
    }

    pub fn add_warning_payload(&mut self, warning: WarningPayload) {
        self.warnings.push(warning);
    }

    pub fn add_warning(&mut self, warning_type: WarningType, file_name: String, message: String) {
        let payload = WarningPayload { warning_type, file_name, message };
        self.warnings.push(payload);
    }

    pub fn get_save_file_path<P : AsRef<Path>>(&self, output_data_folder: P) -> Result<String, DownloadError>{
        let output_folder_path = output_data_folder.as_ref().to_str().unwrap();
        let folder_path = format!("{}/{}", output_folder_path, self.cve);
        fs::create_dir_all(&folder_path)?;
        Ok(format!("{}/warnings.json", folder_path))
    }

    pub fn save<P : AsRef<Path>>(&self, output_data_folder: P) -> Result<(), DownloadError>  {
        let output_json_file_path = self.get_save_file_path(output_data_folder)?;
        let mut file = File::create(output_json_file_path)?;
        let serialized = serde_json::to_string_pretty(&self)?;
        file.write_all(serialized.as_bytes())?;

        Ok(())
    }

    pub fn load<P : AsRef<Path>>(file_path: P) -> Result<Self, DownloadError>  {
        let data = fs::read_to_string(file_path)?;
        let data =  serde_json::from_str(&data)?;
        Ok(data)
    }
}