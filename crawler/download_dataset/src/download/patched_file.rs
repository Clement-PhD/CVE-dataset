use std::fmt::Display;
use std::fs;
use std::path::Path;
use std::str::FromStr;

use crate::error::DownloadError;
use crate::utils::{apply_patch_reverse, download_file};

use super::file_warnings::{WarningPayload, WarningType};


#[derive(Debug, PartialEq, Clone, Hash, Eq)]
pub enum FileStatus {
    Added,
    Modified,
    Removed,
    Renamed,
    Unknown,
}

impl Display for FileStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            FileStatus::Added => write!(f, "added"),
            FileStatus::Modified => write!(f, "modified"),
            FileStatus::Removed => write!(f, "removed"),
            FileStatus::Renamed => write!(f, "renamed"),
            FileStatus::Unknown => write!(f, "unknown"),
        }
    }
}

impl FromStr for FileStatus {
    type Err = ();

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "added" => Ok(FileStatus::Added),
            "modified" => Ok(FileStatus::Modified),
            "removed" => Ok(FileStatus::Removed),
            "renamed" => Ok(FileStatus::Renamed),
            _ => Ok(FileStatus::Unknown),
        }
    }
}



/// A struct that represents a patched file
#[derive(Debug, Clone)]
pub struct PatchedFile {
    name : String,
    raw_url : Option<String>,
    patch : Option<String>,
    status : FileStatus,
}

impl PatchedFile {
    /// Create a new PatchedFile
    pub fn new(name: &str, raw_url: Option<&str>, patch: Option<&str>, status: FileStatus) -> Self {
        PatchedFile {
            name: name.to_string(),
            raw_url: raw_url.map(|s| s.to_string()),
            patch: patch.map(|s| s.to_string()),
            status,
        }
    }

    /// Get the name
    pub fn get_name(&self) -> &str {
        &self.name
    }

    /// Get the raw url
    pub fn get_raw_url(&self) -> Option<&str> {
        self.raw_url.as_deref()
    }

    /// Get the patch
    pub fn get_patch(&self) -> Option<&str> {
        self.patch.as_deref()
    }

    /// Get the status
    pub fn get_status(&self) -> FileStatus {
        self.status.clone()
    }

    // --------------------------------- Name and path ---------------------------------

    pub fn get_patch_name(&self) -> String {
        format!("{}.patch", self.name)
    }

    pub fn get_patch_path<P : AsRef<Path>>(&self, output_folder_path_o : P) -> String {
        let patch_name = self.get_patch_name();
        let output_folder = output_folder_path_o.as_ref();
        let output_folder = output_folder.join("patch");
        let output_file = output_folder.join(patch_name);
        output_file.to_str().unwrap().to_string()
    }

    pub fn get_fixed_file_path<P : AsRef<Path>>(&self, output_folder_path_o : P) -> String {
        let output_folder = output_folder_path_o.as_ref();
        let output_folder = output_folder.join("fixed");
        let output_file = output_folder.join(self.name.as_str());
        output_file.to_str().unwrap().to_string()
    }

    pub fn get_original_file_path<P : AsRef<Path>>(&self, output_folder_path_o : P) -> String {
        let output_folder = output_folder_path_o.as_ref();
        let output_folder = output_folder.join("original");
        let output_file = output_folder.join(self.name.as_str());
        output_file.to_str().unwrap().to_string()
    }

    pub fn get_file_path<P : AsRef<Path>>(&self, output_folder_path_o : P) -> String {
        let output_folder = output_folder_path_o.as_ref().to_str().unwrap();
        match self.status {
            FileStatus::Added | FileStatus::Modified | FileStatus::Renamed => {
                self.get_fixed_file_path(output_folder)
            }
            FileStatus::Removed => {
                self.get_original_file_path(output_folder)
            }
            _ => panic!("Unknown file status: {:?}", self.status),
        }
    }
    // --------------------------------- Warnings ---------------------------------
    pub fn get_warning_payloads(&self) -> Vec<WarningPayload> {
        let mut warnings: Vec<WarningPayload> = Vec::new();
    
        if self.status != FileStatus::Modified {
            warnings.push(WarningPayload::new(
                WarningType::NotModified, 
                self.name.as_str(), 
                format!("not a modified file (status: {:?})\n", self.status)
            ));
        }
    
        if self.patch.is_none() {
            warnings.push(WarningPayload::new(
                WarningType::NoPatch,
                self.name.as_str(),
                "File has no patch data.\n".to_string(),
            ));
        }
    
        if self.raw_url.is_none() {
            warnings.push(WarningPayload::new(
                WarningType::NoUrl,
                self.name.as_str(),
                "File has no raw url.\n".to_string(),
            ));
        }
    
        warnings
    }

    // --------------------------------- Download and patch ---------------------------------

    pub fn can_be_downloaded(&self) -> bool {
        self.raw_url.is_some() && self.status != FileStatus::Unknown
    }

    pub fn can_be_patched(&self) -> bool {
        self.patch.is_some() && self.status != FileStatus::Unknown
    }

    /// Download the file
    /// - output_folder_path_o: the output folder path (cve folder)
    pub fn download<P : AsRef<Path>>(&self, output_folder_path_o : P) -> Result<bool, DownloadError> {
        if !self.can_be_downloaded() {
            return Ok(false);
        }
        let file_path = self.get_file_path(output_folder_path_o);
        std::fs::create_dir_all(std::path::Path::new(&file_path).parent().unwrap()).unwrap();
        // Assuming you have a function `download_file` that downloads the file
        // and saves it to the specified path
        let content = download_file(&self.raw_url.as_ref().unwrap())?;
        std::fs::write(&file_path, &content)?;
        Ok(true)
    }

    pub fn save_patch<P : AsRef<Path>>(&self, output_folder_path_o : P) -> Result<bool, DownloadError> {
        if !self.can_be_patched() {
            return Ok(false);
        }
        let patch_path = self.get_patch_path(output_folder_path_o);
        std::fs::create_dir_all(std::path::Path::new(&patch_path).parent().unwrap())?;
        std::fs::write(&patch_path, &self.patch.as_ref().unwrap().as_bytes())?;
        Ok(true)
    }

    pub fn apply_patch<P : AsRef<Path>>(&self, output_folder_path_o : P) -> Result<bool, DownloadError> {
        if !self.can_be_patched() {
            return Ok(false);
        }
        let original_file_path = self.get_original_file_path(&output_folder_path_o);
        let last_folder_path_o = Path::new(original_file_path.as_str());

        fs::create_dir_all(last_folder_path_o.parent().unwrap())?;

        let result = apply_patch_reverse(
            self.get_patch_path(&output_folder_path_o).as_str(),
            self.get_fixed_file_path(&output_folder_path_o).as_str(),
            self.get_original_file_path(&output_folder_path_o).as_str(),
            false,
        );

        if result {
            return Ok(true);
        }

        // if the patch was not applied, try to add a carriage return to the end of the patch
 
        let patch_content = fs::read_to_string(self.get_patch_path(&output_folder_path_o))?;
        let patched_content = format!("{}\n", patch_content);
        fs::write(self.get_patch_path(&output_folder_path_o), patched_content)?;

        let result = apply_patch_reverse(
            self.get_patch_path(&output_folder_path_o).as_str(),
            self.get_fixed_file_path(&output_folder_path_o).as_str(),
            self.get_original_file_path(&output_folder_path_o).as_str(),
            false,
        );

        Ok(result)
    }
}