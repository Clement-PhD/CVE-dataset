use std::fs;
use std::path::Path;

use normalize_dataset::normalized_data::normalized_url::NormalizedUrl;
use normalize_dataset::normalized_data::NormalizedCveSample;

use crate::download::file_warnings::{WarningPayload, WarningType};
use crate::download::patched_file::PatchedFile;
use crate::download::GetFilesInfoTrait;
use crate::error::DownloadError;
use crate::params::warn;







pub fn download_cve<P : AsRef<Path>>(cve : &NormalizedCveSample, output_folder_path : P) -> bool {
    let mut urls : Vec<&NormalizedUrl> = cve.get_urls().iter().collect();
    urls.sort();


    for url in urls {
        
        if url.can_get_files_info() {
            let maybe_files_info = url.get_files_info();
            if let Ok(inside_files) = maybe_files_info {
                // remove old files
                if output_folder_path.as_ref().exists() {
                    fs::remove_dir_all(&output_folder_path).unwrap();
                }
                fs::create_dir_all(&output_folder_path).unwrap();

                let maybe_warnings = download_files(inside_files, &output_folder_path);
                if let Ok(inside_warnings) = maybe_warnings {
                    // save the warnings
                    let warning_file_path = output_folder_path.as_ref().join("warnings.json");
                    let warning_file = std::fs::File::create(warning_file_path).unwrap();

                    serde_json::to_writer_pretty(warning_file, &inside_warnings).unwrap();

                    let url_file_path = output_folder_path.as_ref().join("url.json");
                    let url_file = std::fs::File::create(url_file_path).unwrap();
                    serde_json::to_writer_pretty(url_file, url).unwrap();
                    return true;
                }else{
                    warn(format!("Error downloading files: {:?}", maybe_warnings));
                }
            }else{
                warn(format!("Error getting files info: {:?}", maybe_files_info));
            }
        }
    }


    false
}


pub fn download_files<P : AsRef<Path>>(files : Vec<PatchedFile>, output_folder_path : P) -> Result<Vec<WarningPayload>, DownloadError>{
    let mut warnings: Vec<WarningPayload> = Vec::new();
    for file in files.iter() {
         // warnings :
         warnings.extend(file.get_warning_payloads());

         // download the file
         if file.can_be_downloaded() {
             file.download(&output_folder_path)?;
         } else {
             warnings.push(WarningPayload::new(
                 WarningType::CantDownloaded,
                 file.get_name(),
                 "File can't be downloaded.\n".to_string(),
             ));
             
             continue;
         };

         // save the patch
        if file.can_be_patched() {
            
            file.save_patch(&output_folder_path)?;
        } else {
            warnings.push(WarningPayload::new(
                WarningType::CantPatched,
                file.get_name(),
                "File can't be patched.\n".to_string(),
            ));

            continue;
        }

        // try to apply the patch
        let applied = file.apply_patch(&output_folder_path)?;
        if !applied {
            warnings.push(WarningPayload::new(
                WarningType::CantApplyPatch,
                file.get_name(),
                "Patch can't be applied.\n".to_string(),
            ));
            warn(format!("Patch can't be applied for file: {}", file.get_name()));
        }
    }

    // check the number of file downloaded
    let mut nb_attended_downloaded_files = 0;
    for file in files.iter() {
        if file.can_be_downloaded() {
            nb_attended_downloaded_files += 1;
        }
    }

    let mut nb_downloaded_files = 0;
    for file in files.iter() {
        let original_path = file.get_original_file_path(&output_folder_path);
        let original_path_o = Path::new(original_path.as_str());
        if original_path_o.exists() {
            nb_downloaded_files += 1;
        }
    }

    if nb_downloaded_files != nb_attended_downloaded_files {
        warn(format!(
            "Only {} files were downloaded, but {} were expected.",
            nb_downloaded_files, nb_attended_downloaded_files
        ));
        return Err(format!(
            "Only {} files were downloaded, but {} were expected.",
            nb_downloaded_files, nb_attended_downloaded_files
        ).into());
    }

    Ok(warnings)
}