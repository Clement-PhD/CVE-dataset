use log::warn;
use serde::de::DeserializeOwned;
use std::fmt::Debug;

use crate::error::CommonError;
use crate::normalized_data::dataset::Dataset;
use crate::normalized_data::{NormalizedDataset, NormalizedDatasetTrait, NormalizedSampleTrait};

pub mod ground_truth_2021;


/// define the data needed to load a csv dataset
pub struct DatasetCsvDef<SampleType>
where
    SampleType: NormalizedSampleTrait + DeserializeOwned + Debug 
{
    dataset : Dataset,
    dataset_path: &'static str,
    escape_char: u8,
    _phantom: std::marker::PhantomData<SampleType>,
}

impl<SampleType> DatasetCsvDef<SampleType>
where
    SampleType: NormalizedSampleTrait + DeserializeOwned + Debug 
{
    pub fn new(dataset_path: &'static str, escape_char: u8, dataset : Dataset) -> Self {
        Self {
            dataset,
            dataset_path,
            escape_char,
            _phantom: std::marker::PhantomData,
        }
    }

    pub fn dataset_path(&self) -> &'static str {
        self.dataset_path
    }

    pub fn escape_char(&self) -> u8 {
        self.escape_char
    }
}

impl<SampleType> NormalizedDatasetTrait for DatasetCsvDef<SampleType> 
where 
    SampleType: NormalizedSampleTrait + DeserializeOwned + Debug
{
    fn normalize_dataset(&self) -> Result<(NormalizedDataset, Vec<CommonError>), Box<dyn std::error::Error>> {
        let mut normalized_dataset = NormalizedDataset::new();
        let mut errors = Vec::new();

        let mut records = Vec::new();

        let mut rdr = csv::ReaderBuilder::new()
            .double_quote(true)
            .escape(Some(self.escape_char())) 
            .has_headers(true)
            .from_path(self.dataset_path())?;
        let file_bytes = std::fs::read(self.dataset_path())?;
        for result in rdr.deserialize().into_iter() {
            if let Err(e) = result {
                match e.into_kind() {
                    csv::ErrorKind::UnequalLengths { pos, expected_len, len } => {
                        warn!("Unequal length : Error position : {:?}, expected length : {:?}, length : {:?}", pos, expected_len, len);
                        if let Some(position) = pos {
                            let line = file_bytes.split(|&c| c == b'\n').nth(position.line() as usize);
                            if let Some(line) = line {
                                warn!("Error line : {:?}", String::from_utf8_lossy(line));
                            }
                        }

                        panic!("Error while deserializing a record");
                    },
                    a => {panic!("Error while deserializing a record : {:?} ", a);}
                }
                
                
            }
            let record: SampleType = result.unwrap();
            //info!("record : {:?}", record);
            records.push(record);
        }

        for record in records {
            let error = normalized_dataset.add(&record);
            if let Err(e) = error {
                errors.push(e);
                continue;
            }
        }

        Ok((normalized_dataset, errors))
    }


    fn get_dataset(&self) -> Dataset {
        self.dataset.clone()
    }
}