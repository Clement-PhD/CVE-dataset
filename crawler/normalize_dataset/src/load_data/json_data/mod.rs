use serde::de::DeserializeOwned;
use std::fmt::Debug;

use crate::error::CommonError;
use crate::normalized_data::dataset::Dataset;
use crate::normalized_data::{NormalizedDataset, NormalizedDatasetTrait, NormalizedSampleTrait};

pub mod osv_dump;


/// define the data needed to load a csv dataset
pub struct DatasetJsonDef<SampleType>
where
    SampleType: NormalizedSampleTrait + DeserializeOwned + Debug 
{
    dataset : Dataset,
    dataset_path: &'static str,
    _phantom: std::marker::PhantomData<SampleType>,
}

impl<SampleType> DatasetJsonDef<SampleType>
where
    SampleType: NormalizedSampleTrait + DeserializeOwned + Debug 
{
    pub fn new(dataset_path: &'static str, dataset : Dataset) -> Self {
        Self {
            dataset,
            dataset_path,
            _phantom: std::marker::PhantomData,
        }
    }

    pub fn dataset_path(&self) -> &'static str {
        self.dataset_path
    }
}

impl<SampleType> NormalizedDatasetTrait for DatasetJsonDef<SampleType> 
where 
    SampleType: NormalizedSampleTrait + DeserializeOwned + Debug
{
    fn normalize_dataset(&self) -> Result<(NormalizedDataset, Vec<CommonError>), Box<dyn std::error::Error>> {
        let mut normalized_dataset = NormalizedDataset::new();
        let mut errors = Vec::new();

        let file_bytes = std::fs::read(self.dataset_path())?;
        let records: Vec<SampleType> = serde_json::from_slice(&file_bytes)?;

        for record in records {
            let error = normalized_dataset.add(&record);
            if let Err(e) = error {
                errors.push(e);
                continue;
            }
        }

        Ok((normalized_dataset, errors))
    }


    fn get_dataset(&self) -> Dataset {
        self.dataset.clone()
    }
}