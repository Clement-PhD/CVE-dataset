use std::collections::HashSet;

use log::warn;
use serde_derive::{Deserialize, Serialize};


use crate::error::{CommonError, NormalizedError, NormalizedMixError};

use self::dataset::Dataset;
use self::normalized_url::NormalizedUrl;
use self::security_id::SecurityId;

pub mod dataset;
pub mod security_id;
pub mod normalized_url;

/// Trait for the normalization of a dataset
pub trait NormalizedDatasetTrait {
    fn normalize_dataset(&self) -> Result<(NormalizedDataset, Vec<CommonError>), Box<dyn std::error::Error>>;

    fn get_dataset(&self) -> Dataset;
}


/// Trait for the normalization of a sample of a dataset
pub trait NormalizedSampleTrait {
    fn normalized(&self) -> Result<NormalizedCveSample, NormalizedError>;
    fn get_id(&self) -> String;
}


#[derive(Debug, Deserialize, Serialize)]
pub struct NormalizedDataset {
    pub cve_samples: Vec<NormalizedCveSample>,
}


impl NormalizedDataset {
    pub fn new() -> Self {
        NormalizedDataset {
            cve_samples: Vec::new(),
        }
    }

    pub fn mix(&mut self, dataset: &NormalizedDataset) -> Vec<NormalizedMixError<NormalizedCveSample>> {
        let mut errors = Vec::new();
        for sample in dataset.cve_samples.iter() {
            let error = self.add(sample);
            if let Err(e) = error {
                errors.push(e);
            }
        }
        errors.into_iter().map(|e| {
            match e {
                CommonError::NormalizedMixError(e) => e,
                _ => panic!("Error should be a NormalizedMixError")
            }
        }).collect()
    }

    pub fn add<T>(&mut self, sample_to_normalize: &T) -> Result<(), CommonError> where T: NormalizedSampleTrait {
        let sample = sample_to_normalize.normalized()?;
        
        let mut found = false;
        for cve_sample in self.cve_samples.iter_mut() {
            if cve_sample.security_id == sample.security_id {
                cve_sample.mix(&sample)?;
                found = true;
                break;
            }
        }

        if !found {
            self.cve_samples.push(sample);
        }

        Ok(())
    }

    pub fn summary(&self) -> String {
        let mut summary = String::new();

        summary.push_str("Normalized dataset summary : \n");
        summary.push_str(&format!("Nb of samples : {}\n", self.cve_samples.len()));
        let nb_link_number : Vec<usize> = self.cve_samples.iter().map(|s| s.urls.len()).collect();
        let min = nb_link_number.iter().min().unwrap();
        let max = nb_link_number.iter().max().unwrap();
        let avg = nb_link_number.iter().sum::<usize>() as f64 / nb_link_number.len() as f64;

        summary.push_str(&format!("Nb of links per CVE : min : {}, max : {}, avg : {}\n", min, max, avg));

        // number of cve, ghsa....

        let cve_number = self.cve_samples.iter().filter(|s| s.security_id.is_cve_id()).count();
        let ghsa_number = self.cve_samples.iter().filter(|s| s.security_id.is_ghsa_id()).count();
        let osv_number = self.cve_samples.iter().filter(|s| s.security_id.is_osv_id()).count();

        summary.push_str(&format!("Nb of CVE : {}\n", cve_number));
        summary.push_str(&format!("Nb of GHSA : {}\n", ghsa_number));
        summary.push_str(&format!("Nb of OSV : {}\n", osv_number));

        // number of urls
        let mut github_url_number = 0;
        let mut unknown_url_number = 0;
        let mut only_unknown = 0;


        for sample in self.cve_samples.iter() {
            let mut is_github = false;
            let mut is_unknown = false;
            for url in sample.urls.iter() {
                match url {
                    NormalizedUrl::GithubUrl(_) => {
                        is_github = true;
                    },
                    NormalizedUrl::UnknownUrl(_) => {
                        is_unknown = true;
                    }
                }
            }

            if is_github {
                github_url_number += 1;
            }

            if is_unknown {
                unknown_url_number += 1;
            }

            if is_unknown && !is_github {
                only_unknown += 1;
            }
        }


        summary.push_str(&format!("Nb of cve with Github urls : {}\n", github_url_number));
        summary.push_str(&format!("Nb of cve with Unknown urls : {}\n", unknown_url_number));
        summary.push_str(&format!("Nb of cve with only Unknown urls : {}\n", only_unknown));
        

        summary
    }
}




/// Normalized data structure for the dataset
#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct NormalizedCveSample {
    security_id: SecurityId,
    urls : HashSet<NormalizedUrl>
}

impl NormalizedSampleTrait for NormalizedCveSample {
    fn normalized(&self) -> Result<NormalizedCveSample, NormalizedError> {
        Ok(self.clone())
    }

    fn get_id(&self) -> String {
        self.security_id.to_string()
    }
}

impl NormalizedCveSample {
    pub fn new(cve_id: String, url: Vec<NormalizedUrl>) -> Result<NormalizedCveSample, NormalizedError> {
        if cve_id.is_empty() {
            return Err(NormalizedError::NoCveId);
        }
        if url.is_empty() {
            return Err(NormalizedError::NoUrl);
        }

        let security_id = SecurityId::new_from_raw(&cve_id);
        if security_id.is_err() {
            let err = security_id.unwrap_err();
            warn!("Error while parsing cve id : {}", err);
            return Err(NormalizedError::CveParsingError(err));
        }
        
        Ok(NormalizedCveSample {
            security_id: security_id.unwrap(),
            urls : url.into_iter().collect()
        })
    }

    pub fn mix(&mut self, sample: &NormalizedCveSample) -> Result<(), NormalizedMixError<NormalizedCveSample>> {

        if self.security_id != sample.security_id {
            return Err(NormalizedMixError::NotSameCveId(self.clone(), sample.clone(), self.security_id.clone(), sample.security_id.clone()));
        }

        self.urls.extend(sample.urls.iter().cloned());

        Ok(())
    }

    pub fn get_urls(&self) -> &HashSet<NormalizedUrl> {
        &self.urls
    }
}
