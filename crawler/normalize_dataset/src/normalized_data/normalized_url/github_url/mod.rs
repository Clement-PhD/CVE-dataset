use std::fmt::Display;
use serde_derive::{Serialize, Deserialize};

use self::commit::GithubCommitUrl;
use self::pull_request::GithubPullRequestUrl;

use super::UrlParsingError;

pub mod commit;
pub mod pull_request;






#[derive(Debug, Deserialize, Serialize, Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
pub enum GithubUrl {
    Commit(GithubCommitUrl),
    PullRequest(GithubPullRequestUrl),
}

impl GithubUrl {
    pub fn from_raw(url: &str) -> Result<GithubUrl, UrlParsingError> {
        if let Ok(commit) = GithubCommitUrl::from_raw(url) {
            return Ok(GithubUrl::Commit(commit));
        }

        if let Ok(pr) = GithubPullRequestUrl::from_raw_normal(url) {
            return Ok(GithubUrl::PullRequest(pr));
        }
        
        Err(UrlParsingError::InvalidUrl(url.to_string()))
        
    }

    pub fn from_project_and_sha(project: &str, sha: &str, diff : Option<String>) -> Result<GithubUrl, UrlParsingError> {
        let commit = GithubCommitUrl::new(project.to_string(), sha.to_string(), diff)?;

        Ok(GithubUrl::Commit(commit))
    }

    /// Get a github url from a project name (e.g. : xorg/xserver) from a project url if the url is a github project url
    pub fn get_github_project_url(url: &str) -> Option<String> {
        let re = regex::Regex::new(r"^https?:\/\/(?:www.)?github\.com\/([^\/]+)\/([^\/]+)").unwrap();
        if let Some(captures) = re.captures(url) {
            Some(format!("{}/{}", captures.get(1).unwrap().as_str(), captures.get(2).unwrap().as_str()))
        } else {
            None
        }
    }
}

impl Display for GithubUrl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            GithubUrl::Commit(commit) => write!(f, "{}", commit),
            GithubUrl::PullRequest(pr) => write!(f, "{}", pr),
        }
    }
}

impl From<GithubCommitUrl> for GithubUrl {
    fn from(commit: GithubCommitUrl) -> Self {
        GithubUrl::Commit(commit)
    }
}