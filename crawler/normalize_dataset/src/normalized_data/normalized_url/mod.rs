use self::github_url::GithubUrl;
use self::unknown_url::UnknownUrl;

use std::fmt::Display;
use serde_derive::{Serialize, Deserialize};

pub mod github_url;
pub mod unknown_url;


#[derive(Debug)]
pub enum UrlParsingError {
    InvalidUrl(String),
    InvalidProject(String),
    InvalidSha(String),
}

impl Display for UrlParsingError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            UrlParsingError::InvalidUrl(url) => write!(f, "Invalid url: {}", url),
            UrlParsingError::InvalidProject(project) => write!(f, "Invalid project: {}", project),
            UrlParsingError::InvalidSha(sha) => write!(f, "Invalid sha: {}", sha),
        }
    }
}

pub(self) const PROJECT_RE : &'static str = r"^[^\/]+/[^\/]+?$";

/// A normalized url
#[derive(Debug, Deserialize, Serialize, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub enum NormalizedUrl {
    GithubUrl(GithubUrl),
    UnknownUrl(UnknownUrl),
}

impl NormalizedUrl {
    /// Get a NormalizedUrl from a raw url
    pub fn from_raw(url: &str) -> Result<NormalizedUrl, UrlParsingError> {
        GithubUrl::from_raw(url).map(NormalizedUrl::from)
    }

    /// Get a NormalizedUrl from a project url (e.g. : https://gitlab.freedesktop.org/xorg/xserver) and a sha
    pub fn from_project_and_sha(project: &str, sha: &str, diff : Option<String>) -> Result<NormalizedUrl, UrlParsingError> {
        if let Some(url) = GithubUrl::get_github_project_url(project) {
            return GithubUrl::from_project_and_sha(&url, sha, diff).map(NormalizedUrl::from);
        }

        UnknownUrl::from_project_and_sha(project, sha).map(NormalizedUrl::from)
    }

    /// Get a github url from a project name (e.g. : xorg/xserver) and a sha
    pub fn from_project_and_sha_github(project: &str, sha: &str, diff : Option<String>) -> Result<NormalizedUrl, UrlParsingError> {
        GithubUrl::from_project_and_sha(project, sha, diff).map(NormalizedUrl::from)
    }

    pub fn is_github_url(&self) -> bool {
        match self {
            NormalizedUrl::GithubUrl(_) => true,
            _ => false,
        }
    }

    pub fn is_unknown_url(&self) -> bool {
        match self {
            NormalizedUrl::UnknownUrl(_) => true,
            _ => false,
        }
    }
}

impl From<UnknownUrl> for NormalizedUrl {
    fn from(url: UnknownUrl) -> Self {
        NormalizedUrl::UnknownUrl(url)
    }
}

impl From<GithubUrl> for NormalizedUrl {
    fn from(url: GithubUrl) -> Self {
        NormalizedUrl::GithubUrl(url)
    }
}

impl Display for NormalizedUrl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            NormalizedUrl::GithubUrl(url) => write!(f, "{}", url),
            NormalizedUrl::UnknownUrl(url) => write!(f, "{}", url),
        }
    }
}


#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_project_re_valid_1() {
        let project = "xorg/xserver";
        assert!(regex::Regex::new(PROJECT_RE).unwrap().is_match(project));
    }

    #[test]
    fn test_project_re_valid_2() {
        let project = "horde/Mime_Viewer";
        assert!(regex::Regex::new(PROJECT_RE).unwrap().is_match(project));
    }

    #[test]
    fn test_project_re_valid_3() {
        let project = "sshnet/SSH.NET";
        assert!(regex::Regex::new(PROJECT_RE).unwrap().is_match(project));
    }

    #[test]
    fn test_project_re_valid_4() {
        let project = "wiris/moodle-filter_wiris";
        assert!(regex::Regex::new(PROJECT_RE).unwrap().is_match(project));
    }

    #[test]
    fn test_project_re_invalid() {
        let project = "xorg";
        assert!(!regex::Regex::new(PROJECT_RE).unwrap().is_match(project));
    }

    #[test]
    fn test_project_re_invalid_url() {
        let project = "https://gitlab.freedesktop.org/xorg/xserver";
        assert!(!regex::Regex::new(PROJECT_RE).unwrap().is_match(project));
    }
}