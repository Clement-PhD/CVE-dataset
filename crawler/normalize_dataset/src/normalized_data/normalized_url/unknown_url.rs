use super::{UrlParsingError, PROJECT_RE};

use std::fmt::Display;
use serde_derive::{Serialize, Deserialize};



/// an unknown url represented by a domain, a project and a sha
#[derive(Debug, Deserialize, Serialize, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct UnknownUrl {
    domain: String,
    project: String,
    sha: String,
}

impl Display for UnknownUrl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "https://{}/{}#{}", self.domain, self.project, self.sha)
    }
}

impl UnknownUrl {
    /// Create a new UnknownUrl
    pub fn new(domain: String, project: String, sha: String) -> Result<UnknownUrl, UrlParsingError> {
        let project = project.trim().to_string();
        let sha = sha.trim().to_string();

        let re = regex::Regex::new(PROJECT_RE).unwrap();
        if !re.is_match(&project) {
            return Err(UrlParsingError::InvalidProject(project));
        }

        Ok(UnknownUrl {
            domain,
            project,
            sha
        })
    }

    /// Create a new UnknownUrl from a project url and a sha
    pub fn from_project_and_sha(project_url: &str, sha: &str) -> Result<UnknownUrl, UrlParsingError> {
        // Regular expression to match unknown URLs
        let re = regex::Regex::new(r"^https?:\/\/([^\/]+)\/([^\/]+)\/([^\/]+)").unwrap();

        if let Some(captures) = re.captures(project_url) {
            let domain = captures[1].to_string();
            let project = captures[2].to_string() + "/" + &captures[3];
            UnknownUrl::new(domain, project, sha.to_string())
        } else {
            Err(UrlParsingError::InvalidUrl(project_url.to_string()))
        }
    }

    /// Get the domain of the url
    pub fn get_domain(&self) -> &str {
        &self.domain
    }

    /// Get the project of the url
    pub fn get_project(&self) -> &str {
        &self.project
    }

    /// Get the sha of the url
    pub fn get_sha(&self) -> &str {
        &self.sha
    }
}