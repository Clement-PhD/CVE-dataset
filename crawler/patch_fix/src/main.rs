use std::fs::{self, File};
use std::io::BufReader;
use std::path::Path;

use download_dataset::download::file_warnings::WarningPayload;
use log::info;
use params::remove_bar;
use rust_utils::logger::common_logger::init_logger;
use rust_utils::utils::unzip_dir;

use crate::params::argv::get_program_args;


mod params;
mod pipeline;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    dotenv::dotenv().ok();
    init_logger();
    let args = get_program_args();
    info!("ðŸš€ Start fixing the patchs dataset.");

    

    let cves = list_cant_apply_patch_cves_path(args.output_folder_path)?;

    // for each cve, unzip it into the patch_fix folder
    let patch_fix_folder = Path::new(&args.patch_fix_folder_path);
    if args.rebuild_folder {

        if patch_fix_folder.exists() {
            fs::remove_dir_all(patch_fix_folder)?;
        }
        fs::create_dir_all(patch_fix_folder)?;

        info!("Unzipping cves into the patch_fix folder.");
        let bar = params::new_bar(cves.len() as u64);
        for cve in cves {
            bar.set_message(format!("unzip cve {}", cve.as_str()));
            let file_path = Path::new(&cve);
            unzip_dir(&file_path, &patch_fix_folder)?;
            bar.inc(1);
        }

        remove_bar(bar);
    }

    // for each folder launch the pipeline:

    let paths = fs::read_dir(patch_fix_folder)?;
    let mut sorted_paths = paths.filter_map(|path| {
        if path.is_ok() {
            let path = path.unwrap();
            if path.file_type().unwrap().is_dir() {
                return Some(path.path().to_str().unwrap().to_string());
            }
            None
        } else {
            None
        }
    }).collect::<Vec<_>>();
    sorted_paths.sort();

    let bar = params::new_bar(sorted_paths.len() as u64);

    for path in sorted_paths {
        bar.set_message(format!("fixing path {}", path.as_str()));
        pipeline::fix_patch_pipeline(path.as_str())?;


        bar.inc(1);
    }

    remove_bar(bar);


    
    

    Ok(())
}

/// build a list of archive (cve) with patch that cannot be applied
fn list_cant_apply_patch_cves_path<P : AsRef<Path>>(data_folder : P) -> Result<Vec<String>, Box<dyn std::error::Error>>{
    let paths = fs::read_dir(data_folder)?;
    let mut cves = Vec::new();
    let mut nb_paths = 0;
    for path in paths {
        nb_paths += 1;
        let path = path?;

        if path.file_type()?.is_file() {
            let file_path = path.path();
            let file_name = file_path.file_name().unwrap().to_str().unwrap();
            if file_name.ends_with(".zip") {
                // read the zip file
                let reader = BufReader::new(File::open(&file_path)?);
                let mut archive = zip::ZipArchive::new(reader)?;

                // isolate the error file if it exists
                let mut error_file_content : Option<String> = None;
                for i in 0..archive.len() {
                    let mut file = archive.by_index(i)?;
                    if file.name().ends_with("warnings.json") {
                        let mut writer: Vec<u8> = vec![];
                        std::io::copy(&mut file, &mut writer)?;
                        let content = String::from_utf8(writer).unwrap();
                        error_file_content = Some(content);
                        break;
                    }
                }
                
                if error_file_content.is_none() {
                    continue;
                }

                let error_file_content = error_file_content.unwrap();
                let errors : Vec<WarningPayload> = serde_json::from_str(&error_file_content).unwrap();

                // check if their is an error which is a CantApplyPatch

                let mut cant_apply_patch = false;
                for error in errors {
                    if *error.get_warning_type() == download_dataset::download::file_warnings::WarningType::CantApplyPatch {
                        cant_apply_patch = true;
                        break;
                    }
                }

                if cant_apply_patch {
                    cves.push(file_path.to_str().unwrap().to_string());
                }
            }
        }
    }

    info!("Cant apply patch cves: {}/{} ({}%)", cves.len(), nb_paths, (cves.len() as f32 / nb_paths as f32) * 100.0);


    Ok(cves)
}