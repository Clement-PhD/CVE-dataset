use std::fs;
use std::path::Path;

use download_dataset::download::file_warnings::WarningPayload;
use download_dataset::utils::apply_patch_reverse;
use log::{info, warn};







pub fn fix_patch_pipeline<P : AsRef<Path>>(cve_folder_path : P) -> Result<(), Box<dyn std::error::Error>> {
    let cant_apply_patch_warnings = get_cant_apply_patch_warnings(&cve_folder_path)?;

    // try to apply the patch in the reverse order
    for warning in cant_apply_patch_warnings {
        let file_name = warning.get_file_name().to_string();
        let original_file_path = cve_folder_path.as_ref().join("original").join(&file_name);
        let fixed_file_path = cve_folder_path.as_ref().join("fixed").join(&file_name);
        let patch_file_path = cve_folder_path.as_ref().join("patch").join(format!("{}.patch", file_name));

        // beggin to add a carriage return to the end of the patch
        let patch_content = fs::read_to_string(&patch_file_path)?;
        let patched_content = format!("{}\n", patch_content);
        fs::write(&patch_file_path, patched_content)?;

        let success = apply_patch_reverse(
            &patch_file_path.to_str().unwrap(), 
            &fixed_file_path.to_str().unwrap(), 
            &original_file_path.to_str().unwrap(), 
            false
        );

        if !success {
            warn!("Failed to apply the patch in reverse for file : {}", file_name);
        }
    }
   
    Ok(())
}

/// get the warning and isolate the CantApplyPatch ones
fn get_cant_apply_patch_warnings<P : AsRef<Path>>(cve_folder_path : P) -> Result<Vec<WarningPayload>, Box<dyn std::error::Error>> {
    let mut cant_apply_patch_warnings = Vec::new();

    let warning_file_path = cve_folder_path.as_ref().join("warnings.json");
    if !warning_file_path.exists() {
        warn!("No warning file found in the folder : {}", cve_folder_path.as_ref().display());
        return Ok(Vec::new());
    }

    let warning_file_content = fs::read_to_string(&warning_file_path)?;

    let all_warnings : Vec<WarningPayload> = serde_json::from_str(&warning_file_content).unwrap();

    for warning in all_warnings {
        if *warning.get_warning_type() == download_dataset::download::file_warnings::WarningType::CantApplyPatch {
            //info!("Found a CantApplyPatch warning for file : {}", warning.get_file_name());
            cant_apply_patch_warnings.push(warning);
        }
    }


    Ok(cant_apply_patch_warnings)
}