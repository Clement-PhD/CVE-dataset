



import json
import os
import shutil

from download.github_request import GithubRequests
from download.pull_request import PullRequest
from download.warnings import CveWarnings, WarningType
from download.file_info import FileInfo



def download_pull_request(cve: str, pull_request: PullRequest, output_data_folder: str):
    """
    Download the pull request data and files from the Github API and save it to a folder in the output folder
    WARN : use the warning.json file to mark the pull request as downloaded
    """
    OUTPUT_CVE_FOLDER_PATH = os.path.join(output_data_folder, cve)
    warnings = CveWarnings(cve)
    # skip if the warning file already exists
    if os.path.exists(warnings.get_save_file_path(output_data_folder)):
        return
    else:
        # must clean the folder if it exists
        if os.path.exists(OUTPUT_CVE_FOLDER_PATH):
            shutil.rmtree(OUTPUT_CVE_FOLDER_PATH)


    request_maker = GithubRequests()

    # Get the pull request data from the Github API
    json_data = request_maker.get(pull_request.get_github_api_path())

    if json_data is None:
        print(f"Failed to get data from pull request {pull_request.url}")
        return

    # Prepare output paths using os.path.join
    os.makedirs(OUTPUT_CVE_FOLDER_PATH, exist_ok=True)
    OUTPUT_JSON_FILE_PATH = os.path.join(OUTPUT_CVE_FOLDER_PATH, "data.json")

    # Save the data to a file
    with open(OUTPUT_JSON_FILE_PATH, "w") as f:
        json.dump(json_data, f, indent=4)

    # Get the pull request files from the Github API
    json_data = request_maker.get(pull_request.get_github_api_files_path())

    if json_data is None:
        print(f"Failed to get files from pull request {pull_request.url}")
        with open(os.path.join(OUTPUT_CVE_FOLDER_PATH, "error.txt"), "w") as f:
            f.write(f"Failed to get files from pull request {pull_request.number}")
        return

    # Prepare the output folders and make their names uppercase
    OUTPUT_CVE_FILES_FOLDER_PATH = os.path.join(OUTPUT_CVE_FOLDER_PATH, "files")
    OUTPUT_CVE_ORIGINAL_FILES_FOLDER_PATH = os.path.join(OUTPUT_CVE_FILES_FOLDER_PATH, "original")
    OUTPUT_CVE_FIXED_FILES_FOLDER_PATH = os.path.join(OUTPUT_CVE_FILES_FOLDER_PATH, "fixed")
    OUTPUT_CVE_PATCH_FILES_FOLDER_PATH = os.path.join(OUTPUT_CVE_FILES_FOLDER_PATH, "patch")

    os.makedirs(OUTPUT_CVE_FILES_FOLDER_PATH, exist_ok=True)
    os.makedirs(OUTPUT_CVE_ORIGINAL_FILES_FOLDER_PATH, exist_ok=True)
    os.makedirs(OUTPUT_CVE_FIXED_FILES_FOLDER_PATH, exist_ok=True)
    os.makedirs(OUTPUT_CVE_PATCH_FILES_FOLDER_PATH, exist_ok=True)

    # Process the files
    for file_data in json_data:
        FILE = FileInfo.create(file_data, OUTPUT_CVE_FOLDER_PATH)

        # get the warning payload for this file
        warnings_payload = FILE.get_warning_payloads()
        for warning in warnings_payload:
            warnings.add_warning_payload(warning)


        # download the file
        downloaded = False
        if FILE.can_be_downloaded():
            downloaded = FILE.download()
        
        if not downloaded:
            warnings.add_warning(WarningType.CANT_DOWNLOADED, FILE.name, f"Failed to download file.")
            continue
        
        
        # save and apply the patch file
        if FILE.can_be_patched():
            patched = False
            patch_saved = FILE.save_patch()
            if not patch_saved:
                print(f"Failed to save patch file for {FILE.name}, \n {FILE.patch}")
                exit(1)

            # apply the patch to the file
            patched = FILE.apply_patch()
        
            if not patched:
                warnings.add_warning(WarningType.CANT_PATCHED, FILE.name, f"Failed to patch file.")
                continue

    
    warnings.save(output_data_folder)
