



from dataclasses import dataclass
from enum import Enum
import os
from typing import List

from download.warnings import WarningPayload, WarningType
from utils import apply_patch_reverse, download_file, try_to_fix_patch_file

class FileStatus(Enum):
    """Enum to store the status of a file in a pull request"""
    ADDED = "added"
    MODIFIED = "modified"
    REMOVED = "removed"
    RENAMED = "renamed"
    UNKNOWN = "unknown"

    @staticmethod
    def from_str(status: str) -> 'FileStatus':
        """Convert a string to a FileStatus"""
        if status == "added":
            return FileStatus.ADDED
        elif status == "modified":
            return FileStatus.MODIFIED
        elif status == "removed":
            return FileStatus.REMOVED
        elif status == "renamed":
            return FileStatus.RENAMED
        else:
            return FileStatus.UNKNOWN


@dataclass(frozen=True)
class FileInfo:
    """Class to store information about a file in a pull request. Wrapper arround the Github API response"""
    name: str
    raw_url: str | None
    patch: str | None
    status: FileStatus
    cve_files_folder_path : str


    @staticmethod
    def create(file_data: dict, cve_folder_path : str):
        """
        Create a FileInfo object from a Github API response
        WARN : The cve_files_folder_path is needed to get the file path of the file on the hardisk
        WARN : throws an exception if the file name is unknown
        """
        try:
            name = file_data["filename"]
        except TypeError:
            print(f"Failed to get filename from file data: {file_data}")
            exit(1)
        status = FileStatus.from_str(file_data["status"])
        raw_url = str(file_data["raw_url"]) if "raw_url" in file_data and file_data["raw_url"] is not None else None
        patch = str(file_data["patch"]) if "patch" in file_data and file_data["patch"] is not None else None
        cve_files_folder_path = os.path.join(cve_folder_path, "files")




        return FileInfo(
            name=name,
            status=status,
            raw_url=raw_url,
            patch=patch,
            cve_files_folder_path=cve_files_folder_path
        )
    # --------------------- info ---------------------
    
    def get_warning_payloads(self) -> List[WarningPayload]:
        """Get a warning payload for this file"""
        warnings : List[WarningPayload] = []


        if self.status != FileStatus.MODIFIED:
            warnings.append(WarningPayload(WarningType.NOT_MODIFIED, self.name, f"not a modified file (status: {self.status})\n"))
        
        if self.patch is None:
            warnings.append(WarningPayload(WarningType.NO_PATCH, self.name, f"File has no patch data.\n"))
        
        if self.raw_url is None:
            warnings.append(WarningPayload(WarningType.NO_URL, self.name, f"File has no raw url.\n"))
        
        return warnings
    
    def get_patch_name(self) -> str:
        """Get the name of the patch file"""
        return self.name + ".patch"
    
    def get_patch_path(self) -> str:
        """Get the path of the patch file"""
        return os.path.join(self.cve_files_folder_path, "patch", self.get_patch_name())
    
    def get_file_path(self) -> str:
        """Get the file path of the file on the hardisk"""
        if self.status == FileStatus.ADDED:
            return os.path.join(self.cve_files_folder_path, "fixed", self.name)
        elif self.status == FileStatus.MODIFIED:
            return os.path.join(self.cve_files_folder_path, "fixed", self.name)
        elif self.status == FileStatus.REMOVED:
            return os.path.join(self.cve_files_folder_path, "original", self.name)
        elif self.status == FileStatus.RENAMED:
            return os.path.join(self.cve_files_folder_path, "fixed", self.name)
        else:
            raise Exception(f"Unknown file status: {self.status}")
    
    # --------------------- check ---------------------

    def can_be_downloaded(self) -> bool:
        """Check if the file can be downloaded"""
        return self.raw_url is not None and self.status != FileStatus.UNKNOWN
    
    def can_be_patched(self) -> bool:
        """Check if the file can be patched"""
        return self.patch is not None and self.status != FileStatus.UNKNOWN

    # --------------------- actions ---------------------

    def download(self) -> bool:
        """Download the file"""
        if not self.can_be_downloaded():
            return False
        assert self.raw_url is not None
        # make sure the folder exists
        os.makedirs(os.path.dirname(self.get_file_path()), exist_ok=True)


        return download_file(self.raw_url, self.get_file_path())
    
    def save_patch(self) -> bool:
        """Save the patch to a file"""
        if not self.can_be_patched():
            return False
        assert self.patch is not None
        # make sure the folder exists
        patch_path = self.get_patch_path()
        os.makedirs(os.path.dirname(patch_path), exist_ok=True)

        # save the patch
        with open(patch_path, "wb") as f:
            f.write(self.patch.encode('utf-8'))

        return True
    
    def apply_patch(self) -> bool:
        """Apply the patch to the file"""
        if not self.can_be_patched():
            return False
        assert self.patch is not None
        # make sure the folder exists
        patched_file_path = os.path.join(self.cve_files_folder_path, "original", self.name)
        os.makedirs(os.path.dirname(patched_file_path), exist_ok=True)

        # try to apply the patch
        patched = apply_patch_reverse(self.get_patch_path(), self.get_file_path(), patched_file_path)
        if not patched:
            # try to fix the patch
            try_to_fix_patch_file(self.get_patch_path())
            # try to apply the patch again
            patched = apply_patch_reverse(self.get_patch_path(), self.get_file_path(), patched_file_path)
        
        return patched
    
    
    
        
        