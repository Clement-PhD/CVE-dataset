
from enum import Enum
import json
import re
from typing import Dict, List, Literal, Tuple, Set
from dataclasses import asdict, dataclass
import os

from download.warnings import CveWarnings, WarningPayload, WarningType

class Languages(Enum):
    C = 1
    Cpp = 2
    Java = 3
    Python = 4
    Ruby = 5
    Javascript = 6
    Rust = 7
    Go = 8
    HTML = 9
    PHP = 10

    @staticmethod
    def from_extension(extension: str):
        """Return the language associated to the extension"""
        if extension in [".cpp", ".hpp"]:
            return Languages.Cpp
        elif extension in [".c", ".h"]:
            return Languages.C
        elif extension in [".java"]:
            return Languages.Java
        elif extension in [".py"]:
            return Languages.Python
        elif extension in [".rb"]:
            return Languages.Ruby
        elif extension in [".js"]:
            return Languages.Javascript
        elif extension in [".rs"]:
            return Languages.Rust
        elif extension in [".go"]:
            return Languages.Go
        elif extension in [".html", ".htm"]:
            return Languages.HTML
        elif extension in [".php"]:
            return Languages.PHP
        else:
            return None
        
    def to_serializable(self):
        """Convert the enum member to a serializable format (e.g., its name)."""
        return self.name

    @staticmethod
    def from_serializable(name: str):
        """Convert a serializable format (e.g., name) back to an enum member."""
        return Languages[name]

@dataclass(frozen=True)
class CVEStats:
    """Class to handle one CVE statistics"""
    data_folder_path: str
    pull_requests_urls: list[str]

    cve_name: str
    repo : str
    warnings : CveWarnings | None

    files_extension_stats: Dict[str, int]
    file_number: int

    removed_files_number: int
    added_files_number: int

    nb_lines_affected: int

    PRIVATE_KEY_EXTENSIONS = [
        ".pem",
        ".key",
        ".pkcs8",
        ".pub",
        ".p12",
        ".pfx",
        ".asc",
        ".der",
        ".crt",
        ".cer",
        ".p7b",
        ".p7c",
        ".p7r",
        ".p7m",
        ".p7s",
    ]
    private_key_files : List[str]


    languages : Set[Languages]

    # --------------------------- serialization ---------------------------

    def to_serializable(self):
        """Convert the CVEStats instance to a serializable format (dictionary)."""
        data = asdict(self)
        data['languages'] = [lang.to_serializable() for lang in self.languages]
        data['warnings'] = self.warnings.to_serializable() if self.warnings else None
        return data

    @staticmethod
    def from_serializable(data: dict):
        """Convert a serializable format (dictionary) back to a CVEStats instance."""
        languages = set(Languages.from_serializable(lang) for lang in data['languages'])
        warnings = CveWarnings.from_serializable(data['warnings']) if data['warnings'] else None
        return CVEStats(
            data_folder_path=data['data_folder_path'],
            pull_requests_urls=data['pull_requests_urls'],
            cve_name=data['cve_name'],
            repo=data['repo'],
            warnings=warnings,
            files_extension_stats=data['files_extension_stats'],
            file_number=data['file_number'],
            removed_files_number=data['removed_files_number'],
            added_files_number=data['added_files_number'],
            nb_lines_affected=data['nb_lines_affected'],
            languages=languages,
            private_key_files=data['private_key_files']

        )

    def save(self, file_path: str):
        """Save the CVEStats instance to a file."""
        with open(file_path, "w") as f:
            json.dump(self.to_serializable(), f, indent=4)
    
    @staticmethod
    def load(file_path: str) -> 'CVEStats':
        """Load a CVEStats instance from a file."""
        with open(file_path, "r") as f:
            data = json.load(f)
            return CVEStats.from_serializable(data)

    # --------------------------- factory function ---------------------------

    @staticmethod
    def create_cve_stats(cve_folder_path : str, pull_requests_urls : list[str]) -> 'CVEStats':
        """
        Initialize the class
        :param data_folder_path: path to the folder containing the data of the cve
        :param pull_requests_urls: list of pull requests urls
        """

        cve_name = os.path.basename(cve_folder_path)
        repo = CVEStats.__extract_repo_from_pull_request_url(pull_requests_urls[0])
        assert repo is not None


        file_number, extension_stats = CVEStats.__load_extension_stats(cve_folder_path, type_of_files="patch")

        languages = set()
        for extension in extension_stats.keys():
            language = Languages.from_extension(extension)
            if language:
                languages.add(language)
        
        warnings = CVEStats.__load_warnings(cve_folder_path)

        if warnings:
            removed_files_number, added_files_number = CVEStats.__load_not_modified_files_number(warnings)
        else:
            removed_files_number = 0
            added_files_number = 0
        
        nb_lines_affected = CVEStats.__get_nb_lines_affected(cve_folder_path)

        private_key_files = CVEStats.__load_private_key_files_relatif_paths(cve_folder_path)

        return CVEStats(
            data_folder_path=cve_folder_path, 
            pull_requests_urls=pull_requests_urls, 

            cve_name=cve_name,
            repo=repo,
            warnings=warnings,

            files_extension_stats=extension_stats,
            file_number=file_number,

            languages=languages,

            removed_files_number=removed_files_number,
            added_files_number=added_files_number,

            private_key_files=private_key_files,

            nb_lines_affected=nb_lines_affected
        )
    
    @staticmethod
    def __extract_repo_from_pull_request_url(url : str) -> str | None:
        match = re.search(r'github\.com/([^/]+/[^/]+)/pull/', url)
        if match:
            return str(match.group(1))
        else:
            return None
    
    @staticmethod
    def __get_nb_lines_affected(cve_folder_path : str) -> int:
        """
        Get the number of lines affected by the CVE
        count the line of the patch files beginning with + or -
        """
        nb_lines_affected = 0

        patch_files_folder_path = os.path.join(cve_folder_path, "files", "patch")

        # Walk through the directory
        for root, dirs, files in os.walk(patch_files_folder_path):
            for file in files:
                # Update total file count
                with open(os.path.join(root, file), "r") as f:
                    for line in f:
                        if line.startswith("+") or line.startswith("-"):
                            nb_lines_affected += 1

        return nb_lines_affected

    @staticmethod
    def __load_not_modified_files_number(warnings : CveWarnings) -> Tuple[int, int]:
        """
        Load the number of not modified files from warnings
        :return: (removed_files_number, added_files_number)
        """
        def is_added(warning : WarningPayload) -> bool | None:
            """Return true if the warning is about a file added, false if it is about a file deleted"""
            if warning.type == WarningType.NOT_MODIFIED:
                match = re.search(r'\(status:\s*(\w+)\)', string=warning.message)

                if match:
                    status = match.group(1)
                    return status == "FileStatus.ADDED"
                else:
                    return None
            else :
                return None
            
        removed_files_number = 0
        added_files_number = 0

        for warning in warnings.warnings:
            is_added_result = is_added(warning)
            if is_added_result is not None:
                if is_added_result:
                    added_files_number += 1
                else:
                    removed_files_number += 1

        return removed_files_number, added_files_number


        

    @staticmethod
    def __load_warnings(cve_folder_path :str):
        """Load the warnings from the warnings.json file"""
        warnings_json_file_path = os.path.join(cve_folder_path, "warnings.json")
        if os.path.exists(warnings_json_file_path):
            with open(warnings_json_file_path, "r") as f:
                warnings_json = json.load(f)
                return CveWarnings.from_serializable(warnings_json)
        else:
            return None
        
    @staticmethod
    def __load_extension_stats(cve_folder_path: str, type_of_files : Literal["fixed", "original", "patch"]) -> Tuple[int, Dict[str, int]]:
        """Load the extension stats from the files in the fixed folder (modified files)"""
        modified_extension_stats: Dict[str, int] = {}  # extension -> number of files
        modified_file_number = 0

        modified_files_folder_path = os.path.join(cve_folder_path, "files", type_of_files)

        # Walk through the directory
        for root, dirs, files in os.walk(modified_files_folder_path):
            for file in files:
                # Update total file count
                modified_file_number += 1

                # if we are in the patch folder, we remove the suffixe .patch
                if type_of_files == "patch":
                    file = file[:-6]

                # Get the file extension and update the count for the extension
                _, extension = os.path.splitext(file)
                if extension:
                    extension = extension.lower()  # Normalize the extension to lowercase
                    modified_extension_stats[extension] = modified_extension_stats.get(extension, 0) + 1

        return modified_file_number, modified_extension_stats
       
    @staticmethod
    def __load_private_key_files_relatif_paths(cve_folder_path: str) -> List[str]:
        """Load the private key files from the files in the fixed folder (modified files)"""
        private_key_files: List[str] = []

        FOLDERS_TO_TEST = ["fixed", "original"]

        for folder in FOLDERS_TO_TEST:
            modified_files_folder_path = os.path.join(cve_folder_path, "files", folder)

            # Walk through the directory
            for root, dirs, files in os.walk(modified_files_folder_path):
                for file in files:
                    # Get the file extension and update the count for the extension
                    _, extension = os.path.splitext(file)
                    if extension:
                        extension = extension.lower()
                        if extension in CVEStats.PRIVATE_KEY_EXTENSIONS:
                            absolute_path = os.path.join(root, file)
                            relatif_path = os.path.relpath(absolute_path, modified_files_folder_path)
                            private_key_files.append(relatif_path)
        
        return list(set(private_key_files))  # remove duplicates