@@ -12,7 +12,7 @@
 from pip.download import urlopen
 from pip.exceptions import (BadCommand, InstallationError, UninstallationError,
                             CommandError)
-from pip.backwardcompat import StringIO
+from pip.backwardcompat import StringIO, ssl
 from pip.baseparser import ConfigOptionParser, UpdatingDefaultsHelpFormatter
 from pip.status_codes import SUCCESS, ERROR, UNKNOWN_ERROR, VIRTUALENV_NOT_FOUND
 from pip.util import get_prog
@@ -69,11 +69,15 @@ def _copy_option_group(self, parser, group):
 
     def merge_options(self, initial_options, options):
         # Make sure we have all global options carried over
-        for attr in ['log', 'proxy', 'require_venv',
-                     'log_explicit_levels', 'log_file',
-                     'timeout', 'default_vcs',
-                     'skip_requirements_regex',
-                     'no_input', 'exists_action']:
+        attrs = ['log', 'proxy', 'require_venv',
+                 'log_explicit_levels', 'log_file',
+                 'timeout', 'default_vcs',
+                 'skip_requirements_regex',
+                 'no_input', 'exists_action',
+                 'cert']
+        if not ssl:
+            attrs.append('insecure')
+        for attr in attrs:
             setattr(options, attr, getattr(initial_options, attr) or getattr(options, attr))
         options.quiet += initial_options.quiet
         options.verbose += initial_options.verbose
@@ -98,12 +102,21 @@ def main(self, args, initial_options):
 
         self.setup_logging()
 
+        #TODO: try to get these passing down from the command?
+        #      without resorting to os.environ to hold these.
+
         if options.no_input:
             os.environ['PIP_NO_INPUT'] = '1'
 
         if options.exists_action:
             os.environ['PIP_EXISTS_ACTION'] = ''.join(options.exists_action)
 
+        if not ssl and options.insecure:
+            os.environ['PIP_INSECURE'] = '1'
+
+        if options.cert:
+            os.environ['PIP_CERT'] = options.cert
+
         if options.require_venv:
             # If a venv is required check if it can really be found
             if not os.environ.get('VIRTUAL_ENV'):