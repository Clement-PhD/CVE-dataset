@@ -4,6 +4,7 @@
 # pylint: disable=no-member
 import ddt
 from lxml import etree
+from onelogin.saml2.errors import OneLogin_Saml2_Error
 import unittest
 from .testutil import AUTH_FEATURE_ENABLED, SAMLTestCase
 
@@ -26,8 +27,7 @@ def test_saml_disabled(self):
         response = self.client.get(self.METADATA_URL)
         self.assertEqual(response.status_code, 404)
 
-    @ddt.data('saml_key', 'saml_key_alt')  # Test two slightly different key pair export formats
-    def test_metadata(self, key_name):
+    def test_metadata(self):
         self.enable_saml()
         doc = self._fetch_metadata()
         # Check the ACS URL:
@@ -62,13 +62,44 @@ def test_custom_contact_info(self):
             support_email="joe@example.com"
         )
 
-    def test_signed_metadata(self):
+    @ddt.data(
+        # Test two slightly different key pair export formats
+        ('saml_key', 'MIICsDCCAhmgAw'),
+        ('saml_key_alt', 'MIICWDCCAcGgAw'),
+    )
+    @ddt.unpack
+    def test_signed_metadata(self, key_name, pub_key_starts_with):
         self.enable_saml(
+            private_key=self._get_private_key(key_name),
+            public_key=self._get_public_key(key_name),
             other_config_str='{"SECURITY_CONFIG": {"signMetadata": true} }',
         )
+        self._validate_signed_metadata(pub_key_starts_with=pub_key_starts_with)
+
+    def test_secure_key_configuration(self):
+        """ Test that the SAML private key can be stored in Django settings and not the DB """
+        self.enable_saml(
+            public_key='',
+            private_key='',
+            other_config_str='{"SECURITY_CONFIG": {"signMetadata": true} }',
+        )
+        with self.assertRaises(OneLogin_Saml2_Error):
+            self._fetch_metadata()  # OneLogin_Saml2_Error: Cannot sign metadata: missing SP private key.
+        with self.settings(
+            SOCIAL_AUTH_SAML_SP_PRIVATE_KEY=self._get_private_key('saml_key'),
+            SOCIAL_AUTH_SAML_SP_PUBLIC_CERT=self._get_public_key('saml_key'),
+        ):
+            self._validate_signed_metadata()
+
+    def _validate_signed_metadata(self, pub_key_starts_with='MIICsDCCAhmgAw'):
+        """ Fetch the SAML metadata and do some validation """
         doc = self._fetch_metadata()
         sig_node = doc.find(".//{}".format(etree.QName(XMLDSIG_XML_NS, 'SignatureValue')))
         self.assertIsNotNone(sig_node)
+        # Check that the right public key was used:
+        pub_key_node = doc.find(".//{}".format(etree.QName(XMLDSIG_XML_NS, 'X509Certificate')))
+        self.assertIsNotNone(pub_key_node)
+        self.assertIn(pub_key_starts_with, pub_key_node.text)
 
     def _fetch_metadata(self):
         """ Fetch and parse the metadata XML at self.METADATA_URL """