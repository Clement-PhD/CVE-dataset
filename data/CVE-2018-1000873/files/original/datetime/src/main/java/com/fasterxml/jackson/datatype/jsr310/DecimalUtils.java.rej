--- /dev/null
+++ /dev/null
@@ -92,51 +91,12 @@ public static BigDecimal toBigDecimal(long seconds, int nanoseconds)
         }
         return new BigDecimal(toDecimal(seconds, nanoseconds));
     }
-
-    /**
-     * @Deprecated due to potential unbounded latency on some JRE releases.
-     */
+    
     public static int extractNanosecondDecimal(BigDecimal value, long integer)
     {
         // !!! 14-Mar-2016, tatu: Somewhat inefficient; should replace with functionally
         //   equivalent code that just subtracts integral part? (or, measure and show
         //   there's no difference and do nothing... )
         return value.subtract(new BigDecimal(integer)).multiply(ONE_BILLION).intValue();
     }
-
-
-    /**
-     * Extracts the seconds and nanoseconds component of {@code seconds} as {@code long} and {@code int}
-     * values, passing them to the given converter.   The implementation avoids latency issues present
-     * on some JRE releases.
-     *
-     * @since 2.9.8
-     */
-    public static <T> T extractSecondsAndNanos(BigDecimal seconds, BiFunction<Long, Integer, T> convert)
-    {
-        // Complexity is here to workaround unbounded latency in some BigDecimal operations.
-        //   https://github.com/FasterXML/jackson-databind/issues/2141
-
-        long secondsOnly;
-        int nanosOnly;
-
-        BigDecimal nanoseconds = seconds.scaleByPowerOfTen(9);
-        if (nanoseconds.precision() - nanoseconds.scale() <= 0) {
-            // There are no non-zero digits to the left of the decimal point.
-            // This protects against very negative exponents.
-            secondsOnly = nanosOnly = 0;
-        }
-        else if (seconds.scale() < -63) {
-            // There would be no low-order bits once we chop to a long.
-            // This protects against very positive exponents.
-            secondsOnly = nanosOnly = 0;
-        }
-        else {
-            // Now we know that seconds has reasonable scale, we can safely chop it apart.
-            secondsOnly = seconds.longValue();
-            nanosOnly = nanoseconds.subtract(new BigDecimal(secondsOnly).scaleByPowerOfTen(9)).intValue();
-        }
-
-        return convert.apply(secondsOnly, nanosOnly);
-    }
 
