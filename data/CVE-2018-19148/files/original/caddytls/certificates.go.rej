--- /dev/null
+++ /dev/null
@@ -243,104 +203,65 @@ func fillCertFromLeaf(cert *Certificate, tlsCert tls.Certificate) error {
 		return errors.New("certificate has no names")
 	}
 
-	// save the hash of this certificate (chain) and
-	// expiration date, for necessity and efficiency
-	cert.Hash = hashCertificateChain(cert.Certificate.Certificate)
 	cert.NotAfter = leaf.NotAfter
 
 	return nil
 }
 
-// hashCertificateChain computes the unique hash of certChain,
-// which is the chain of DER-encoded bytes. It returns the
-// hex encoding of the hash.
-func hashCertificateChain(certChain [][]byte) string {
-	h := sha256.New()
-	for _, certInChain := range certChain {
-		h.Write(certInChain)
-	}
-	return fmt.Sprintf("%x", h.Sum(nil))
-}
-
-// managedCertInStorageExpiresSoon returns true if cert (being a
-// managed certificate) is expiring within RenewDurationBefore.
-// It returns false if there was an error checking the expiration
-// of the certificate as found in storage, or if the certificate
-// in storage is NOT expiring soon. A certificate that is expiring
-// soon in our cache but is not expiring soon in storage probably
-// means that another instance renewed the certificate in the
-// meantime, and it would be a good idea to simply load the cert
-// into our cache rather than repeating the renewal process again.
-func managedCertInStorageExpiresSoon(cert Certificate) (bool, error) {
-	if len(cert.configs) == 0 {
-		return false, fmt.Errorf("no configs for certificate")
-	}
-	storage, err := cert.configs[0].StorageFor(cert.configs[0].CAUrl)
-	if err != nil {
-		return false, err
-	}
-	siteData, err := storage.LoadSite(cert.Names[0])
-	if err != nil {
-		return false, err
-	}
-	tlsCert, err := tls.X509KeyPair(siteData.Cert, siteData.Key)
-	if err != nil {
-		return false, err
-	}
-	leaf, err := x509.ParseCertificate(tlsCert.Certificate[0])
-	if err != nil {
-		return false, err
-	}
-	timeLeft := leaf.NotAfter.Sub(time.Now().UTC())
-	return timeLeft < RenewDurationBefore, nil
-}
-
-// cacheCertificate adds cert to the in-memory cache. If a certificate
-// with the same hash is already cached, it is NOT overwritten; instead,
-// cfg is added to the existing certificate's list of configs if not
-// already in the list. Then all the names on cert are used to add
-// entries to cfg.Certificates (the config's name lookup map).
-// Then the certificate is stored/updated in the cache. It returns
-// a copy of the certificate that ends up being stored in the cache.
+// cacheCertificate adds cert to the in-memory cache. If the cache is
+// empty, cert will be used as the default certificate. If the cache is
+// full, random entries are deleted until there is room to map all the
+// names on the certificate.
 //
-// It is VERY important, even for some test cases, that the Hash field
-// of the cert be set properly.
+// This certificate will be keyed to the names in cert.Names. Any names
+// already used as a cache key will NOT be replaced by this cert; in
+// other words, no overlap is allowed, and this certificate will not
+// service those pre-existing names.
 //
 // This function is safe for concurrent use.
-func (cfg *Config) cacheCertificate(cert Certificate) Certificate {
-	cfg.certCache.Lock()
-	defer cfg.certCache.Unlock()
-
-	// if this certificate already exists in the cache,
-	// use it instead of overwriting it -- very important!
-	if existingCert, ok := cfg.certCache.cache[cert.Hash]; ok {
-		cert = existingCert
+func cacheCertificate(cert Certificate) {
+	if cert.Config == nil {
+		cert.Config = new(Config)
 	}
-
-	// attach this config to the certificate so we know which
-	// configs are referencing/using the certificate, but don't
-	// duplicate entries
-	var found bool
-	for _, c := range cert.configs {
-		if c == cfg {
-			found = true
+	certCacheMu.Lock()
+	if _, ok := certCache[""]; !ok {
+		// use as default - must be *appended* to end of list, or bad things happen!
+		cert.Names = append(cert.Names, "")
+	}
+	for len(certCache)+len(cert.Names) > 10000 {
+		// for simplicity, just remove random elements
+		for key := range certCache {
+			if key == "" { // ... but not the default cert
+				continue
+			}
+			delete(certCache, key)
 			break
 		}
 	}
-	if !found {
-		cert.configs = append(cert.configs, cfg)
+	for i := 0; i < len(cert.Names); i++ {
+		name := cert.Names[i]
+		if _, ok := certCache[name]; ok {
+			// do not allow certificates to overlap in the names they serve;
+			// this ambiguity causes problems because it is confusing while
+			// maintaining certificates; see OCSP maintenance code and
+			// https://caddy.community/t/random-ocsp-response-errors-for-random-clients/2473?u=matt.
+			log.Printf("[NOTICE] There is already a certificate loaded for %s, "+
+				"so certificate for %v will not service that name",
+				name, cert.Names)
+			cert.Names = append(cert.Names[:i], cert.Names[i+1:]...)
+			i--
+			continue
+		}
+		certCache[name] = cert
 	}
+	certCacheMu.Unlock()
+}
 
-	// key the certificate by all its names for this config only,
-	// this is how we find the certificate during handshakes
-	// (yes, if certs overlap in the names they serve, one will
-	// overwrite another here, but that's just how it goes)
-	for _, name := range cert.Names {
-		cfg.Certificates[name] = cert.Hash
-	}
-
-	// store the certificate
-	cfg.certCache.cache[cert.Hash] = cert
-
-	return cert
+// uncacheCertificate deletes name's certificate from the
+// cache. If name is not a key in the certificate cache,
+// this function does nothing.
+func uncacheCertificate(name string) {
+	certCacheMu.Lock()
+	delete(certCache, name)
+	certCacheMu.Unlock()
 
