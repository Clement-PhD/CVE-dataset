@@ -87,119 +87,150 @@ func maintainAssets(stopChan chan struct{}) {
 // RenewManagedCertificates renews managed certificates,
 // including ones loaded on-demand.
 func RenewManagedCertificates(allowPrompts bool) (err error) {
-	var renewQueue, deleteQueue []Certificate
-	visitedNames := make(map[string]struct{})
-
-	certCacheMu.RLock()
-	for name, cert := range certCache {
-		if !cert.Config.Managed || cert.Config.SelfSigned {
-			continue
-		}
-
-		// the list of names on this cert should never be empty...
-		if cert.Names == nil || len(cert.Names) == 0 {
-			log.Printf("[WARNING] Certificate keyed by '%s' has no names: %v - removing from cache", name, cert.Names)
-			deleteQueue = append(deleteQueue, cert)
-			continue
-		}
-
-		// skip names whose certificate we've already renewed
-		if _, ok := visitedNames[name]; ok {
+	for _, inst := range caddy.Instances() {
+		inst.StorageMu.RLock()
+		certCache, ok := inst.Storage[CertCacheInstStorageKey].(*certificateCache)
+		inst.StorageMu.RUnlock()
+		if !ok || certCache == nil {
 			continue
 		}
-		for _, name := range cert.Names {
-			visitedNames[name] = struct{}{}
-		}
 
-		// if its time is up or ending soon, we need to try to renew it
-		timeLeft := cert.NotAfter.Sub(time.Now().UTC())
-		if timeLeft < RenewDurationBefore {
-			log.Printf("[INFO] Certificate for %v expires in %v; attempting renewal", cert.Names, timeLeft)
+		// we use the queues for a very important reason: to do any and all
+		// operations that could require an exclusive write lock outside
+		// of the read lock! otherwise we get a deadlock, yikes. in other
+		// words, our first iteration through the certificate cache does NOT
+		// perform any operations--only queues them--so that more fine-grained
+		// write locks may be obtained during the actual operations.
+		var renewQueue, reloadQueue, deleteQueue []Certificate
+
+		certCache.RLock()
+		for certKey, cert := range certCache.cache {
+			if len(cert.configs) == 0 {
+				// this is bad if this happens, probably a programmer error (oops)
+				log.Printf("[ERROR] No associated TLS config for certificate with names %v; unable to manage", cert.Names)
+				continue
+			}
+			if !cert.configs[0].Managed || cert.configs[0].SelfSigned {
+				continue
+			}
 
-			if cert.Config == nil {
-				log.Printf("[ERROR] %s: No associated TLS config; unable to renew", name)
+			// the list of names on this cert should never be empty... programmer error?
+			if cert.Names == nil || len(cert.Names) == 0 {
+				log.Printf("[WARNING] Certificate keyed by '%s' has no names: %v - removing from cache", certKey, cert.Names)
+				deleteQueue = append(deleteQueue, cert)
 				continue
 			}
 
-			// queue for renewal when we aren't in a read lock anymore
-			// (the TLS-SNI challenge will need a write lock in order to
-			// present the certificate, so we renew outside of read lock)
-			renewQueue = append(renewQueue, cert)
-		}
-	}
-	certCacheMu.RUnlock()
-
-	// Perform renewals that are queued
-	for _, cert := range renewQueue {
-		// Get the name which we should use to renew this certificate;
-		// we only support managing certificates with one name per cert,
-		// so this should be easy. We can't rely on cert.Config.Hostname
-		// because it may be a wildcard value from the Caddyfile (e.g.
-		// *.something.com) which, as of Jan. 2017, is not supported by ACME.
-		var renewName string
-		for _, name := range cert.Names {
-			if name != "" {
-				renewName = name
-				break
+			// if time is up or expires soon, we need to try to renew it
+			timeLeft := cert.NotAfter.Sub(time.Now().UTC())
+			if timeLeft < RenewDurationBefore {
+				// see if the certificate in storage has already been renewed, possibly by another
+				// instance of Caddy that didn't coordinate with this one; if so, just load it (this
+				// might happen if another instance already renewed it - kinda sloppy but checking disk
+				// first is a simple way to possibly drastically reduce rate limit problems)
+				storedCertExpiring, err := managedCertInStorageExpiresSoon(cert)
+				if err != nil {
+					// hmm, weird, but not a big deal, maybe it was deleted or something
+					log.Printf("[NOTICE] Error while checking if certificate for %v in storage is also expiring soon: %v",
+						cert.Names, err)
+				} else if !storedCertExpiring {
+					// if the certificate is NOT expiring soon and there was no error, then we
+					// are good to just reload the certificate from storage instead of repeating
+					// a likely-unnecessary renewal procedure
+					reloadQueue = append(reloadQueue, cert)
+					continue
+				}
+
+				// the certificate in storage has not been renewed yet, so we will do it
+				// NOTE 1: This is not correct 100% of the time, if multiple Caddy instances
+				// happen to run their maintenance checks at approximately the same times;
+				// both might start renewal at about the same time and do two renewals and one
+				// will overwrite the other. Hence TLS storage plugins. This is sort of a TODO.
+				// NOTE 2: It is super-important to note that the TLS-SNI challenge requires
+				// a write lock on the cache in order to complete its challenge, so it is extra
+				// vital that this renew operation does not happen inside our read lock!
+				renewQueue = append(renewQueue, cert)
 			}
 		}
+		certCache.RUnlock()
 
-		// perform renewal
-		err := cert.Config.RenewCert(renewName, allowPrompts)
-		if err != nil {
-			if allowPrompts {
-				// Certificate renewal failed and the operator is present. See a discussion
-				// about this in issue 642. For a while, we only stopped if the certificate
-				// was expired, but in reality, there is no difference between reporting
-				// it now versus later, except that there's somebody present to deal with
-				// it right now.
-				timeLeft := cert.NotAfter.Sub(time.Now().UTC())
-				if timeLeft < RenewDurationBeforeAtStartup {
-					// See issue 1680. Only fail at startup if the certificate is dangerously
-					// close to expiration.
-					return err
+		// Reload certificates that merely need to be updated in memory
+		for _, oldCert := range reloadQueue {
+			timeLeft := oldCert.NotAfter.Sub(time.Now().UTC())
+			log.Printf("[INFO] Certificate for %v expires in %v, but is already renewed in storage; reloading stored certificate",
+				oldCert.Names, timeLeft)
+
+			err = certCache.reloadManagedCertificate(oldCert)
+			if err != nil {
+				if allowPrompts {
+					return err // operator is present, so report error immediately
 				}
+				log.Printf("[ERROR] Loading renewed certificate: %v", err)
 			}
-			log.Printf("[ERROR] %v", err)
-			if cert.Config.OnDemand {
-				// loaded dynamically, removed dynamically
-				deleteQueue = append(deleteQueue, cert)
-			}
-		} else {
-			// successful renewal, so update in-memory cache by loading
-			// renewed certificate so it will be used with handshakes
+		}
 
-			// we must delete all the names this cert services from the cache
-			// so that we can replace the certificate, because replacing names
-			// already in the cache is not allowed, to avoid later conflicts
-			// with renewals.
-			// TODO: It would be nice if this whole operation were idempotent;
-			// i.e. a thread-safe function to replace a certificate in the cache,
-			// see also handshake.go for on-demand maintenance.
-			certCacheMu.Lock()
-			for _, name := range cert.Names {
-				delete(certCache, name)
+		// Renewal queue
+		for _, oldCert := range renewQueue {
+			timeLeft := oldCert.NotAfter.Sub(time.Now().UTC())
+			log.Printf("[INFO] Certificate for %v expires in %v; attempting renewal", oldCert.Names, timeLeft)
+
+			// Get the name which we should use to renew this certificate;
+			// we only support managing certificates with one name per cert,
+			// so this should be easy. We can't rely on cert.Config.Hostname
+			// because it may be a wildcard value from the Caddyfile (e.g.
+			// *.something.com) which, as of Jan. 2017, is not supported by ACME.
+			// TODO: ^ ^ ^ (wildcards)
+			renewName := oldCert.Names[0]
+
+			// perform renewal
+			err := oldCert.configs[0].RenewCert(renewName, allowPrompts)
+			if err != nil {
+				if allowPrompts {
+					// Certificate renewal failed and the operator is present. See a discussion
+					// about this in issue 642. For a while, we only stopped if the certificate
+					// was expired, but in reality, there is no difference between reporting
+					// it now versus later, except that there's somebody present to deal with
+					// it right now. Follow-up: See issue 1680. Only fail in this case if the
+					// certificate is dangerously close to expiration.
+					timeLeft := oldCert.NotAfter.Sub(time.Now().UTC())
+					if timeLeft < RenewDurationBeforeAtStartup {
+						return err
+					}
+				}
+				log.Printf("[ERROR] %v", err)
+				if oldCert.configs[0].OnDemand {
+					// loaded dynamically, remove dynamically
+					deleteQueue = append(deleteQueue, oldCert)
+				}
+				continue
 			}
-			certCacheMu.Unlock()
 
-			// put the certificate in the cache
-			_, err := cert.Config.CacheManagedCertificate(cert.Names[0])
+			// successful renewal, so update in-memory cache by loading
+			// renewed certificate so it will be used with handshakes
+			err = certCache.reloadManagedCertificate(oldCert)
 			if err != nil {
 				if allowPrompts {
 					return err // operator is present, so report error immediately
 				}
 				log.Printf("[ERROR] %v", err)
 			}
 		}
-	}
 
-	// Apply queued deletion changes to the cache
-	for _, cert := range deleteQueue {
-		certCacheMu.Lock()
-		for _, name := range cert.Names {
-			delete(certCache, name)
+		// Deletion queue
+		for _, cert := range deleteQueue {
+			certCache.Lock()
+			// remove any pointers to this certificate from Configs
+			for _, cfg := range cert.configs {
+				for name, certKey := range cfg.Certificates {
+					if certKey == cert.Hash {
+						delete(cfg.Certificates, name)
+					}
+				}
+			}
+			// then delete the certificate from the cache
+			delete(certCache.cache, cert.Hash)
+			certCache.Unlock()
 		}
-		certCacheMu.Unlock()
 	}
 
 	return nil
@@ -212,91 +243,75 @@ func RenewManagedCertificates(allowPrompts bool) (err error) {
 // Ryan Sleevi's recommendations for good OCSP support:
 // https://gist.github.com/sleevi/5efe9ef98961ecfb4da8
 func UpdateOCSPStaples() {
-	// Create a temporary place to store updates
-	// until we release the potentially long-lived
-	// read lock and use a short-lived write lock.
-	type ocspUpdate struct {
-		rawBytes []byte
-		parsed   *ocsp.Response
-	}
-	updated := make(map[string]ocspUpdate)
-
-	// A single SAN certificate maps to multiple names, so we use this
-	// set to make sure we don't waste cycles checking OCSP for the same
-	// certificate multiple times.
-	visited := make(map[string]struct{})
-
-	certCacheMu.RLock()
-	for name, cert := range certCache {
-		// skip this certificate if we've already visited it,
-		// and if not, mark all the names as visited
-		if _, ok := visited[name]; ok {
+	for _, inst := range caddy.Instances() {
+		inst.StorageMu.RLock()
+		certCache, ok := inst.Storage[CertCacheInstStorageKey].(*certificateCache)
+		inst.StorageMu.RUnlock()
+		if !ok || certCache == nil {
 			continue
 		}
-		for _, n := range cert.Names {
-			visited[n] = struct{}{}
-		}
 
-		// no point in updating OCSP for expired certificates
-		if time.Now().After(cert.NotAfter) {
-			continue
+		// Create a temporary place to store updates
+		// until we release the potentially long-lived
+		// read lock and use a short-lived write lock
+		// on the certificate cache.
+		type ocspUpdate struct {
+			rawBytes []byte
+			parsed   *ocsp.Response
 		}
+		updated := make(map[string]ocspUpdate)
 
-		var lastNextUpdate time.Time
-		if cert.OCSP != nil {
-			lastNextUpdate = cert.OCSP.NextUpdate
-			if freshOCSP(cert.OCSP) {
-				// no need to update staple if ours is still fresh
+		certCache.RLock()
+		for certHash, cert := range certCache.cache {
+			// no point in updating OCSP for expired certificates
+			if time.Now().After(cert.NotAfter) {
 				continue
 			}
-		}
 
-		err := stapleOCSP(&cert, nil)
-		if err != nil {
+			var lastNextUpdate time.Time
 			if cert.OCSP != nil {
-				// if there was no staple before, that's fine; otherwise we should log the error
-				log.Printf("[ERROR] Checking OCSP: %v", err)
+				lastNextUpdate = cert.OCSP.NextUpdate
+				if freshOCSP(cert.OCSP) {
+					continue // no need to update staple if ours is still fresh
+				}
 			}
-			continue
-		}
 
-		// By this point, we've obtained the latest OCSP response.
-		// If there was no staple before, or if the response is updated, make
-		// sure we apply the update to all names on the certificate.
-		if cert.OCSP != nil && (lastNextUpdate.IsZero() || lastNextUpdate != cert.OCSP.NextUpdate) {
-			log.Printf("[INFO] Advancing OCSP staple for %v from %s to %s",
-				cert.Names, lastNextUpdate, cert.OCSP.NextUpdate)
-			for _, n := range cert.Names {
-				// BUG: If this certificate has names on it that appear on another
-				// certificate in the cache, AND the other certificate is keyed by
-				// that name in the cache, then this method of 'queueing' the staple
-				// update will cause this certificate's new OCSP to be stapled to
-				// a different certificate! See:
-				// https://caddy.community/t/random-ocsp-response-errors-for-random-clients/2473?u=matt
-				// This problem should be avoided if names on certificates in the
-				// cache don't overlap with regards to the cache keys.
-				// (This is isn't a bug anymore, since we're careful when we add
-				// certificates to the cache by skipping keying when key already exists.)
-				updated[n] = ocspUpdate{rawBytes: cert.Certificate.OCSPStaple, parsed: cert.OCSP}
+			err := stapleOCSP(&cert, nil)
+			if err != nil {
+				if cert.OCSP != nil {
+					// if there was no staple before, that's fine; otherwise we should log the error
+					log.Printf("[ERROR] Checking OCSP: %v", err)
+				}
+				continue
+			}
+
+			// By this point, we've obtained the latest OCSP response.
+			// If there was no staple before, or if the response is updated, make
+			// sure we apply the update to all names on the certificate.
+			if cert.OCSP != nil && (lastNextUpdate.IsZero() || lastNextUpdate != cert.OCSP.NextUpdate) {
+				log.Printf("[INFO] Advancing OCSP staple for %v from %s to %s",
+					cert.Names, lastNextUpdate, cert.OCSP.NextUpdate)
+				updated[certHash] = ocspUpdate{rawBytes: cert.Certificate.OCSPStaple, parsed: cert.OCSP}
 			}
 		}
+		certCache.RUnlock()
+
+		// These write locks should be brief since we have all the info we need now.
+		for certKey, update := range updated {
+			certCache.Lock()
+			cert := certCache.cache[certKey]
+			cert.OCSP = update.parsed
+			cert.Certificate.OCSPStaple = update.rawBytes
+			certCache.cache[certKey] = cert
+			certCache.Unlock()
+		}
 	}
-	certCacheMu.RUnlock()
-
-	// This write lock should be brief since we have all the info we need now.
-	certCacheMu.Lock()
-	for name, update := range updated {
-		cert := certCache[name]
-		cert.OCSP = update.parsed
-		cert.Certificate.OCSPStaple = update.rawBytes
-		certCache[name] = cert
-	}
-	certCacheMu.Unlock()
 }
 
 // DeleteOldStapleFiles deletes cached OCSP staples that have expired.
 // TODO: Should we do this for certificates too?
 func DeleteOldStapleFiles() {
+	// TODO: Upgrade caddytls.Storage to support OCSP operations too
 	files, err := ioutil.ReadDir(ocspFolder)
 	if err != nil {
 		// maybe just hasn't been created yet; no big deal