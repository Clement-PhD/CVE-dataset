@@ -258,6 +258,18 @@ char *SERVER_ERROR =
   "<body>The request contained invalid UTF-8 in " location ".</body>" \
   "</html>"
 
+/*
+ * Host HTTP header error page.
+ */
+#define HOST_HEADER_ERROR_PAGE \
+  "<html>"                                                            \
+  "<head><title>Invalid request</title></head>"                       \
+  "<body>The request contained an unknown or invalid Host header."    \
+  " If you are trying to access GSA via its hostname or a proxy,"     \
+  " make sure GSA is set up to allow it."                             \
+  "</body>"                                                           \
+  "</html>"
+
 /**
  * @brief The handle on the embedded HTTP daemon.
  */
@@ -268,6 +280,11 @@ struct MHD_Daemon *gsad_daemon;
  */
 GSList *address_list = NULL;
 
+/**
+ * @brief Host names and IP accepted in the "Host" HTTP header
+ */
+GHashTable *gsad_header_hosts = NULL;
+
 /**
  * @brief Location for redirection server.
  */
@@ -3828,6 +3845,150 @@ gsad_add_content_type_header (struct MHD_Response *response,
     }
 }
 
+/**
+ * @brief Add all local IP addresses to a GHashTable.
+ *
+ * @param[in] hashtable       The hashtable to add the addresses to.
+ * @param[in] include_ipv6    Whether to include IPv6 addresses.
+ * @param[in] localhost_only  Whether to add only localhost, 127.0.0.1 and ::1.
+ */
+void
+add_local_addresses (GHashTable *hashtable, int include_ipv6,
+                     int localhost_only)
+{
+  struct ifaddrs *ifaddr, *ifa;
+  int family, ret;
+  char host[NI_MAXHOST];
+
+  // Basic loopback addresses
+  g_hash_table_add (gsad_header_hosts, g_strdup ("localhost"));
+  g_hash_table_add (gsad_header_hosts, g_strdup ("127.0.0.1"));
+  if (include_ipv6)
+    g_hash_table_add (gsad_header_hosts, g_strdup ("::1"));
+
+  // Other interface addresses
+  if (localhost_only == 0 && getifaddrs(&ifaddr) != -1)
+    {
+      for (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next)
+        {
+          if (ifa->ifa_addr == NULL)
+            continue;
+
+          family = ifa->ifa_addr->sa_family;
+
+          if (family == AF_INET || (include_ipv6 && family == AF_INET6))
+            {
+              ret = getnameinfo(ifa->ifa_addr,
+                                (family == AF_INET) 
+                                  ? sizeof(struct sockaddr_in) 
+                                  : sizeof(struct sockaddr_in6),
+                                host, NI_MAXHOST,
+                                NULL, 0, NI_NUMERICHOST);
+              if (ret != 0) {
+                g_warning ("%s: getnameinfo() failed: %s\n",
+                           __FUNCTION__, gai_strerror(ret));
+                return;
+              }
+
+              g_hash_table_insert (hashtable, g_strdup (host), NULL);
+            }
+        }
+      freeifaddrs(ifaddr);
+    }
+}
+
+/**
+ * @brief Verify if a hostname or IP address refers to the gsad.
+ *
+ * @param[in] host  The name or address to check.
+ *
+ * @return 0 valid, 1 invalid.
+ */
+static int
+host_is_gsad (const char *host)
+{
+  if (host == NULL)
+    return 0;
+
+  return host ? g_hash_table_contains (gsad_header_hosts, host) : 0;
+}
+
+/**
+ * Verify a Host HTTP header.
+ *
+ * @param[in] host_header  Host header value.
+ *
+ * @return 0 valid, 1 invalid UTF-8, 2 otherwise invalid, -1 error.
+ */
+static int
+validate_host_header (const char *host_header)
+{
+  int ret;
+  int char_index, colon_index, bracket_index;
+  gchar *host;
+
+  if (host_header == NULL || strlen (host_header) == 0)
+    return 2;
+  else if (g_utf8_validate (host_header, -1, NULL) == FALSE)
+    return 1;
+
+  /*
+   * Find brackets and colons for detecting IPv6 addresses and port.
+   */
+  bracket_index = -1;
+  colon_index = -1;
+  for (char_index = strlen (host_header) - 1;
+       char_index >= 0;
+       char_index --)
+    {
+      if (host_header[char_index] == ']' && bracket_index == -1)
+        bracket_index = char_index;
+      if (host_header[char_index] == ':' && colon_index == -1)
+        colon_index = char_index;
+    }
+
+  if (bracket_index != -1 && host_header[0] == '['
+      && (colon_index == bracket_index + 1 || colon_index < bracket_index))
+    {
+      /*
+       * IPv6 address which starts with a square bracket and
+       *  where the last colon is right after a closing bracket,
+       *  e.g. "[::1]:9392" -> "::1" or inside brackets, e.g. "[::1]" -> "::1".
+       */
+      host = g_strndup (host_header + 1, bracket_index - 1);
+    }
+  else if (colon_index > 0 && bracket_index == -1)
+    {
+      /*
+       * Hostname or IPv4 address (no brackets) with a port after the colon,
+       *  e.g. "127.0.0.1:9393" -> "127.0.0.1".
+       */
+      host = g_strndup (host_header, colon_index);
+    }
+  else if (colon_index == -1 && bracket_index == -1)
+    {
+      /*
+       * Hostname or IPv4 address (no brackets) without any colon for a port,
+       *  e.g. "127.0.0.1".
+       */
+      host = g_strdup (host_header);
+    }
+  else
+    {
+      /*
+       * Invalid because colon or brackets are in unexpected places.
+       */
+      host = NULL;
+    }
+
+  g_debug ("%s: header: '%s' -> host: '%s'", __FUNCTION__, host_header, host);
+
+  ret = host_is_gsad (host) ? 0 : 2;
+  g_free (host);
+
+  return ret;
+}
+
 /**
  * @brief Sends a HTTP response.
  *
@@ -3972,19 +4133,27 @@ send_redirect_to_urn (struct MHD_Connection *connection, const char *urn,
 
   host = MHD_lookup_connection_value (connection, MHD_HEADER_KIND,
                                       MHD_HTTP_HEADER_HOST);
-  if (host && g_utf8_validate (host, -1, NULL) == FALSE)
-    {
-      send_response (connection,
-                     UTF8_ERROR_PAGE ("'Host' header"),
-                     MHD_HTTP_BAD_REQUEST, NULL,
-                     GSAD_CONTENT_TYPE_TEXT_HTML, NULL, 0);
-      return MHD_YES;
-    }
-  if (host == NULL)
+
+  switch (validate_host_header (host))
     {
-      send_response (connection, BAD_REQUEST_PAGE, MHD_HTTP_NOT_ACCEPTABLE,
-                     NULL, GSAD_CONTENT_TYPE_TEXT_HTML, NULL, 0);
-      return MHD_YES;
+      case 0:
+        // Header is valid
+        break;
+      case 1:
+        // Invalid UTF-8
+        send_response (connection,
+                       UTF8_ERROR_PAGE ("'Host' header"),
+                       MHD_HTTP_BAD_REQUEST, NULL,
+                       GSAD_CONTENT_TYPE_TEXT_HTML, NULL, 0);
+        return MHD_YES;
+      case 2:
+      default:
+        // Otherwise invalid
+        send_response (connection,
+                       HOST_HEADER_ERROR_PAGE,
+                       MHD_HTTP_BAD_REQUEST, NULL,
+                       GSAD_CONTENT_TYPE_TEXT_HTML, NULL, 0);
+        return MHD_YES;
     }
 
   protocol = MHD_lookup_connection_value (connection, MHD_HEADER_KIND,
@@ -4068,16 +4237,27 @@ redirect_handler (void *cls, struct MHD_Connection *connection,
   host = MHD_lookup_connection_value (connection,
                                       MHD_HEADER_KIND,
                                       "Host");
-  if (host && g_utf8_validate (host, -1, NULL) == FALSE)
+  switch (validate_host_header (host))
     {
-      send_response (connection,
-                     UTF8_ERROR_PAGE ("'Host' header"),
-                     MHD_HTTP_BAD_REQUEST, NULL,
-                     GSAD_CONTENT_TYPE_TEXT_HTML, NULL, 0);
-      return MHD_YES;
+      case 0:
+        // Header is valid
+        break;
+      case 1:
+        // Invalid UTF-8
+        send_response (connection,
+                       UTF8_ERROR_PAGE ("'Host' header"),
+                       MHD_HTTP_BAD_REQUEST, NULL,
+                       GSAD_CONTENT_TYPE_TEXT_HTML, NULL, 0);
+        return MHD_YES;
+      case 2:
+      default:
+        // Otherwise invalid
+        send_response (connection,
+                       HOST_HEADER_ERROR_PAGE,
+                       MHD_HTTP_BAD_REQUEST, NULL,
+                       GSAD_CONTENT_TYPE_TEXT_HTML, NULL, 0);
+        return MHD_YES;
     }
-  else if (host == NULL)
-    return MHD_NO;
   /* [IPv6 or IPv4-mapped IPv6]:port */
   if (sscanf (host, "[%" G_STRINGIFY(MAX_HOST_LEN) "[0-9a-f:.]]:%*i", name)
       == 1)
@@ -5858,6 +6038,8 @@ gsad_address_set_port (struct sockaddr_storage *address, int port)
 /**
  * @brief Initalizes the address to listen on.
  *
+ * If an address is given explicitly, it will also be allowed in a Host header.
+ *
  * @param[in]  address_str      Address to listen on.
  * @param[in]  port             Port to listen on.
  *
@@ -5883,6 +6065,7 @@ gsad_address_init (const char *address_str, int port)
           g_free (address);
           return 1;
         }
+      g_hash_table_add (gsad_header_hosts, g_strdup (address_str));
     }
   else
     {
@@ -5935,6 +6118,7 @@ main (int argc, char **argv)
   static gboolean secure_cookie = FALSE;
   static int timeout = SESSION_TIMEOUT;
   static gchar **gsad_address_string = NULL;
+  static gchar **gsad_header_host_strings = NULL;
   static gchar *gsad_manager_address_string = NULL;
   static gchar *gsad_manager_unix_socket_path = NULL;
   static gchar *gsad_port_string = NULL;
@@ -5964,6 +6148,10 @@ main (int argc, char **argv)
   GError *error = NULL;
   GOptionContext *option_context;
   static GOptionEntry option_entries[] = {
+    {"allow-header-host", '\0',
+     0, G_OPTION_ARG_STRING_ARRAY, &gsad_header_host_strings,
+     "Allow <host> as hostname/address part of a Host header."
+     "<host>" },
     {"drop-privileges", '\0',
      0, G_OPTION_ARG_STRING, &drop,
      "Drop privileges to <user>.", "<user>" },
@@ -6402,16 +6590,51 @@ main (int argc, char **argv)
       exit (EXIT_FAILURE);
     }
 
+  /* Initialize addresses and accepted host headers for HTTP header */
+  gsad_header_hosts = g_hash_table_new_full (g_str_hash, g_str_equal,
+                                             g_free, NULL);
+
   if (gsad_address_string)
-    while (*gsad_address_string)
+    {
+      // Allow basic loopback addresses in Host header
+      add_local_addresses (gsad_header_hosts, ipv6_is_enabled (), 1);
+      // Listen to given addresses and allow them in Host header
+      while (*gsad_address_string)
+        {
+          if (gsad_address_init (*gsad_address_string, gsad_port))
+            return 1;
+          gsad_address_string++;
+        }
+    }
+  else
+    {
+      // Allow all local interface addresses in Host Header
+      add_local_addresses (gsad_header_hosts, ipv6_is_enabled (), 0);
+      // Listen on all addresses
+      if (gsad_address_init (NULL, gsad_port))
+        return 1;
+    }
+
+  if (gsad_header_host_strings)
+    while (*gsad_header_host_strings)
       {
-        if (gsad_address_init (*gsad_address_string, gsad_port))
-          return 1;
-        gsad_address_string++;
+        g_hash_table_add (gsad_header_hosts,
+                          g_strdup (*gsad_header_host_strings));
+        gsad_header_host_strings ++;
       }
-  else
-    if (gsad_address_init (NULL, gsad_port))
-      return 1;
+
+  g_debug ("Accepting %d host addresses in Host headers",
+          g_hash_table_size (gsad_header_hosts));
+  if (verbose)
+    {
+      GHashTableIter iter;
+      char *hostname;
+      g_hash_table_iter_init (&iter, gsad_header_hosts);
+      while (g_hash_table_iter_next (&iter, (void**)(&hostname), NULL))
+        {
+          g_debug ("- %s\n", hostname);
+        }
+    }
 
   if (!no_redirect)
     {