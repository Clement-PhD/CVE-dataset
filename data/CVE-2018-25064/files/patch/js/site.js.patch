@@ -1,3 +1,5 @@
+"use strict";
+
 var osmStream = require('osm-stream'),
     reqwest = require('reqwest'),
     moment = require('moment'),
@@ -73,7 +75,7 @@ var osm = new L.TileLayer('https://api.mapbox.com/styles/v1/openstreetmapus/cj8x
     attribution: '<a href="https://mapbox.com/about/maps/">Terms &amp; Conditions</a>'
 }).addTo(overview_map);
 
-var lineGroup = L.featureGroup().addTo(map);
+var mapElementGroup = L.featureGroup().addTo(map);
 
 var changeset_info = document.getElementById('changeset_info');
 var changeset_tmpl = _.template(document.getElementById('changeset-template').innerHTML);
@@ -113,13 +115,13 @@ function showLocation(ll) {
         crossOrigin: true,
         type: 'json'
     }, function(resp) {
-        document.getElementById('reverse-location').innerHTML =
+        document.getElementById('reverse-location').textContent =
             '' + resp.display_name + '';
     });
 }
 
 function fetchChangesetData(id, callback) {
-    cached_changeset_data = changeset_cache.get(id);
+    var cached_changeset_data = changeset_cache.get(id);
 
     if (!cached_changeset_data) {
         var changeset_url_tmpl = '//www.openstreetmap.org/api/0.6/changeset/{id}';
@@ -145,7 +147,7 @@ function fetchChangesetData(id, callback) {
 
 function showComment(id) {
     fetchChangesetData(id, function(err, changeset_data) {
-        document.getElementById('comment').innerHTML = changeset_data.comment + ' in ' + changeset_data.created_by;
+        document.getElementById('comment').textContent = changeset_data.comment + ' in ' + changeset_data.created_by;
     });
 }
 
@@ -156,73 +158,95 @@ function makeBbox(bounds_array) {
     );
 }
 
+function happenedToday(timestamp) {
+    return moment(timestamp).format("MMM Do YY") === moment().format("MMM Do YY");
+}
+
+function userNotIgnored(change) {
+    return (change.old && ignore.indexOf(change.old.user) === -1)
+        || (change.neu && ignore.indexOf(change.neu.user) === -1);
+}
+
 var runSpeed = 2000;
 
 osmStream.runFn(function(err, data) {
     queue = _.filter(data, function(f) {
-        var is_a_way = (f.old && f.old.type === 'way') || (f.neu && f.neu.type === 'way');
-        if (is_a_way) {
-            var bbox_intersects_old = (f.old && f.old.bounds && bbox.intersects(makeBbox(f.old.bounds)));
-            var bbox_intersects_new = (f.neu && f.neu.bounds && bbox.intersects(makeBbox(f.neu.bounds)));
-            var happened_today = moment((f.neu && f.neu.timestamp) || (f.neu && f.neu.timestamp)).format("MMM Do YY") === moment().format("MMM Do YY");
-            var user_not_ignored = (f.old && ignore.indexOf(f.old.user) === -1) || (f.neu && ignore.indexOf(f.neu.user) === -1);
-            var way_long_enough = (f.old && f.old.linestring && f.old.linestring.length > 4) || (f.neu && f.neu.linestring && f.neu.linestring.length > 4);
-            return is_a_way &&
-                (bbox_intersects_old || bbox_intersects_new) &&
-                happened_today &&
-                user_not_ignored &&
-                way_long_enough;
-        } else {
-            return false;
+        var type = (f.old && f.old.type) || (f.neu && f.neu.type);
+        switch (type) {
+            case 'way':
+                var bbox_intersects_old = (f.old && f.old.bounds && bbox.intersects(makeBbox(f.old.bounds)));
+                var bbox_intersects_new = (f.neu && f.neu.bounds && bbox.intersects(makeBbox(f.neu.bounds)));
+                var happened_today = happenedToday(f.neu && f.neu.timestamp);
+                var user_not_ignored = userNotIgnored(f);
+                var way_long_enough = (f.old && f.old.linestring && f.old.linestring.length > 4) || (f.neu && f.neu.linestring && f.neu.linestring.length > 4);
+                return (bbox_intersects_old || bbox_intersects_new) &&
+                    happened_today &&
+                    user_not_ignored &&
+                    way_long_enough;
+            case 'node':
+                var has_tags = (f.neu && Object.keys(f.neu.tags || {}).length > 0)
+                    || (f.old && Object.keys(f.old.tags || {}).length > 0);
+                if (!has_tags) { // shortcut to skip more expensive operations
+                    return false;
+                }
+                var bbox_contains_old = (f.old && f.old.lat && f.old.lon && bbox.contains(new L.LatLng(f.old.lat, f.old.lon)));
+                var bbox_contains_new = (f.neu && f.neu.lat && f.neu.lon && bbox.contains(new L.LatLng(f.neu.lat, f.neu.lon)));
+                var happened_today = happenedToday(f.neu && f.neu.timestamp);
+                var user_not_ignored = userNotIgnored(f);
+                return (bbox_contains_old || bbox_contains_new) &&
+                    happened_today &&
+                    user_not_ignored;
+            default:
+                return false;
         }
     }).sort(function(a, b) {
-        return (+new Date((a.neu && a.neu.timestamp) || (a.neu && a.neu.timestamp))) -
-            (+new Date((b.neu && b.neu.timestamp) || (b.neu && b.neu.timestamp)));
+        return (+new Date((a.neu && a.neu.timestamp))) -
+            (+new Date((b.neu && b.neu.timestamp)));
     });
     // if (queue.length > 2000) queue = queue.slice(0, 2000);
     runSpeed = 1500;
 }, null, null, bboxString);
 
-function doDrawWay() {
-    document.getElementById('queuesize').innerHTML = queue.length;
+function doDrawMapElement() {
+    document.getElementById('queuesize').textContent = queue.length;
     if (queue.length) {
         var change = queue.pop();
-        var way = change.neu || change.old;
+        var mapElement = change.neu || change.old;
 
-        // Skip ways that are part of a changeset we don't care about
-        if (changeset_comment_match && way.changeset) {
-            fetchChangesetData(way.changeset, function(err, changeset_data) {
+        // Skip map elements that are part of a changeset we don't care about
+        if (changeset_comment_match && mapElement.changeset) {
+            fetchChangesetData(mapElement.changeset, function(err, changeset_data) {
                 if (err) {
                     console.log("Error filtering changeset: " + err);
-                    doDrawWay();
+                    doDrawMapElement();
                     return;
                 }
 
                 if (changeset_data.comment && changeset_data.comment.indexOf(changeset_comment_match) > -1) {
-                    console.log("Drawing way " + way.id);
-                    drawWay(change, function() {
-                        doDrawWay();
+                    console.log("Drawing map element " + mapElement.id);
+                    drawMapElement(change, function() {
+                        doDrawMapElement();
                     });
                 } else {
-                    console.log("Skipping way " + way.id + " because changeset " + way.changeset + " didn't match " + changeset_comment_match);
-                    doDrawWay();
+                    console.log("Skipping map element " + mapElement.id + " because changeset " + mapElement.changeset + " didn't match " + changeset_comment_match);
+                    doDrawMapElement();
                 }
             });
         } else {
-            drawWay(change, function() {
-                doDrawWay();
+            drawMapElement(change, function() {
+                doDrawMapElement();
             });
         }
     } else {
-        window.setTimeout(doDrawWay, runSpeed);
+        window.setTimeout(doDrawMapElement, runSpeed);
     }
 }
 
-function pruneLines() {
+function pruneMapElements() {
     var mb = map.getBounds();
-    lineGroup.eachLayer(function(l) {
+    mapElementGroup.eachLayer(function(l) {
         if (!mb.intersects(l.getBounds())) {
-            lineGroup.removeLayer(l);
+            mapElementGroup.removeLayer(l);
         } else {
             l.setStyle({ opacity: 0.5 });
         }
@@ -231,32 +255,37 @@ function pruneLines() {
 
 function setTagText(change) {
     var showTags = ['building', 'natural', 'leisure', 'waterway',
-        'barrier', 'landuse', 'highway', 'power'];
+        'barrier', 'landuse', 'highway', 'power', 'amenity', 'place',
+        'addr:housenumber', 'memorial', 'historic', 'shop', 'office',
+        'emergency'];
+    var mapElement = change.type === 'delete' ? change.old : change.neu;
+    var tags = mapElement.tags;
     for (var i = 0; i < showTags.length; i++) {
-        var tags = change.type === 'delete' ? change.old.tags : change.neu.tags;
         if (tags[showTags[i]]) {
             change.tagtext = showTags[i] + '=' + tags[showTags[i]];
             return change;
         }
     }
-    change.tagtext = 'a way';
+    change.tagtext = 'a ' + mapElement.type;
     return change;
 }
 
-function drawWay(change, cb) {
-    pruneLines();
+function drawMapElement(change, cb) {
+    pruneMapElements();
 
-    var way = change.type === 'delete' ? change.old : change.neu;
+    var mapElement = change.type === 'delete' ? change.old : change.neu;
     change.meta = {
-        id: way.id,
-        type: way.type,
+        id: mapElement.id,
+        type: mapElement.type,
         // Always pull in the new side user, timestamp, and changeset info
         user: change.neu.user,
         changeset: change.neu.changeset
     };
 
     // Zoom to the area in question
-    var bounds = makeBbox(way.bounds);
+    var bounds = mapElement.type === 'way'
+        ? makeBbox(mapElement.bounds)
+        : makeBbox([mapElement.lat, mapElement.lon, mapElement.lat, mapElement.lon]);
 
     if (farFromLast(bounds.getCenter())) showLocation(bounds.getCenter());
     showComment(change.neu.changeset);
@@ -270,35 +299,64 @@ function drawWay(change, cb) {
     changeset_info.innerHTML = changeset_tmpl({ change: change });
 
     var color = { 'create': '#B7FF00', 'modify': '#FF00EA', 'delete': '#FF0000' }[change.type];
-    if (way.tags.building || way.tags.area) {
-        newLine = L.polygon([], {
-            opacity: 1,
-            color: color,
-            fill: color
-        }).addTo(lineGroup);
-    } else {
-        newLine = L.polyline([], {
-            opacity: 1,
-            color: color
-        }).addTo(lineGroup);
-    }
-    // This is a bit lower than 3000 because we want the whole way
-    // to stay on the screen for a bit before moving on.
-    var perPt = runSpeed / way.linestring.length;
-
-    function drawPt(pt) {
-        newLine.addLatLng(pt);
-        if (way.linestring.length) {
-            window.setTimeout(function() {
-                drawPt(way.linestring.pop());
-            }, perPt);
-        } else {
-            window.setTimeout(cb, perPt * 2);
-        }
-    }
+    switch (mapElement.type) {
+        case 'way':
+            var newLine;
+            if (mapElement.tags.building || mapElement.tags.area) {
+                newLine = L.polygon([], {
+                    opacity: 1,
+                    color: color,
+                    fill: color
+                }).addTo(mapElementGroup);
+            } else {
+                newLine = L.polyline([], {
+                    opacity: 1,
+                    color: color
+                }).addTo(mapElementGroup);
+            }
+            // This is a bit lower than 3000 because we want the whole way
+            // to stay on the screen for a bit before moving on.
+            var perPt = runSpeed / mapElement.linestring.length;
+
+            function drawPt(pt) {
+                newLine.addLatLng(pt);
+                if (mapElement.linestring.length) {
+                    window.setTimeout(function() {
+                        drawPt(mapElement.linestring.pop());
+                    }, perPt);
+                } else {
+                    window.setTimeout(cb, perPt * 2);
+                }
+            }
 
-    newLine.addLatLng(way.linestring.pop());
-    drawPt(way.linestring.pop());
+            newLine.addLatLng(mapElement.linestring.pop());
+            drawPt(mapElement.linestring.pop());
+            break;
+        case 'node':
+            // Calculate marker radii such that final radius is ~10px
+            var radii = [];
+            for (var i = 0; i <= 25; i += 1) {
+                radii.push(17 * Math.sin(i / 10));
+            }
+            var newMarker = L.circleMarker([mapElement.lat, mapElement.lon], {
+                opacity: 1,
+                color: color
+            }).addTo(mapElementGroup);
+
+            var perRadius = runSpeed / radii.length;
+            function nodeMarkerAnimation() {
+                newMarker.setRadius(radii.shift());
+                if (radii.length) {
+                    window.setTimeout(nodeMarkerAnimation, perRadius);
+                }
+                else {
+                    window.setTimeout(cb, perRadius * 2);
+                }
+            }
+
+            nodeMarkerAnimation();
+            break;
+    }
 }
 
-doDrawWay();
+doDrawMapElement();
