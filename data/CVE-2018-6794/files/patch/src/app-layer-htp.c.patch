@@ -78,6 +78,7 @@
 
 #include "util-memcmp.h"
 #include "util-random.h"
+#include "util-validate.h"
 
 //#define PRINT
 
@@ -340,9 +341,6 @@ void HTPStateFree(void *state)
         SCReturn;
     }
 
-    /* Unset the body inspection */
-    s->flags &=~ HTP_FLAG_NEW_BODY_SET;
-
     /* free the connection parser memory used by HTP library */
     if (s->connp != NULL) {
         SCLogDebug("freeing HTP state");
@@ -647,6 +645,63 @@ static inline void HTPErrorCheckTxRequestFlags(HtpState *s, htp_tx_t *tx)
     }
 }
 
+static int Setup(Flow *f, HtpState *hstate)
+{
+    /* store flow ref in state so callbacks can access it */
+    hstate->f = f;
+
+    HTPCfgRec *htp_cfg_rec = &cfglist;
+    htp_cfg_t *htp = cfglist.cfg; /* Default to the global HTP config */
+    void *user_data = NULL;
+
+    if (FLOW_IS_IPV4(f)) {
+        SCLogDebug("Looking up HTP config for ipv4 %08x", *GET_IPV4_DST_ADDR_PTR(f));
+        (void)SCRadixFindKeyIPV4BestMatch((uint8_t *)GET_IPV4_DST_ADDR_PTR(f), cfgtree, &user_data);
+    }
+    else if (FLOW_IS_IPV6(f)) {
+        SCLogDebug("Looking up HTP config for ipv6");
+        (void)SCRadixFindKeyIPV6BestMatch((uint8_t *)GET_IPV6_DST_ADDR(f), cfgtree, &user_data);
+    }
+    else {
+        SCLogError(SC_ERR_INVALID_ARGUMENT, "unknown address family, bug!");
+        goto error;
+    }
+
+    if (user_data != NULL) {
+        htp_cfg_rec = user_data;
+        htp = htp_cfg_rec->cfg;
+        SCLogDebug("LIBHTP using config: %p", htp);
+    } else {
+        SCLogDebug("Using default HTP config: %p", htp);
+    }
+
+    if (NULL == htp) {
+#ifdef DEBUG_VALIDATION
+        BUG_ON(htp == NULL);
+#endif
+        /* should never happen if HTPConfigure is properly invoked */
+        goto error;
+    }
+
+    hstate->connp = htp_connp_create(htp);
+    if (hstate->connp == NULL) {
+        goto error;
+    }
+
+    hstate->conn = htp_connp_get_connection(hstate->connp);
+
+    htp_connp_set_user_data(hstate->connp, (void *)hstate);
+    hstate->cfg = htp_cfg_rec;
+
+    SCLogDebug("New hstate->connp %p", hstate->connp);
+
+    htp_connp_open(hstate->connp, NULL, f->sp, NULL, f->dp, &f->startts);
+
+    return 0;
+error:
+    return -1;
+}
+
 /**
  *  \brief  Function to handle the reassembled data from client and feed it to
  *          the HTP library to process it.
@@ -666,107 +721,30 @@ static int HTPHandleRequestData(Flow *f, void *htp_state,
                                 void *local_data)
 {
     SCEnter();
-    int r = -1;
     int ret = 1;
-
-    //PrintRawDataFp(stdout, input, input_len);
-
     HtpState *hstate = (HtpState *)htp_state;
-    hstate->f = f;
 
     /* On the first invocation, create the connection parser structure to
      * be used by HTP library.  This is looked up via IP in the radix
      * tree.  Failing that, the default HTP config is used.
      */
     if (NULL == hstate->conn) {
-        HTPCfgRec *htp_cfg_rec = &cfglist;
-        htp_cfg_t *htp = cfglist.cfg; /* Default to the global HTP config */
-        void *user_data = NULL;
-
-        if (FLOW_IS_IPV4(f)) {
-            SCLogDebug("Looking up HTP config for ipv4 %08x", *GET_IPV4_DST_ADDR_PTR(f));
-            (void)SCRadixFindKeyIPV4BestMatch((uint8_t *)GET_IPV4_DST_ADDR_PTR(f), cfgtree, &user_data);
-        }
-        else if (FLOW_IS_IPV6(f)) {
-            SCLogDebug("Looking up HTP config for ipv6");
-            (void)SCRadixFindKeyIPV6BestMatch((uint8_t *)GET_IPV6_DST_ADDR(f), cfgtree, &user_data);
-        }
-        else {
-            SCLogError(SC_ERR_INVALID_ARGUMENT, "unknown address family, bug!");
-            goto error;
-        }
-
-        if (user_data != NULL) {
-            htp_cfg_rec = user_data;
-            htp = htp_cfg_rec->cfg;
-            SCLogDebug("LIBHTP using config: %p", htp);
-        } else {
-            SCLogDebug("Using default HTP config: %p", htp);
-        }
-
-        if (NULL == htp) {
-#ifdef DEBUG_VALIDATION
-            BUG_ON(htp == NULL);
-#endif
-            /* should never happen if HTPConfigure is properly invoked */
+        if (Setup(f, hstate) != 0) {
             goto error;
         }
-
-        hstate->connp = htp_connp_create(htp);
-        if (hstate->connp == NULL) {
-            goto error;
-        }
-
-        hstate->conn = htp_connp_get_connection(hstate->connp);
-
-        htp_connp_set_user_data(hstate->connp, (void *)hstate);
-        hstate->cfg = htp_cfg_rec;
-
-        SCLogDebug("New hstate->connp %p", hstate->connp);
-    }
-
-    /* the code block above should make sure connp is never NULL here */
-#ifdef DEBUG_VALIDATION
-    BUG_ON(hstate->connp == NULL);
-#endif
-
-    /* Unset the body inspection (the callback should
-     * reactivate it if necessary) */
-    hstate->flags &=~ HTP_FLAG_NEW_BODY_SET;
-
-    /* Open the HTTP connection on receiving the first request */
-    if (!(hstate->flags & HTP_FLAG_STATE_OPEN)) {
-        SCLogDebug("opening htp handle at %p", hstate->connp);
-
-        htp_connp_open(hstate->connp, NULL, f->sp, NULL, f->dp, &f->startts);
-        hstate->flags |= HTP_FLAG_STATE_OPEN;
-    } else {
-        SCLogDebug("using existing htp handle at %p", hstate->connp);
     }
+    DEBUG_VALIDATE_BUG_ON(hstate->connp == NULL);
 
     htp_time_t ts = { f->lastts.tv_sec, f->lastts.tv_usec };
     /* pass the new data to the htp parser */
     if (input_len > 0) {
-        r = htp_connp_req_data(hstate->connp, &ts, input, input_len);
-
-        switch(r) {
+        const int r = htp_connp_req_data(hstate->connp, &ts, input, input_len);
+        switch (r) {
             case HTP_STREAM_ERROR:
-
-                hstate->flags |= HTP_FLAG_STATE_ERROR;
-                hstate->flags &= ~HTP_FLAG_STATE_DATA;
-                hstate->flags &= ~HTP_FLAG_NEW_BODY_SET;
                 ret = -1;
                 break;
-            case HTP_STREAM_DATA:
-            case HTP_STREAM_DATA_OTHER:
-
-                hstate->flags |= HTP_FLAG_STATE_DATA;
-                break;
-            case HTP_STREAM_TUNNEL:
-                break;
             default:
-                hstate->flags &= ~HTP_FLAG_STATE_DATA;
-                hstate->flags &= ~HTP_FLAG_NEW_BODY_SET;
+                break;
         }
         HTPHandleError(hstate);
     }
@@ -806,42 +784,29 @@ static int HTPHandleResponseData(Flow *f, void *htp_state,
                                  void *local_data)
 {
     SCEnter();
-    int r = -1;
     int ret = 1;
-
     HtpState *hstate = (HtpState *)htp_state;
-    hstate->f = f;
-    if (hstate->connp == NULL) {
-        SCLogDebug("HTP state has no connp");
-        /* till we have the new libhtp changes that allow response first,
-         * let's take response in first. */
-        //BUG_ON(1);
-        SCReturnInt(-1);
-    }
 
-    /* Unset the body inspection (the callback should
-     * reactivate it if necessary) */
-    hstate->flags &=~ HTP_FLAG_NEW_BODY_SET;
+    /* On the first invocation, create the connection parser structure to
+     * be used by HTP library.  This is looked up via IP in the radix
+     * tree.  Failing that, the default HTP config is used.
+     */
+    if (NULL == hstate->conn) {
+        if (Setup(f, hstate) != 0) {
+            goto error;
+        }
+    }
+    DEBUG_VALIDATE_BUG_ON(hstate->connp == NULL);
 
     htp_time_t ts = { f->lastts.tv_sec, f->lastts.tv_usec };
     if (input_len > 0) {
-        r = htp_connp_res_data(hstate->connp, &ts, input, input_len);
-        switch(r) {
+        const int r = htp_connp_res_data(hstate->connp, &ts, input, input_len);
+        switch (r) {
             case HTP_STREAM_ERROR:
-                hstate->flags = HTP_FLAG_STATE_ERROR;
-                hstate->flags &= ~HTP_FLAG_STATE_DATA;
-                hstate->flags &= ~HTP_FLAG_NEW_BODY_SET;
                 ret = -1;
                 break;
-            case HTP_STREAM_DATA:
-            case HTP_STREAM_DATA_OTHER:
-                hstate->flags |= HTP_FLAG_STATE_DATA;
-                break;
-            case HTP_STREAM_TUNNEL:
-                break;
             default:
-                hstate->flags &= ~HTP_FLAG_STATE_DATA;
-                hstate->flags &= ~HTP_FLAG_NEW_BODY_SET;
+                break;
         }
         HTPHandleError(hstate);
     }
@@ -856,6 +821,8 @@ static int HTPHandleResponseData(Flow *f, void *htp_state,
 
     SCLogDebug("hstate->connp %p", hstate->connp);
     SCReturnInt(ret);
+error:
+    SCReturnInt(-1);
 }
 
 /**
@@ -1730,7 +1697,6 @@ static int HTPCallbackRequestBodyData(htp_tx_data_t *d)
     }
     if (!tx_ud->response_body_init) {
         tx_ud->response_body_init = 1;
-        tx_ud->operation = HTP_BODY_REQUEST;
 
         if (d->tx->request_method_number == HTP_M_POST) {
             SCLogDebug("POST");
@@ -1799,9 +1765,6 @@ static int HTPCallbackRequestBodyData(htp_tx_data_t *d)
     }
 
 end:
-    /* set the new chunk flag */
-    hstate->flags |= HTP_FLAG_NEW_BODY_SET;
-
     SCReturnInt(HTP_OK);
 }
 
@@ -1841,7 +1804,6 @@ static int HTPCallbackResponseBodyData(htp_tx_data_t *d)
     }
     if (!tx_ud->request_body_init) {
         tx_ud->request_body_init = 1;
-        tx_ud->operation = HTP_BODY_RESPONSE;
     }
 
     /* see if we can get rid of htp body chunks */
@@ -1874,9 +1836,6 @@ static int HTPCallbackResponseBodyData(htp_tx_data_t *d)
         }
     }
 
-    /* set the new chunk flag */
-    hstate->flags |= HTP_FLAG_NEW_BODY_SET;
-
     SCReturnInt(HTP_OK);
 }
 
@@ -1998,9 +1957,6 @@ static int HTPCallbackResponse(htp_tx_t *tx)
     /* we have one whole transaction now */
     hstate->transaction_cnt++;
 
-    /* Unset the body inspection (if any) */
-    hstate->flags &=~ HTP_FLAG_NEW_BODY_SET;
-
     HtpTxUserData *htud = (HtpTxUserData *) htp_tx_get_user_data(tx);
     if (htud != NULL) {
         if (htud->tcflags & HTP_FILENAME_SET) {
@@ -2660,10 +2616,13 @@ static uint64_t HTPStateGetTxCnt(void *alstate)
 {
     HtpState *http_state = (HtpState *)alstate;
 
-    if (http_state != NULL && http_state->conn != NULL)
-        return (uint64_t)htp_list_size(http_state->conn->transactions);
-    else
+    if (http_state != NULL && http_state->conn != NULL) {
+        const uint64_t size = (uint64_t)htp_list_size(http_state->conn->transactions);
+        SCLogDebug("size %"PRIu64, size);
+        return size;
+    } else {
         return 0ULL;
+    }
 }
 
 static void *HTPStateGetTx(void *alstate, uint64_t tx_id)
@@ -2882,7 +2841,8 @@ void RegisterHTPParsers(void)
         AppLayerParserRegisterParser(IPPROTO_TCP, ALPROTO_HTTP, STREAM_TOCLIENT,
                                      HTPHandleResponseData);
         SC_ATOMIC_INIT(htp_config_flags);
-        AppLayerParserRegisterParserAcceptableDataDirection(IPPROTO_TCP, ALPROTO_HTTP, STREAM_TOSERVER);
+        AppLayerParserRegisterParserAcceptableDataDirection(IPPROTO_TCP,
+                ALPROTO_HTTP, STREAM_TOSERVER|STREAM_TOCLIENT);
         HTPConfigure();
     } else {
         SCLogInfo("Parsed disabled for %s protocol. Protocol detection"
@@ -6497,6 +6457,298 @@ static int HTPParserTest19(void)
     return result;
 }
 
+/** \test Test response not HTTP
+ */
+static int HTPParserTest20(void)
+{
+    Flow *f = NULL;
+    uint8_t httpbuf1[] = "GET /ld/index.php?id=412784631&cid=0064&version=4&"
+                         "name=try HTTP/1.1\r\nAccept: */*\r\nUser-Agent: "
+                         "LD-agent\r\nHost: 209.205.196.16\r\n\r\n";
+    uint32_t httplen1 = sizeof(httpbuf1) - 1; /* minus the \0 */
+    uint8_t httpbuf2[] = "NOTHTTP\r\nSOMEOTHERDATA";
+    uint32_t httplen2 = sizeof(httpbuf2) - 1; /* minus the \0 */
+    uint8_t httpbuf3[] = "STILLNOTHTTP\r\nSOMEMOREOTHERDATA";
+    uint32_t httplen3 = sizeof(httpbuf3) - 1; /* minus the \0 */
+    TcpSession ssn;
+    HtpState *http_state = NULL;
+    AppLayerParserThreadCtx *alp_tctx = AppLayerParserThreadCtxAlloc();
+    FAIL_IF_NULL(alp_tctx);
+
+    memset(&ssn, 0, sizeof(ssn));
+
+    f = UTHBuildFlow(AF_INET, "1.2.3.4", "1.2.3.5", 1024, 80);
+    FAIL_IF_NULL(f);
+    f->protoctx = &ssn;
+    f->proto = IPPROTO_TCP;
+    f->alproto = ALPROTO_HTTP;
+
+    StreamTcpInitConfig(TRUE);
+
+    int r = AppLayerParserParse(NULL, alp_tctx, f, ALPROTO_HTTP,
+                                STREAM_TOSERVER | STREAM_START, httpbuf1,
+                                httplen1);
+    FAIL_IF(r != 0);
+
+    r = AppLayerParserParse(NULL, alp_tctx, f, ALPROTO_HTTP,
+                            STREAM_TOCLIENT | STREAM_START, httpbuf2,
+                            httplen2);
+    FAIL_IF(r != 0);
+
+    r = AppLayerParserParse(NULL, alp_tctx, f, ALPROTO_HTTP,
+                            STREAM_TOCLIENT | STREAM_START, httpbuf3,
+                            httplen3);
+    FAIL_IF(r != 0);
+
+    http_state = f->alstate;
+    FAIL_IF_NULL(http_state);
+    htp_tx_t *tx = HTPStateGetTx(http_state, 0);
+    FAIL_IF_NULL(tx);
+    htp_header_t *h =  htp_table_get_index(tx->request_headers, 0, NULL);
+    FAIL_IF_NULL(h);
+
+    FAIL_IF(tx->request_method_number != HTP_M_GET);
+    FAIL_IF(tx->request_protocol_number != HTP_PROTOCOL_1_1);
+
+    FAIL_IF(tx->response_status_number != 0);
+    FAIL_IF(tx->response_protocol_number != -1);
+
+    AppLayerParserThreadCtxFree(alp_tctx);
+    StreamTcpFreeConfig(TRUE);
+    UTHFreeFlow(f);
+    PASS;
+}
+
+/** \test Test response not HTTP
+ */
+static int HTPParserTest21(void)
+{
+    Flow *f = NULL;
+    uint8_t httpbuf1[] = "GET /ld/index.php?id=412784631&cid=0064&version=4&"
+                         "name=try HTTP/1.1\r\nAccept: */*\r\nUser-Agent: "
+                         "LD-agent\r\nHost: 209.205.196.16\r\n\r\n";
+    uint32_t httplen1 = sizeof(httpbuf1) - 1; /* minus the \0 */
+    uint8_t httpbuf2[] = "999 NOTHTTP REALLY\r\nSOMEOTHERDATA\r\n";
+    uint32_t httplen2 = sizeof(httpbuf2) - 1; /* minus the \0 */
+    uint8_t httpbuf3[] = "STILLNOTHTTP\r\nSOMEMOREOTHERDATA";
+    uint32_t httplen3 = sizeof(httpbuf3) - 1; /* minus the \0 */
+    TcpSession ssn;
+    HtpState *http_state = NULL;
+    AppLayerParserThreadCtx *alp_tctx = AppLayerParserThreadCtxAlloc();
+    FAIL_IF_NULL(alp_tctx);
+
+    memset(&ssn, 0, sizeof(ssn));
+
+    f = UTHBuildFlow(AF_INET, "1.2.3.4", "1.2.3.5", 1024, 80);
+    FAIL_IF_NULL(f);
+    f->protoctx = &ssn;
+    f->proto = IPPROTO_TCP;
+    f->alproto = ALPROTO_HTTP;
+
+    StreamTcpInitConfig(TRUE);
+
+    int r = AppLayerParserParse(NULL, alp_tctx, f, ALPROTO_HTTP,
+                                STREAM_TOSERVER | STREAM_START, httpbuf1,
+                                httplen1);
+    FAIL_IF(r != 0);
+
+    r = AppLayerParserParse(NULL, alp_tctx, f, ALPROTO_HTTP,
+                            STREAM_TOCLIENT | STREAM_START, httpbuf2,
+                            httplen2);
+    FAIL_IF(r != 0);
+
+    r = AppLayerParserParse(NULL, alp_tctx, f, ALPROTO_HTTP,
+                            STREAM_TOCLIENT | STREAM_START, httpbuf3,
+                            httplen3);
+    FAIL_IF(r != 0);
+
+    http_state = f->alstate;
+    FAIL_IF_NULL(http_state);
+    htp_tx_t *tx = HTPStateGetTx(http_state, 0);
+    FAIL_IF_NULL(tx);
+    htp_header_t *h =  htp_table_get_index(tx->request_headers, 0, NULL);
+    FAIL_IF_NULL(h);
+
+    FAIL_IF(tx->request_method_number != HTP_M_GET);
+    FAIL_IF(tx->request_protocol_number != HTP_PROTOCOL_1_1);
+
+    FAIL_IF(tx->response_status_number != 0);
+    FAIL_IF(tx->response_protocol_number != -1);
+
+    AppLayerParserThreadCtxFree(alp_tctx);
+    StreamTcpFreeConfig(TRUE);
+    UTHFreeFlow(f);
+    PASS;
+}
+
+/** \test Test response not HTTP
+ */
+static int HTPParserTest22(void)
+{
+    Flow *f = NULL;
+    uint8_t httpbuf1[] = "GET /ld/index.php?id=412784631&cid=0064&version=4&"
+                         "name=try HTTP/1.1\r\nAccept: */*\r\nUser-Agent: "
+                         "LD-agent\r\nHost: 209.205.196.16\r\n\r\n";
+    uint32_t httplen1 = sizeof(httpbuf1) - 1; /* minus the \0 */
+    uint8_t httpbuf2[] = "\r\n0000=0000000/ASDF3_31.zip, 456723\r\n"
+                          "AAAAAA_0000=0000000/AAAAAAAA.zip,46725\r\n";
+    uint32_t httplen2 = sizeof(httpbuf2) - 1; /* minus the \0 */
+    TcpSession ssn;
+    HtpState *http_state = NULL;
+    AppLayerParserThreadCtx *alp_tctx = AppLayerParserThreadCtxAlloc();
+    FAIL_IF_NULL(alp_tctx);
+
+    memset(&ssn, 0, sizeof(ssn));
+
+    f = UTHBuildFlow(AF_INET, "1.2.3.4", "1.2.3.5", 1024, 80);
+    FAIL_IF_NULL(f);
+    f->protoctx = &ssn;
+    f->proto = IPPROTO_TCP;
+    f->alproto = ALPROTO_HTTP;
+
+    StreamTcpInitConfig(TRUE);
+
+    int r = AppLayerParserParse(NULL, alp_tctx, f, ALPROTO_HTTP,
+                                STREAM_TOSERVER | STREAM_START, httpbuf1,
+                                httplen1);
+    FAIL_IF(r != 0);
+
+    r = AppLayerParserParse(NULL, alp_tctx, f, ALPROTO_HTTP,
+                            STREAM_TOCLIENT | STREAM_START, httpbuf2,
+                            httplen2);
+    FAIL_IF(r != 0);
+
+    http_state = f->alstate;
+    FAIL_IF_NULL(http_state);
+    htp_tx_t *tx = HTPStateGetTx(http_state, 0);
+    FAIL_IF_NULL(tx);
+    htp_header_t *h =  htp_table_get_index(tx->request_headers, 0, NULL);
+    FAIL_IF_NULL(h);
+
+    FAIL_IF(tx->request_method_number != HTP_M_GET);
+    FAIL_IF(tx->request_protocol_number != HTP_PROTOCOL_1_1);
+
+    FAIL_IF(tx->response_status_number != -0);
+    FAIL_IF(tx->response_protocol_number != -1);
+
+    AppLayerParserThreadCtxFree(alp_tctx);
+    StreamTcpFreeConfig(TRUE);
+    UTHFreeFlow(f);
+    PASS;
+}
+
+/** \test Test response not HTTP
+ */
+static int HTPParserTest23(void)
+{
+    Flow *f = NULL;
+    uint8_t httpbuf1[] = "GET /ld/index.php?id=412784631&cid=0064&version=4&"
+                         "name=try HTTP/1.1\r\nAccept: */*\r\nUser-Agent: "
+                         "LD-agent\r\nHost: 209.205.196.16\r\n\r\n";
+    uint32_t httplen1 = sizeof(httpbuf1) - 1; /* minus the \0 */
+    uint8_t httpbuf2[] = "HTTP0000=0000000/ASDF3_31.zip, 456723\r\n"
+                          "AAAAAA_0000=0000000/AAAAAAAA.zip,46725\r\n";
+    uint32_t httplen2 = sizeof(httpbuf2) - 1; /* minus the \0 */
+    TcpSession ssn;
+    HtpState *http_state = NULL;
+    AppLayerParserThreadCtx *alp_tctx = AppLayerParserThreadCtxAlloc();
+    FAIL_IF_NULL(alp_tctx);
+
+    memset(&ssn, 0, sizeof(ssn));
+
+    f = UTHBuildFlow(AF_INET, "1.2.3.4", "1.2.3.5", 1024, 80);
+    FAIL_IF_NULL(f);
+    f->protoctx = &ssn;
+    f->proto = IPPROTO_TCP;
+    f->alproto = ALPROTO_HTTP;
+
+    StreamTcpInitConfig(TRUE);
+
+    int r = AppLayerParserParse(NULL, alp_tctx, f, ALPROTO_HTTP,
+                                STREAM_TOSERVER | STREAM_START, httpbuf1,
+                                httplen1);
+    FAIL_IF(r != 0);
+
+    r = AppLayerParserParse(NULL, alp_tctx, f, ALPROTO_HTTP,
+                            STREAM_TOCLIENT | STREAM_START, httpbuf2,
+                            httplen2);
+    FAIL_IF(r != 0);
+
+    http_state = f->alstate;
+    FAIL_IF_NULL(http_state);
+    htp_tx_t *tx = HTPStateGetTx(http_state, 0);
+    FAIL_IF_NULL(tx);
+    htp_header_t *h =  htp_table_get_index(tx->request_headers, 0, NULL);
+    FAIL_IF_NULL(h);
+
+    FAIL_IF(tx->request_method_number != HTP_M_GET);
+    FAIL_IF(tx->request_protocol_number != HTP_PROTOCOL_1_1);
+
+    FAIL_IF(tx->response_status_number != -1);
+    FAIL_IF(tx->response_protocol_number != -2);
+
+    AppLayerParserThreadCtxFree(alp_tctx);
+    StreamTcpFreeConfig(TRUE);
+    UTHFreeFlow(f);
+    PASS;
+}
+
+/** \test Test response not HTTP
+ */
+static int HTPParserTest24(void)
+{
+    Flow *f = NULL;
+    uint8_t httpbuf1[] = "GET /ld/index.php?id=412784631&cid=0064&version=4&"
+                         "name=try HTTP/1.1\r\nAccept: */*\r\nUser-Agent: "
+                         "LD-agent\r\nHost: 209.205.196.16\r\n\r\n";
+    uint32_t httplen1 = sizeof(httpbuf1) - 1; /* minus the \0 */
+    uint8_t httpbuf2[] = "HTTP/1.0 0000=0000000/ASDF3_31.zip, 456723\r\n"
+                          "AAAAAA_0000=0000000/AAAAAAAA.zip,46725\r\n";
+    uint32_t httplen2 = sizeof(httpbuf2) - 1; /* minus the \0 */
+    TcpSession ssn;
+    HtpState *http_state = NULL;
+    AppLayerParserThreadCtx *alp_tctx = AppLayerParserThreadCtxAlloc();
+    FAIL_IF_NULL(alp_tctx);
+
+    memset(&ssn, 0, sizeof(ssn));
+
+    f = UTHBuildFlow(AF_INET, "1.2.3.4", "1.2.3.5", 1024, 80);
+    FAIL_IF_NULL(f);
+    f->protoctx = &ssn;
+    f->proto = IPPROTO_TCP;
+    f->alproto = ALPROTO_HTTP;
+
+    StreamTcpInitConfig(TRUE);
+
+    int r = AppLayerParserParse(NULL, alp_tctx, f, ALPROTO_HTTP,
+                                STREAM_TOSERVER | STREAM_START, httpbuf1,
+                                httplen1);
+    FAIL_IF(r != 0);
+
+    r = AppLayerParserParse(NULL, alp_tctx, f, ALPROTO_HTTP,
+                            STREAM_TOCLIENT | STREAM_START, httpbuf2,
+                            httplen2);
+    FAIL_IF(r != 0);
+
+    http_state = f->alstate;
+    FAIL_IF_NULL(http_state);
+    htp_tx_t *tx = HTPStateGetTx(http_state, 0);
+    FAIL_IF_NULL(tx);
+    htp_header_t *h =  htp_table_get_index(tx->request_headers, 0, NULL);
+    FAIL_IF_NULL(h);
+
+    FAIL_IF(tx->request_method_number != HTP_M_GET);
+    FAIL_IF(tx->request_protocol_number != HTP_PROTOCOL_1_1);
+
+    FAIL_IF(tx->response_status_number != -1);
+    FAIL_IF(tx->response_protocol_number != HTP_PROTOCOL_1_0);
+
+    AppLayerParserThreadCtxFree(alp_tctx);
+    StreamTcpFreeConfig(TRUE);
+    UTHFreeFlow(f);
+    PASS;
+}
+
 #endif /* UNITTESTS */
 
 /**
@@ -6546,6 +6798,11 @@ void HTPParserRegisterTests(void)
     UtRegisterTest("HTPParserTest17", HTPParserTest17);
     UtRegisterTest("HTPParserTest18", HTPParserTest18);
     UtRegisterTest("HTPParserTest19", HTPParserTest19);
+    UtRegisterTest("HTPParserTest20", HTPParserTest20);
+    UtRegisterTest("HTPParserTest21", HTPParserTest21);
+    UtRegisterTest("HTPParserTest22", HTPParserTest22);
+    UtRegisterTest("HTPParserTest23", HTPParserTest23);
+    UtRegisterTest("HTPParserTest24", HTPParserTest24);
 
     HTPFileParserRegisterTests();
     HTPXFFParserRegisterTests();