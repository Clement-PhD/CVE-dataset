@@ -698,46 +698,72 @@ public static File urlToPath(URL location, String subdir) {
             path.append(location.getPort());
             path.append(File.separatorChar);
         }
-        path.append(location.getPath().replace('/', File.separatorChar));
-        if (location.getQuery() != null && !location.getQuery().trim().isEmpty()) {
-            path.append(".").append(location.getQuery());
+        String locationPath = location.getPath().replace('/', File.separatorChar);
+        String query = "";
+        if (location.getQuery() != null) {
+            query = location.getQuery();
         }
+        if (locationPath.contains("..") || query.contains("..")){
+            try {
+                /**
+                 * if path contains .. then it can harm lcoal system
+                 * So without mercy, hash it
+                 */
+                String hexed = hex(new File(locationPath).getName(), locationPath);
+                return new File(path.toString(), hexed.toString());
+            } catch (NoSuchAlgorithmException ex) {
+                // should not occur, cite from javadoc:
+                // every java implementation should support
+                // MD5 SHA-1 SHA-256
+                throw new RuntimeException(ex);
+            }
+        } else {
+            path.append(locationPath);
+            if (location.getQuery() != null && !location.getQuery().trim().isEmpty()) {
+                path.append(".").append(location.getQuery());
+            }
 
-        File candidate = new File(FileUtils.sanitizePath(path.toString()));
-        if (candidate.getName().length() > 255) {
-            /**
-             * When filename is longer then 255 chars, then then various
-             * filesystems have issues to save it. By saving the file by its
-             * sum, we are trying to prevent collision of two files differs in
-             * suffixes (general suffix of name, not only 'filetype suffix')
-             * only. It is also preventing bug when truncate (files with 1000
-             * chars hash in query) cuts to much.
-             */
+            File candidate = new File(FileUtils.sanitizePath(path.toString()));
             try {
-                MessageDigest md = MessageDigest.getInstance("SHA-256");
-                byte[] sum = md.digest(candidate.getName().getBytes(UTF_8));
-                //convert the byte to hex format method 2
-                StringBuilder hexString = new StringBuilder();
-                for (int i = 0; i < sum.length; i++) {
-                    hexString.append(Integer.toHexString(0xFF & sum[i]));
-                }
-                String extension = "";
-                int i = candidate.getName().lastIndexOf('.');
-                if (i > 0) {
-                    extension = candidate.getName().substring(i);//contains dot
+                if (candidate.getName().length() > 255) {
+                    /**
+                     * When filename is longer then 255 chars, then then various
+                     * filesystems have issues to save it. By saving the file by its
+                     * sum, we are trying to prevent collision of two files differs in
+                     * suffixes (general suffix of name, not only 'filetype suffix')
+                     * only. It is also preventing bug when truncate (files with 1000
+                     * chars hash in query) cuts to much.
+                     */
+                    String hexed = hex(candidate.getName(), candidate.getName());
+                    candidate = new File(candidate.getParentFile(), hexed.toString());
                 }
-                if (extension.length() < 10 && extension.length() > 1) {
-                    hexString.append(extension);
-                }
-                candidate = new File(candidate.getParentFile(), hexString.toString());
             } catch (NoSuchAlgorithmException ex) {
                 // should not occur, cite from javadoc:
                 // every java implementation should support
                 // MD5 SHA-1 SHA-256
                 throw new RuntimeException(ex);
             }
+            return candidate;
+        }
+    }
+
+    public static String hex(String origName, String candidate) throws NoSuchAlgorithmException {
+        MessageDigest md = MessageDigest.getInstance("SHA-256");
+        byte[] sum = md.digest(candidate.getBytes(UTF_8));
+        //convert the byte to hex format method 2
+        StringBuilder hexString = new StringBuilder();
+        for (int i = 0; i < sum.length; i++) {
+            hexString.append(Integer.toHexString(0xFF & sum[i]));
+        }
+        String extension = "";
+        int i = origName.lastIndexOf('.');
+        if (i > 0) {
+            extension = origName.substring(i);//contains dot
+        }
+        if (extension.length() < 10 && extension.length() > 1) {
+            hexString.append(extension);
         }
-        return candidate;
+        return hexString.toString();
     }
 
     /**