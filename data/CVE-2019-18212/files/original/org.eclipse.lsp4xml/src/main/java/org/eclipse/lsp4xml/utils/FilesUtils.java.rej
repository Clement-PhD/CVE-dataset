--- /dev/null
+++ /dev/null
@@ -20,9 +20,6 @@
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
-import java.nio.file.attribute.PosixFilePermissions;
-import java.util.logging.Level;
-import java.util.logging.Logger;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
@@ -35,8 +32,6 @@
  */
 public class FilesUtils {
 
-	private static final Logger LOGGER = Logger.getLogger(FilesUtils.class.getName());
-
 	public static final String FILE_SCHEME = "file://";
 	public static final String LSP4XML_WORKDIR_KEY = "lsp4xml.workdir";
 	private static String cachePathSetting = null;
@@ -148,15 +143,6 @@ public static void saveToFile(String content, Path outFile) throws IOException {
 		try (Writer writer = Files.newBufferedWriter(outFile, StandardCharsets.UTF_8)) {
 			writer.write(content);
 		}
-		// Make sure it's not executable
-		try {
-			Files.setPosixFilePermissions(outFile, PosixFilePermissions.fromString("rw-r-----"));
-		} catch (UnsupportedOperationException e) {
-			// The associated file system does not support the PosixFileAttributeView,
-			// ignore the error
-			LOGGER.log(Level.SEVERE,
-					"The associated file system '" + outFile + "' + does not support the PosixFileAttributeView", e);
-		}
 	}
 
 	public static int getOffsetAfterScheme(String uri) {
@@ -176,8 +162,7 @@ public static int getOffsetAfterScheme(String uri) {
 	 * the path to that, else it will try to find the parent directory of the
 	 * givenPath.
 	 * 
-	 * **IMPORTANT** The slashes of the given paths have to match the supported OS
-	 * file path slash
+	 * **IMPORTANT** The slashes of the given paths have to match the supported OS file path slash
 	 * 
 	 * @param parentDirectory The directory that the given path is relative to
 	 * @param givenPath       Path that could be absolute or relative
@@ -193,11 +178,13 @@ public static Path getNormalizedPath(String parentDirectory, String givenPath) {
 
 		// in case the given path is incomplete, trim the end
 		String givenPathCleaned;
-		if (lastIndexOfSlash == 0) { // Looks like `/someFileOrFolder`
+		if(lastIndexOfSlash == 0) { // Looks like `/someFileOrFolder`
 			return Paths.get(SLASH);
-		} else {
+		}
+		else {
 			givenPathCleaned = lastIndexOfSlash > -1 ? givenPath.substring(0, lastIndexOfSlash) : null;
 		}
+		
 
 		Path p;
 
@@ -214,14 +201,16 @@ public static Path getNormalizedPath(String parentDirectory, String givenPath) {
 			return p;
 		}
 
+
+
 		if (parentDirectory == null) {
 			return null;
 		}
 
 		if (parentDirectory.endsWith(SLASH)) {
 			parentDirectory = parentDirectory.substring(0, parentDirectory.length() - 1);
 		}
-
+		
 		String combinedPath = parentDirectory + SLASH + givenPath;
 		p = getPathIfExists(combinedPath);
 		if (p != null) {
@@ -248,9 +237,8 @@ private static Path getPathIfExists(String path) {
 	}
 
 	/**
-	 * Returns the slash ("/" or "\") that is used by the given string. If no slash
-	 * is given "/" is returned by default.
-	 * 
+	 * Returns the slash ("/" or "\") that is used by the given string.
+	 * If no slash is given "/" is returned by default.
 	 * @param text
 	 * @return
 	 */
@@ -262,18 +250,18 @@ public static String getFilePathSlash(String text) {
 	}
 
 	/**
-	 * Ensures there is no slash before a drive letter, and forces use of '\'
-	 * 
+	 * Ensures there is no slash before a drive letter, and
+	 * forces use of '\'
 	 * @param pathString
 	 * @return
 	 */
 	public static String convertToWindowsPath(String pathString) {
 		String pathSlash = getFilePathSlash(pathString);
-		if (pathString.startsWith(pathSlash)) {
-			if (pathString.length() > 3) {
+		if(pathString.startsWith(pathSlash) ) {
+			if(pathString.length() > 3) {
 				char letter = pathString.charAt(1);
 				char colon = pathString.charAt(2);
-				if (Character.isLetter(letter) && ':' == colon) {
+				if(Character.isLetter(letter) && ':' == colon) {
 					pathString = pathString.substring(1);
 				}
 			}
@@ -285,8 +273,4 @@ public static boolean pathEndsWithFile(String pathString) {
 		Matcher m = endFilePattern.matcher(pathString);
 		return m.matches();
 	}
-
-	public static boolean isIncludedInDeployedPath(Path resourceCachePath) {
-		return resourceCachePath.normalize().startsWith(DEPLOYED_BASE_PATH.get());
-	}
 }
