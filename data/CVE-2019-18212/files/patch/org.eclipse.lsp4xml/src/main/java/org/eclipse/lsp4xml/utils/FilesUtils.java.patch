@@ -20,6 +20,9 @@
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
+import java.nio.file.attribute.PosixFilePermissions;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
@@ -32,6 +35,8 @@
  */
 public class FilesUtils {
 
+	private static final Logger LOGGER = Logger.getLogger(FilesUtils.class.getName());
+
 	public static final String FILE_SCHEME = "file://";
 	public static final String LSP4XML_WORKDIR_KEY = "lsp4xml.workdir";
 	private static String cachePathSetting = null;
@@ -143,6 +148,15 @@ public static void saveToFile(String content, Path outFile) throws IOException {
 		try (Writer writer = Files.newBufferedWriter(outFile, StandardCharsets.UTF_8)) {
 			writer.write(content);
 		}
+		// Make sure it's not executable
+		try {
+			Files.setPosixFilePermissions(outFile, PosixFilePermissions.fromString("rw-r-----"));
+		} catch (UnsupportedOperationException e) {
+			// The associated file system does not support the PosixFileAttributeView,
+			// ignore the error
+			LOGGER.log(Level.SEVERE,
+					"The associated file system '" + outFile + "' + does not support the PosixFileAttributeView", e);
+		}
 	}
 
 	public static int getOffsetAfterScheme(String uri) {
@@ -162,7 +176,8 @@ public static int getOffsetAfterScheme(String uri) {
 	 * the path to that, else it will try to find the parent directory of the
 	 * givenPath.
 	 * 
-	 * **IMPORTANT** The slashes of the given paths have to match the supported OS file path slash
+	 * **IMPORTANT** The slashes of the given paths have to match the supported OS
+	 * file path slash
 	 * 
 	 * @param parentDirectory The directory that the given path is relative to
 	 * @param givenPath       Path that could be absolute or relative
@@ -178,13 +193,11 @@ public static Path getNormalizedPath(String parentDirectory, String givenPath) {
 
 		// in case the given path is incomplete, trim the end
 		String givenPathCleaned;
-		if(lastIndexOfSlash == 0) { // Looks like `/someFileOrFolder`
+		if (lastIndexOfSlash == 0) { // Looks like `/someFileOrFolder`
 			return Paths.get(SLASH);
-		}
-		else {
+		} else {
 			givenPathCleaned = lastIndexOfSlash > -1 ? givenPath.substring(0, lastIndexOfSlash) : null;
 		}
-		
 
 		Path p;
 
@@ -201,16 +214,14 @@ public static Path getNormalizedPath(String parentDirectory, String givenPath) {
 			return p;
 		}
 
-
-
 		if (parentDirectory == null) {
 			return null;
 		}
 
 		if (parentDirectory.endsWith(SLASH)) {
 			parentDirectory = parentDirectory.substring(0, parentDirectory.length() - 1);
 		}
-		
+
 		String combinedPath = parentDirectory + SLASH + givenPath;
 		p = getPathIfExists(combinedPath);
 		if (p != null) {
@@ -237,8 +248,9 @@ private static Path getPathIfExists(String path) {
 	}
 
 	/**
-	 * Returns the slash ("/" or "\") that is used by the given string.
-	 * If no slash is given "/" is returned by default.
+	 * Returns the slash ("/" or "\") that is used by the given string. If no slash
+	 * is given "/" is returned by default.
+	 * 
 	 * @param text
 	 * @return
 	 */
@@ -250,18 +262,18 @@ public static String getFilePathSlash(String text) {
 	}
 
 	/**
-	 * Ensures there is no slash before a drive letter, and
-	 * forces use of '\'
+	 * Ensures there is no slash before a drive letter, and forces use of '\'
+	 * 
 	 * @param pathString
 	 * @return
 	 */
 	public static String convertToWindowsPath(String pathString) {
 		String pathSlash = getFilePathSlash(pathString);
-		if(pathString.startsWith(pathSlash) ) {
-			if(pathString.length() > 3) {
+		if (pathString.startsWith(pathSlash)) {
+			if (pathString.length() > 3) {
 				char letter = pathString.charAt(1);
 				char colon = pathString.charAt(2);
-				if(Character.isLetter(letter) && ':' == colon) {
+				if (Character.isLetter(letter) && ':' == colon) {
 					pathString = pathString.substring(1);
 				}
 			}
@@ -273,4 +285,8 @@ public static boolean pathEndsWithFile(String pathString) {
 		Matcher m = endFilePattern.matcher(pathString);
 		return m.matches();
 	}
+
+	public static boolean isIncludedInDeployedPath(Path resourceCachePath) {
+		return resourceCachePath.normalize().startsWith(DEPLOYED_BASE_PATH.get());
+	}
 }
