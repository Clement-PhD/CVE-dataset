@@ -40,6 +40,7 @@ limitations under the License.
 #include "chisel.h"
 #include "sysdig.h"
 
+#include "event_drops.h"
 #include "configuration.h"
 #include "falco_engine.h"
 #include "config_falco.h"
@@ -132,6 +133,9 @@ static void usage()
            "                               from multiple files/directories.\n"
 	   " -s <stats_file>               If specified, write statistics related to falco's reading/processing of events\n"
 	   "                               to this file. (Only useful in live mode).\n"
+	   " --stats_interval <msec>       When using -s <stats_file>, write statistics every <msec> ms.\n"
+	   "                               (This uses signals, so don't recommend intervals below 200 ms)\n"
+	   "                               defaults to 5000 (5 seconds)\n"
 	   " -S <len>, --snaplen=<len>\n"
 	   "                  		   Capture the first <len> bytes of each I/O buffer.\n"
 	   "                   		   By default, the first 80 bytes are captured. Use this\n"
@@ -215,21 +219,32 @@ static std::string read_file(std::string filename)
 uint64_t do_inspect(falco_engine *engine,
 		    falco_outputs *outputs,
 		    sinsp* inspector,
+		    falco_configuration &config,
+		    syscall_evt_drop_mgr &sdropmgr,
 		    uint64_t duration_to_tot_ns,
 		    string &stats_filename,
-		    bool all_events)
+		    uint64_t stats_interval,
+		    bool all_events,
+		    int &result)
 {
 	uint64_t num_evts = 0;
 	int32_t rc;
 	sinsp_evt* ev;
 	StatsFileWriter writer;
 	uint64_t duration_start = 0;
 
+	sdropmgr.init(inspector,
+		      outputs,
+		      config.m_syscall_evt_drop_actions,
+		      config.m_syscall_evt_drop_rate,
+		      config.m_syscall_evt_drop_max_burst,
+		      config.m_syscall_evt_simulate_drops);
+
 	if (stats_filename != "")
 	{
 		string errstr;
 
-		if (!writer.init(inspector, stats_filename, 5, errstr))
+		if (!writer.init(inspector, stats_filename, stats_interval, errstr))
 		{
 			throw falco_exception(errstr);
 		}
@@ -285,6 +300,12 @@ uint64_t do_inspect(falco_engine *engine,
 			}
 		}
 
+		if(!sdropmgr.process_event(ev))
+		{
+			result = EXIT_FAILURE;
+			break;
+		}
+
 		if(!ev->falco_consider() && !all_events)
 		{
 			continue;
@@ -375,6 +396,7 @@ int falco_init(int argc, char **argv)
 	sinsp_evt::param_fmt event_buffer_format = sinsp_evt::PF_NORMAL;
 	falco_engine *engine = NULL;
 	falco_outputs *outputs = NULL;
+	syscall_evt_drop_mgr sdropmgr;
 	int op;
 	int long_index = 0;
 	string trace_filename;
@@ -388,6 +410,7 @@ int falco_init(int argc, char **argv)
 	string describe_rule = "";
 	list<string> validate_rules_filenames;
 	string stats_filename = "";
+	uint64_t stats_interval = 5000;
 	bool verbose = false;
 	bool names_only = false;
 	bool all_events = false;
@@ -432,6 +455,7 @@ int falco_init(int argc, char **argv)
 		{"print", required_argument, 0, 'p' },
 		{"pidfile", required_argument, 0, 'P' },
 		{"snaplen", required_argument, 0, 'S' },
+		{"stats_interval", required_argument, 0},
 		{"support", no_argument, 0},
 		{"unbuffered", no_argument, 0, 'U' },
 		{"version", no_argument, 0, 0 },
@@ -588,6 +612,10 @@ int falco_init(int argc, char **argv)
 						list_flds_source = optarg;
 					}
 				}
+				else if (string(long_options[long_index].name) == "stats_interval")
+				{
+					stats_interval = atoi(optarg);
+				}
 				else if (string(long_options[long_index].name) == "support")
 				{
 					print_support = true;
@@ -1061,9 +1089,13 @@ int falco_init(int argc, char **argv)
 			num_evts = do_inspect(engine,
 					      outputs,
 					      inspector,
+					      config,
+					      sdropmgr,
 					      uint64_t(duration_to_tot*ONE_SECOND_IN_NS),
 					      stats_filename,
-					      all_events);
+					      stats_interval,
+					      all_events,
+					      result);
 
 			duration = ((double)clock()) / CLOCKS_PER_SEC - duration;
 
@@ -1085,6 +1117,7 @@ int falco_init(int argc, char **argv)
 
 		inspector->close();
 		engine->print_stats();
+		sdropmgr.print_stats();
 		webserver.stop();
 	}
 	catch(exception &e)