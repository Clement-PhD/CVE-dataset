@@ -46,7 +46,7 @@
 #include "ll_filter.h"
 
 #define BT_DBG_ENABLED IS_ENABLED(CONFIG_BT_DEBUG_HCI_DRIVER)
-#define LOG_MODULE_NAME bt_ctlr_llsw_ctrl
+#define LOG_MODULE_NAME bt_ctlr_ctrl
 #include "common/log.h"
 
 #if defined(CONFIG_BT_CTLR_CONN_RSSI)
@@ -338,15 +338,16 @@ static void ctrl_tx_enqueue(struct connection *conn,
 			    struct radio_pdu_node_tx *node_tx);
 static void connection_release(struct connection *conn);
 static void terminate_ind_rx_enqueue(struct connection *conn, u8_t reason);
-static u8_t conn_update(struct connection *conn, struct pdu_data *pdu_data_rx);
-
 #if defined(CONFIG_BT_CTLR_XTAL_ADVANCED) && \
     defined(CONFIG_BT_CTLR_SCHED_ADVANCED)
 static u32_t conn_update_req(struct connection *conn);
 #endif /* CONFIG_BT_CTLR_XTAL_ADVANCED && CONFIG_BT_CTLR_SCHED_ADVANCED */
 
+#if defined(CONFIG_BT_PERIPHERAL)
+static u8_t conn_update(struct connection *conn, struct pdu_data *pdu_data_rx);
 static u8_t chan_map_update(struct connection *conn,
 			    struct pdu_data *pdu_data_rx);
+#endif /* CONFIG_BT_PERIPHERAL */
 
 #if defined(CONFIG_BT_CTLR_PHY)
 static inline u8_t phy_upd_ind_recv(struct radio_pdu_node_rx *node_rx,
@@ -356,7 +357,9 @@ static inline u8_t phy_upd_ind_recv(struct radio_pdu_node_rx *node_rx,
 #if defined(CONFIG_BT_CTLR_LE_ENC)
 static void enc_req_reused_send(struct connection *conn,
 				struct radio_pdu_node_tx *node_tx);
+#if defined(CONFIG_BT_PERIPHERAL)
 static u8_t enc_rsp_send(struct connection *conn);
+#endif /* CONFIG_BT_PERIPHERAL */
 static u8_t start_enc_rsp_send(struct connection *conn,
 			       struct pdu_data *pdu_ctrl_tx);
 static u8_t pause_enc_rsp_send(struct connection *conn, u8_t req);
@@ -569,7 +572,9 @@ void ll_reset(void)
 	_radio.fc_ack = _radio.fc_req;
 
 	/* reset whitelist and resolving list */
-	ll_filter_reset(false);
+	if (IS_ENABLED(CONFIG_BT_CTLR_FILTER)) {
+		ll_filter_reset(false);
+	}
 
 	/* memory allocations */
 	common_init();
@@ -719,9 +724,9 @@ static inline void isr_radio_state_tx(void)
 		 */
 		radio_tmr_end_capture();
 
-#if defined(CONFIG_BT_CTLR_SCAN_REQ_RSSI)
+#if defined(CONFIG_BT_CTLR_SCAN_REQ_RSSI) || defined(CONFIG_BT_CTLR_CONN_RSSI)
 		radio_rssi_measure();
-#endif /* CONFIG_BT_CTLR_SCAN_REQ_RSSI */
+#endif /* CONFIG_BT_CTLR_SCAN_REQ_RSSI || CONFIG_BT_CTLR_CONN_RSSI */
 
 #if defined(CONFIG_BT_CTLR_GPIO_LNA_PIN)
 		radio_gpio_pa_lna_enable(radio_tmr_tifs_base_get() +
@@ -965,6 +970,7 @@ static inline u32_t isr_rx_adv(u8_t devmatch_ok, u8_t devmatch_id,
 
 	if ((pdu_adv->type == PDU_ADV_TYPE_SCAN_REQ) &&
 	    (pdu_adv->len == sizeof(struct pdu_adv_scan_req)) &&
+	    (_pdu_adv->type != PDU_ADV_TYPE_DIRECT_IND) &&
 	    isr_adv_sr_check(_pdu_adv, pdu_adv, devmatch_ok, &rl_idx)) {
 
 #if defined(CONFIG_BT_CTLR_SCAN_REQ_NOTIFY)
@@ -1014,6 +1020,7 @@ static inline u32_t isr_rx_adv(u8_t devmatch_ok, u8_t devmatch_id,
 		u32_t conn_offset_us;
 		u32_t rx_ready_delay;
 		u32_t ticker_status;
+		u32_t ticks_at_stop;
 
 		if (IS_ENABLED(CONFIG_BT_CTLR_CHAN_SEL_2)) {
 			node_rx = packet_rx_reserve_get(4);
@@ -1047,7 +1054,13 @@ static inline u32_t isr_rx_adv(u8_t devmatch_ok, u8_t devmatch_id,
 		conn->data_chan_count =
 			util_ones_count_get(&conn->data_chan_map[0],
 					    sizeof(conn->data_chan_map));
+		if (conn->data_chan_count < 2) {
+			return 1;
+		}
 		conn->data_chan_hop = pdu_adv->connect_ind.hop;
+		if ((conn->data_chan_hop < 5) || (conn->data_chan_hop > 16)) {
+			return 1;
+		}
 		conn->conn_interval =
 			pdu_adv->connect_ind.interval;
 		conn_interval_us =
@@ -1074,6 +1087,11 @@ static inline u32_t isr_rx_adv(u8_t devmatch_ok, u8_t devmatch_id,
 				     conn->apto_reload;
 #endif /* CONFIG_BT_CTLR_LE_PING */
 
+#if defined(CONFIG_BT_CTLR_CONN_RSSI)
+		conn->rssi_latest = (rssi_ready) ? (radio_rssi_get() & 0x7f) :
+						   0x7f;
+#endif /* CONFIG_BT_CTLR_CONN_RSSI */
+
 		/* Prepare the rx packet structure */
 		node_rx->hdr.handle = conn->handle;
 		node_rx->hdr.type = NODE_RX_TYPE_CONNECTION;
@@ -1194,12 +1212,28 @@ static inline u32_t isr_rx_adv(u8_t devmatch_ok, u8_t devmatch_id,
 		conn_offset_us -= RADIO_TICKER_JITTER_US << 1;
 		conn_offset_us -= RADIO_TICKER_JITTER_US;
 
+#if (RADIO_TICKER_USER_ID_WORKER_PRIO == RADIO_TICKER_USER_ID_JOB_PRIO)
+		/* disable ticker job, in order to chain stop and start
+		 * to avoid RTC being stopped if no tickers active.
+		 */
+		u32_t mayfly_was_enabled =
+			mayfly_is_enabled(RADIO_TICKER_USER_ID_WORKER,
+					  RADIO_TICKER_USER_ID_JOB);
+		mayfly_enable(RADIO_TICKER_USER_ID_WORKER,
+			      RADIO_TICKER_USER_ID_JOB, 0);
+#endif
+
 		/* Stop Advertiser */
-		ticker_status = ticker_stop(RADIO_TICKER_INSTANCE_ID_RADIO,
-					    RADIO_TICKER_USER_ID_WORKER,
-					    RADIO_TICKER_ID_ADV,
-					    ticker_stop_adv_assert,
-					    (void *)__LINE__);
+		ticks_at_stop = _radio.ticks_anchor +
+			HAL_TICKER_US_TO_TICKS(RADIO_TICKER_START_PART_US +
+					       radio_tmr_end_get()) -
+			ticks_slot_offset;
+		ticker_status = ticker_stop_abs(RADIO_TICKER_INSTANCE_ID_RADIO,
+						RADIO_TICKER_USER_ID_WORKER,
+						RADIO_TICKER_ID_ADV,
+						ticks_at_stop,
+						ticker_stop_adv_assert,
+						(void *)__LINE__);
 		ticker_stop_adv_assert(ticker_status, (void *)__LINE__);
 
 		/* Stop Direct Adv Stopper */
@@ -1227,6 +1261,14 @@ static inline u32_t isr_rx_adv(u8_t devmatch_ok, u8_t devmatch_id,
 		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
 			  (ticker_status == TICKER_STATUS_BUSY));
 
+#if (RADIO_TICKER_USER_ID_WORKER_PRIO == RADIO_TICKER_USER_ID_JOB_PRIO)
+		/* enable ticker job, if disabled in this function */
+		if (mayfly_was_enabled) {
+			mayfly_enable(RADIO_TICKER_USER_ID_WORKER,
+				      RADIO_TICKER_USER_ID_JOB, 1);
+		}
+#endif
+
 		return 0;
 #endif /* CONFIG_BT_PERIPHERAL */
 	}
@@ -1295,23 +1337,6 @@ static u32_t isr_rx_scan_report(u8_t rssi_ready, u8_t rl_idx, bool dir_report)
 	*extra = dir_report ? 1 : 0;
 	extra += PDU_AC_SIZE_SCFP;
 #endif /* CONFIG_BT_CTLR_EXT_SCAN_FP */
-#if defined(CONFIG_BT_HCI_MESH_EXT)
-	if (node_rx->hdr.type == NODE_RX_TYPE_MESH_REPORT) {
-		/* save the directed adv report flag */
-		*extra = _radio.scanner.chan - 1;
-		extra++;
-		sys_put_le32(_radio.ticks_anchor, extra);
-	}
-#endif /* CONFIG_BT_HCI_MESH_EXT */
-
-#if defined(CONFIG_BT_HCI_MESH_EXT)
-	if (node_rx->hdr.type == NODE_RX_TYPE_MESH_REPORT) {
-		/* save the directed adv report flag */
-		*extra = _radio.scanner.chan - 1;
-		extra++;
-		sys_put_le32(_radio.ticks_anchor, extra);
-	}
-#endif /* CONFIG_BT_HCI_MESH_EXT */
 
 #if defined(CONFIG_BT_HCI_MESH_EXT)
 	if (node_rx->hdr.type == NODE_RX_TYPE_MESH_REPORT) {
@@ -1449,6 +1474,7 @@ static inline u32_t isr_rx_scan(u8_t devmatch_ok, u8_t devmatch_id,
 		u32_t conn_offset_us;
 		u32_t ticker_status;
 		u32_t conn_space_us;
+		u32_t ticks_at_stop;
 #if defined(CONFIG_BT_CTLR_PRIVACY)
 		bt_addr_t *lrpa;
 #endif /* CONFIG_BT_CTLR_PRIVACY */
@@ -1469,6 +1495,11 @@ static inline u32_t isr_rx_scan(u8_t devmatch_ok, u8_t devmatch_id,
 		conn = _radio.scanner.conn;
 		_radio.scanner.conn = NULL;
 
+#if defined(CONFIG_BT_CTLR_CONN_RSSI)
+		conn->rssi_latest = (rssi_ready) ? (radio_rssi_get() & 0x7f) :
+						   0x7f;
+#endif /* CONFIG_BT_CTLR_CONN_RSSI */
+
 		/* Tx the connect request packet */
 		pdu_adv_tx = (void *)radio_pkt_scratch_get();
 		pdu_adv_tx->type = PDU_ADV_TYPE_CONNECT_IND;
@@ -1679,12 +1710,28 @@ static inline u32_t isr_rx_scan(u8_t devmatch_ok, u8_t devmatch_id,
 		ticks_slot_offset = MAX(conn->hdr.ticks_active_to_start,
 					conn->hdr.ticks_xtal_to_start);
 
+#if (RADIO_TICKER_USER_ID_WORKER_PRIO == RADIO_TICKER_USER_ID_JOB_PRIO)
+		/* disable ticker job, in order to chain stop and start
+		 * to avoid RTC being stopped if no tickers active.
+		 */
+		u32_t mayfly_was_enabled =
+			mayfly_is_enabled(RADIO_TICKER_USER_ID_WORKER,
+					  RADIO_TICKER_USER_ID_JOB);
+		mayfly_enable(RADIO_TICKER_USER_ID_WORKER,
+			      RADIO_TICKER_USER_ID_JOB, 0);
+#endif
+
 		/* Stop Scanner */
-		ticker_status = ticker_stop(RADIO_TICKER_INSTANCE_ID_RADIO,
-					    RADIO_TICKER_USER_ID_WORKER,
-					    RADIO_TICKER_ID_SCAN,
-					    ticker_stop_scan_assert,
-					    (void *)__LINE__);
+		ticks_at_stop = _radio.ticks_anchor +
+			HAL_TICKER_US_TO_TICKS(RADIO_TICKER_START_PART_US +
+					       conn_offset_us - 1250) -
+			ticks_slot_offset;
+		ticker_status = ticker_stop_abs(RADIO_TICKER_INSTANCE_ID_RADIO,
+						RADIO_TICKER_USER_ID_WORKER,
+						RADIO_TICKER_ID_SCAN,
+						ticks_at_stop,
+						ticker_stop_scan_assert,
+						(void *)__LINE__);
 		ticker_stop_scan_assert(ticker_status, (void *)__LINE__);
 
 		/* Scanner stop can expire while here in this ISR.
@@ -1712,6 +1759,14 @@ static inline u32_t isr_rx_scan(u8_t devmatch_ok, u8_t devmatch_id,
 		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
 			  (ticker_status == TICKER_STATUS_BUSY));
 
+#if (RADIO_TICKER_USER_ID_WORKER_PRIO == RADIO_TICKER_USER_ID_JOB_PRIO)
+		/* enable ticker job, if disabled in this function */
+		if (mayfly_was_enabled) {
+			mayfly_enable(RADIO_TICKER_USER_ID_WORKER,
+				      RADIO_TICKER_USER_ID_JOB, 1);
+		}
+#endif
+
 		return 0;
 #endif /* CONFIG_BT_CENTRAL */
 	}
@@ -1865,6 +1920,7 @@ static inline u32_t isr_rx_conn_pkt_ack(struct pdu_data *pdu_data_tx,
 		break;
 
 #if defined(CONFIG_BT_CTLR_LE_ENC)
+#if defined(CONFIG_BT_CENTRAL)
 	case PDU_DATA_LLCTRL_TYPE_ENC_REQ:
 		/* things from master stored for session key calculation */
 		memcpy(&_radio.conn_curr->llcp.encryption.skd[0],
@@ -1885,7 +1941,9 @@ static inline u32_t isr_rx_conn_pkt_ack(struct pdu_data *pdu_data_tx,
 		/* Reset enc req queued state */
 		_radio.conn_curr->llcp_enc.ack = _radio.conn_curr->llcp_enc.req;
 		break;
+#endif /* CONFIG_BT_CENTRAL */
 
+#if defined(CONFIG_BT_PERIPHERAL)
 	case PDU_DATA_LLCTRL_TYPE_ENC_RSP:
 		/* pause data packet tx */
 		_radio.conn_curr->pause_tx = 1U;
@@ -1897,7 +1955,9 @@ static inline u32_t isr_rx_conn_pkt_ack(struct pdu_data *pdu_data_tx,
 		 * alongwith this tx ack at this point in time.
 		 */
 		break;
+#endif /* CONFIG_BT_PERIPHERAL */
 
+#if defined(CONFIG_BT_CENTRAL)
 	case PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_REQ:
 		/* pause data packet tx */
 		_radio.conn_curr->pause_tx = 1U;
@@ -1915,6 +1975,7 @@ static inline u32_t isr_rx_conn_pkt_ack(struct pdu_data *pdu_data_tx,
 		/* Reset enc req queued state */
 		_radio.conn_curr->llcp_enc.ack = _radio.conn_curr->llcp_enc.req;
 		break;
+#endif /* CONFIG_BT_CENTRAL */
 
 	case PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_RSP:
 		if (_radio.role == ROLE_MASTER) {
@@ -2013,16 +2074,20 @@ static inline u32_t isr_rx_conn_pkt_ack(struct pdu_data *pdu_data_tx,
 		_radio.conn_curr->llcp_phy.state = LLCP_PHY_STATE_RSP_WAIT;
 		/* fall through */
 
+#if defined(CONFIG_BT_PERIPHERAL)
 	case PDU_DATA_LLCTRL_TYPE_PHY_RSP:
 		if (_radio.role == ROLE_SLAVE) {
 			isr_rx_conn_phy_tx_time_set();
 		}
+#endif /* CONFIG_BT_PERIPHERAL */
 		break;
 
+#if defined(CONFIG_BT_CENTRAL)
 	case PDU_DATA_LLCTRL_TYPE_PHY_UPD_IND:
 		_radio.conn_curr->phy_tx_time =
 			_radio.conn_curr->llcp.phy_upd_ind.tx;
 		break;
+#endif /* CONFIG_BT_CENTRAL */
 #endif /* CONFIG_BT_CTLR_PHY */
 
 	default:
@@ -2246,62 +2311,138 @@ isr_rx_conn_pkt_ctrl_rej_phy_upd(struct radio_pdu_node_rx *node_rx,
 }
 #endif /* CONFIG_BT_CTLR_PHY */
 
+#if defined(CONFIG_BT_CTLR_LE_ENC)
+static inline void
+isr_rx_conn_pkt_ctrl_rej_enc(struct radio_pdu_node_rx *node_rx,
+			     u8_t *rx_enqueue)
+{
+	/* resume data packet rx and tx */
+	_radio.conn_curr->pause_rx = 0U;
+	_radio.conn_curr->pause_tx = 0U;
+
+	/* Procedure complete */
+	_radio.conn_curr->llcp_ack = _radio.conn_curr->llcp_req;
+	_radio.conn_curr->procedure_expire = 0U;
+
+	*rx_enqueue = 1U;
+}
+#endif /* CONFIG_BT_CTLR_LE_ENC */
+
 static inline void
 isr_rx_conn_pkt_ctrl_rej(struct radio_pdu_node_rx *node_rx, u8_t *rx_enqueue)
 {
-	if (0) {
+	struct pdu_data_llctrl_reject_ext_ind *rej_ext_ind;
+	struct pdu_data *pdu_rx;
+
+	pdu_rx = (void *)node_rx->pdu_data;
+	rej_ext_ind = (void *)&pdu_rx->llctrl.reject_ext_ind;
+
+	switch (rej_ext_ind->reject_opcode) {
+#if defined(CONFIG_BT_CENTRAL) && defined(CONFIG_BT_CTLR_LE_ENC)
+	case PDU_DATA_LLCTRL_TYPE_ENC_REQ:
+		if (_radio.conn_curr->llcp_ack != _radio.conn_curr->llcp_req &&
+		    _radio.conn_curr->llcp_type == LLCP_ENCRYPTION) {
+			/* enqueue as if it were a reject ind */
+			pdu_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_IND;
+			pdu_rx->llctrl.reject_ind.error_code =
+				rej_ext_ind->error_code;
+
+			isr_rx_conn_pkt_ctrl_rej_enc(node_rx, rx_enqueue);
+		}
+		break;
+#endif /* CONFIG_BT_CENTRAL && CONFIG_BT_CTLR_LE_ENC */
+
 #if defined(CONFIG_BT_CTLR_PHY)
-	} else if (_radio.conn_curr->llcp_phy.ack !=
-		   _radio.conn_curr->llcp_phy.req) {
-		isr_rx_conn_pkt_ctrl_rej_phy_upd(node_rx, rx_enqueue);
+	case PDU_DATA_LLCTRL_TYPE_PHY_REQ:
+		if (_radio.conn_curr->llcp_phy.ack !=
+		    _radio.conn_curr->llcp_phy.req) {
+			isr_rx_conn_pkt_ctrl_rej_phy_upd(node_rx, rx_enqueue);
+		}
+		break;
 #endif /* CONFIG_BT_CTLR_PHY */
 
 #if defined(CONFIG_BT_CTLR_CONN_PARAM_REQ)
-	} else if (_radio.conn_curr->llcp_conn_param.ack !=
-		   _radio.conn_curr->llcp_conn_param.req) {
-		isr_rx_conn_pkt_ctrl_rej_conn_upd(node_rx, rx_enqueue);
+	case PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ:
+		if (_radio.conn_curr->llcp_conn_param.ack !=
+		    _radio.conn_curr->llcp_conn_param.req) {
+			isr_rx_conn_pkt_ctrl_rej_conn_upd(node_rx, rx_enqueue);
+		}
+		break;
 #endif /* CONFIG_BT_CTLR_CONN_PARAM_REQ */
 
 #if defined(CONFIG_BT_CTLR_DATA_LENGTH)
-	} else if (_radio.conn_curr->llcp_length.ack !=
-		   _radio.conn_curr->llcp_length.req) {
-		isr_rx_conn_pkt_ctrl_rej_dle(node_rx, rx_enqueue);
+	case PDU_DATA_LLCTRL_TYPE_LENGTH_REQ:
+		if (_radio.conn_curr->llcp_length.ack !=
+		    _radio.conn_curr->llcp_length.req) {
+			isr_rx_conn_pkt_ctrl_rej_dle(node_rx, rx_enqueue);
+		}
+		break;
 #endif /* CONFIG_BT_CTLR_DATA_LENGTH */
+	default:
+		/* Ignore */
+		break;
+	}
+}
 
-#if defined(CONFIG_BT_CTLR_LE_ENC)
-	} else {
-		struct pdu_data_llctrl_reject_ext_ind *rej_ext_ind;
-		struct pdu_data *pdu_rx;
-
-		pdu_rx = (void *)node_rx->pdu_data;
-		rej_ext_ind = (void *)&pdu_rx->llctrl.reject_ext_ind;
-
-		switch (rej_ext_ind->reject_opcode) {
-		case PDU_DATA_LLCTRL_TYPE_ENC_REQ:
-			/* resume data packet rx and tx */
-			_radio.conn_curr->pause_rx = 0U;
-			_radio.conn_curr->pause_tx = 0U;
+#if defined(CONFIG_BT_CTLR_DATA_LENGTH)
+static void dle_max_time_get(struct connection *conn, u16_t *max_rx_time,
+			     u16_t *max_tx_time)
+{
+	if (!conn->common.fex_valid ||
+#if defined(CONFIG_BT_CTLR_PHY)
+	     (
+#if defined(CONFIG_BT_CTLR_PHY_CODED)
+	      !(conn->llcp_feature.features &
+		BIT(BT_LE_FEAT_BIT_PHY_CODED)) &&
+#endif /* CONFIG_BT_CTLR_PHY_CODED */
 
-			/* Procedure complete */
-			_radio.conn_curr->llcp_ack = _radio.conn_curr->llcp_req;
-			_radio.conn_curr->procedure_expire = 0U;
+#if defined(CONFIG_BT_CTLR_PHY_2M)
+	      !(conn->llcp_feature.features &
+		BIT(BT_LE_FEAT_BIT_PHY_2M)) &&
+#endif /* CONFIG_BT_CTLR_PHY_2M */
+	      1)
+#else /* !CONFIG_BT_CTLR_PHY */
+	    1
+#endif /* !CONFIG_BT_CTLR_PHY */
+	   ) {
+		*max_rx_time = RADIO_PKT_TIME(LL_LENGTH_OCTETS_RX_MAX, 0);
+#if defined(CONFIG_BT_CTLR_PHY)
+		*max_tx_time = MAX(MIN(RADIO_PKT_TIME(LL_LENGTH_OCTETS_RX_MAX,
+						      0),
+				       conn->default_tx_time),
+				   RADIO_PKT_TIME(PDU_DC_PAYLOAD_SIZE_MIN, 0));
+#else /* !CONFIG_BT_CTLR_PHY */
+		*max_tx_time = RADIO_PKT_TIME(conn->default_tx_octets, 0);
+#endif /* !CONFIG_BT_CTLR_PHY */
 
-			/* enqueue as if it were a reject ind */
-			pdu_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_IND;
-			pdu_rx->llctrl.reject_ind.error_code =
-				rej_ext_ind->error_code;
-			*rx_enqueue = 1U;
-			break;
+#if defined(CONFIG_BT_CTLR_PHY)
+#if defined(CONFIG_BT_CTLR_PHY_CODED)
+	} else if (conn->llcp_feature.features &
+		   BIT(BT_LE_FEAT_BIT_PHY_CODED)) {
+		*max_rx_time = MAX(RADIO_PKT_TIME(LL_LENGTH_OCTETS_RX_MAX,
+						  BIT(2)),
+				   RADIO_PKT_TIME(PDU_DC_PAYLOAD_SIZE_MIN, 0));
+		*max_tx_time = MAX(MIN(RADIO_PKT_TIME(LL_LENGTH_OCTETS_RX_MAX,
+						      BIT(2)),
+				       conn->default_tx_time),
+				   RADIO_PKT_TIME(PDU_DC_PAYLOAD_SIZE_MIN, 0));
+#endif /* CONFIG_BT_CTLR_PHY_CODED */
 
-		default:
-			/* Ignore */
-			break;
-		}
-#endif /* CONFIG_BT_CTLR_LE_ENC */
+#if defined(CONFIG_BT_CTLR_PHY_2M)
+	} else if (conn->llcp_feature.features &
+		   BIT(BT_LE_FEAT_BIT_PHY_2M)) {
+		*max_rx_time = MAX(RADIO_PKT_TIME(LL_LENGTH_OCTETS_RX_MAX,
+						  BIT(1)),
+				   RADIO_PKT_TIME(PDU_DC_PAYLOAD_SIZE_MIN, 0));
+		*max_tx_time = MAX(MIN(RADIO_PKT_TIME(LL_LENGTH_OCTETS_RX_MAX,
+						      BIT(1)),
+				       conn->default_tx_time),
+				   RADIO_PKT_TIME(PDU_DC_PAYLOAD_SIZE_MIN, 0));
+#endif /* CONFIG_BT_CTLR_PHY_2M */
+#endif /* CONFIG_BT_CTLR_PHY */
 	}
 }
 
-#if defined(CONFIG_BT_CTLR_DATA_LENGTH)
 static inline u8_t isr_rx_conn_pkt_ctrl_dle(struct pdu_data *pdu_data_rx,
 					    u8_t *rx_enqueue)
 {
@@ -2334,9 +2475,7 @@ static inline u8_t isr_rx_conn_pkt_ctrl_dle(struct pdu_data *pdu_data_rx,
 	     * with response.
 	     */
 	    ((_radio.conn_curr->llcp_length.req ==
-	      _radio.conn_curr->llcp_length.ack) &&
-	     (pdu_data_rx->llctrl.opcode ==
-	      PDU_DATA_LLCTRL_TYPE_LENGTH_REQ)) ||
+	      _radio.conn_curr->llcp_length.ack) && node_tx) ||
 	    /* or Local has active... */
 	    ((_radio.conn_curr->llcp_length.req !=
 	      _radio.conn_curr->llcp_length.ack) &&
@@ -2346,19 +2485,13 @@ static inline u8_t isr_rx_conn_pkt_ctrl_dle(struct pdu_data *pdu_data_rx,
 	     ((((_radio.conn_curr->llcp_length.state ==
 		 LLCP_LENGTH_STATE_REQ) ||
 		(_radio.conn_curr->llcp_length.state ==
-		 LLCP_LENGTH_STATE_REQ_ACK_WAIT)) &&
-	       (pdu_data_rx->llctrl.opcode ==
-		PDU_DATA_LLCTRL_TYPE_LENGTH_REQ)) ||
+		 LLCP_LENGTH_STATE_REQ_ACK_WAIT)) && node_tx) ||
 	      /* with Local waiting for response, and Peer response then
 	       * complete the Local procedure or Peer request then complete the
 	       * Peer procedure with response.
 	       */
-	      ((_radio.conn_curr->llcp_length.state ==
-		LLCP_LENGTH_STATE_RSP_WAIT) &&
-	       ((pdu_data_rx->llctrl.opcode ==
-		 PDU_DATA_LLCTRL_TYPE_LENGTH_RSP) ||
-		(pdu_data_rx->llctrl.opcode ==
-		 PDU_DATA_LLCTRL_TYPE_LENGTH_REQ)))))) {
+	      (_radio.conn_curr->llcp_length.state ==
+		LLCP_LENGTH_STATE_RSP_WAIT)))) {
 		struct pdu_data_llctrl_length_req *lr;
 
 		lr = &pdu_data_rx->llctrl.length_req;
@@ -2380,14 +2513,17 @@ static inline u8_t isr_rx_conn_pkt_ctrl_dle(struct pdu_data *pdu_data_rx,
 		}
 
 #if defined(CONFIG_BT_CTLR_PHY)
-		/* use the minimal of our default_tx_time and
+		u16_t max_rx_time, max_tx_time;
+
+		dle_max_time_get(_radio.conn_curr, &max_rx_time, &max_tx_time);
+
+		/* use the minimal of our max_tx_time and
 		 * peer max_rx_time
 		 */
 		if (lr->max_rx_time >=
 		    RADIO_PKT_TIME(PDU_DC_PAYLOAD_SIZE_MIN, 0)) {
-			eff_tx_time =
-				MIN(lr->max_rx_time,
-				    _radio.conn_curr->default_tx_time);
+			eff_tx_time = MIN(lr->max_rx_time, max_tx_time);
+
 #if defined(CONFIG_BT_CTLR_PHY_CODED)
 			eff_tx_time =
 				MAX(eff_tx_time,
@@ -2401,10 +2537,8 @@ static inline u8_t isr_rx_conn_pkt_ctrl_dle(struct pdu_data *pdu_data_rx,
 		 */
 		if (lr->max_tx_time >=
 		    RADIO_PKT_TIME(PDU_DC_PAYLOAD_SIZE_MIN, 0)) {
-			eff_rx_time =
-				MIN(lr->max_tx_time,
-				    RADIO_PKT_TIME(LL_LENGTH_OCTETS_RX_MAX,
-						   BIT(2)));
+			eff_rx_time = MIN(lr->max_tx_time, max_rx_time);
+
 #if defined(CONFIG_BT_CTLR_PHY_CODED)
 			eff_rx_time =
 				MAX(eff_rx_time,
@@ -2543,9 +2677,21 @@ static inline u8_t isr_rx_conn_pkt_ctrl_dle(struct pdu_data *pdu_data_rx,
 			*rx_enqueue = 1U;
 		}
 	} else {
-		/* Drop response with no Local initiated request. */
-		LL_ASSERT(pdu_data_rx->llctrl.opcode ==
-			  PDU_DATA_LLCTRL_TYPE_LENGTH_RSP);
+		/* Drop response with no Local initiated request and duplicate
+		 * requests.
+		 */
+		if (pdu_data_rx->llctrl.opcode !=
+		    PDU_DATA_LLCTRL_TYPE_LENGTH_RSP) {
+			mem_release(node_tx, &_radio.pkt_tx_ctrl_free);
+
+			/* Defer new request if previous in resize state */
+			if (_radio.conn_curr->llcp_length.state ==
+			    LLCP_LENGTH_STATE_RESIZE) {
+				return 1U;
+			}
+		}
+
+		return 0;
 	}
 
 send_length_resp:
@@ -2638,6 +2784,7 @@ isr_rx_conn_pkt_ctrl(struct radio_pdu_node_rx *node_rx,
 	pdu_data_rx = (void *)node_rx->pdu_data;
 
 	switch (pdu_data_rx->llctrl.opcode) {
+#if defined(CONFIG_BT_PERIPHERAL)
 	case PDU_DATA_LLCTRL_TYPE_CONN_UPDATE_IND:
 	{
 		u8_t err;
@@ -2674,6 +2821,7 @@ isr_rx_conn_pkt_ctrl(struct radio_pdu_node_rx *node_rx,
 		}
 	}
 	break;
+#endif /* CONFIG_BT_PERIPHERAL */
 
 	case PDU_DATA_LLCTRL_TYPE_TERMINATE_IND:
 		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_TERMINATE_IND,
@@ -2687,6 +2835,7 @@ isr_rx_conn_pkt_ctrl(struct radio_pdu_node_rx *node_rx,
 		break;
 
 #if defined(CONFIG_BT_CTLR_LE_ENC)
+#if defined(CONFIG_BT_PERIPHERAL)
 	case PDU_DATA_LLCTRL_TYPE_ENC_REQ:
 		if (!_radio.conn_curr->role ||
 		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_ENC_REQ,
@@ -2713,7 +2862,30 @@ isr_rx_conn_pkt_ctrl(struct radio_pdu_node_rx *node_rx,
 		if (nack) {
 			break;
 		}
-#endif /* CONFIG_BT_CTLR_FAST_ENC */
+
+		/* enqueue the enc req */
+		*rx_enqueue = 1U;
+
+		/* Start Enc Req to be scheduled by LL api */
+		_radio.conn_curr->llcp.encryption.state =
+			LLCP_ENC_STATE_LTK_WAIT;
+#else /* !CONFIG_BT_CTLR_FAST_ENC */
+		/* back up rand and ediv for deferred generation of Enc Req */
+		memcpy(&_radio.conn_curr->llcp_enc.rand[0],
+		       &pdu_data_rx->llctrl.enc_req.rand[0],
+		       sizeof(_radio.conn_curr->llcp_enc.rand));
+		_radio.conn_curr->llcp_enc.ediv[0] =
+			pdu_data_rx->llctrl.enc_req.ediv[0];
+		_radio.conn_curr->llcp_enc.ediv[1] =
+			pdu_data_rx->llctrl.enc_req.ediv[1];
+
+		/* Enc rsp to be scheduled in master prepare */
+		_radio.conn_curr->llcp.encryption.state = LLCP_ENC_STATE_INIT;
+#endif /* !CONFIG_BT_CTLR_FAST_ENC */
+
+		/* Enc Setup requested */
+		_radio.conn_curr->llcp_type = LLCP_ENCRYPTION;
+		_radio.conn_curr->llcp_ack--;
 
 		/* things from master stored for session key calculation */
 		memcpy(&_radio.conn_curr->llcp.encryption.skd[0],
@@ -2729,11 +2901,10 @@ isr_rx_conn_pkt_ctrl(struct radio_pdu_node_rx *node_rx,
 		 */
 		_radio.conn_curr->procedure_expire =
 			_radio.conn_curr->procedure_reload;
-
-		/* enqueue the enc req */
-		*rx_enqueue = 1U;
 		break;
+#endif /* CONFIG_BT_PERIPHERAL */
 
+#if defined(CONFIG_BT_CENTRAL)
 	case PDU_DATA_LLCTRL_TYPE_ENC_RSP:
 		if (_radio.conn_curr->role ||
 		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_ENC_RSP,
@@ -2753,19 +2924,18 @@ isr_rx_conn_pkt_ctrl(struct radio_pdu_node_rx *node_rx,
 
 	case PDU_DATA_LLCTRL_TYPE_START_ENC_REQ:
 		if (_radio.conn_curr->role ||
-		    ((_radio.conn_curr->llcp_req !=
-		      _radio.conn_curr->llcp_ack) &&
-		     (_radio.conn_curr->llcp_type != LLCP_ENCRYPTION)) ||
+		    (_radio.conn_curr->llcp_req ==
+		      _radio.conn_curr->llcp_ack) ||
+		    (_radio.conn_curr->llcp_type != LLCP_ENCRYPTION) ||
 		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_START_ENC_REQ,
 				 pdu_data_rx->len)) {
 			goto isr_rx_conn_unknown_rsp_send;
 		}
 
 		/* start enc rsp to be scheduled in master prepare */
-		_radio.conn_curr->llcp.encryption.initiate = 0U;
-		_radio.conn_curr->llcp_type = LLCP_ENCRYPTION;
-		_radio.conn_curr->llcp_ack--;
+		_radio.conn_curr->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
 		break;
+#endif /* CONFIG_BT_CENTRAL */
 
 	case PDU_DATA_LLCTRL_TYPE_START_ENC_RSP:
 		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_START_ENC_RSP,
@@ -2782,7 +2952,8 @@ isr_rx_conn_pkt_ctrl(struct radio_pdu_node_rx *node_rx,
 			}
 
 			/* start enc rsp to be scheduled in slave  prepare */
-			_radio.conn_curr->llcp.encryption.initiate = 0U;
+			_radio.conn_curr->llcp.encryption.state =
+				LLCP_ENC_STATE_INPROG;
 			_radio.conn_curr->llcp_type = LLCP_ENCRYPTION;
 			_radio.conn_curr->llcp_ack--;
 #else /* CONFIG_BT_CTLR_FAST_ENC */
@@ -2816,6 +2987,7 @@ isr_rx_conn_pkt_ctrl(struct radio_pdu_node_rx *node_rx,
 		break;
 #endif /* CONFIG_BT_CTLR_LE_ENC */
 
+#if defined(CONFIG_BT_PERIPHERAL)
 	case PDU_DATA_LLCTRL_TYPE_FEATURE_REQ:
 		if (!_radio.conn_curr->role ||
 		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_FEATURE_REQ,
@@ -2825,7 +2997,9 @@ isr_rx_conn_pkt_ctrl(struct radio_pdu_node_rx *node_rx,
 
 		nack = feature_rsp_send(_radio.conn_curr, pdu_data_rx);
 		break;
+#endif /* CONFIG_BT_PERIPHERAL */
 
+#if defined(CONFIG_BT_CENTRAL)
 	case PDU_DATA_LLCTRL_TYPE_SLAVE_FEATURE_REQ:
 		if (_radio.conn_curr->role ||
 		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_SLAVE_FEATURE_REQ,
@@ -2835,6 +3009,7 @@ isr_rx_conn_pkt_ctrl(struct radio_pdu_node_rx *node_rx,
 
 		nack = feature_rsp_send(_radio.conn_curr, pdu_data_rx);
 		break;
+#endif /* CONFIG_BT_CENTRAL */
 
 	case PDU_DATA_LLCTRL_TYPE_FEATURE_RSP:
 	{
@@ -2865,6 +3040,7 @@ isr_rx_conn_pkt_ctrl(struct radio_pdu_node_rx *node_rx,
 	break;
 
 #if defined(CONFIG_BT_CTLR_LE_ENC)
+#if defined(CONFIG_BT_PERIPHERAL)
 	case PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_REQ:
 		if (!_radio.conn_curr->role ||
 		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_REQ,
@@ -2874,6 +3050,7 @@ isr_rx_conn_pkt_ctrl(struct radio_pdu_node_rx *node_rx,
 
 		nack = pause_enc_rsp_send(_radio.conn_curr, 1);
 		break;
+#endif /* CONFIG_BT_PERIPHERAL */
 
 	case PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_RSP:
 		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_RSP,
@@ -2902,16 +3079,7 @@ isr_rx_conn_pkt_ctrl(struct radio_pdu_node_rx *node_rx,
 			goto isr_rx_conn_unknown_rsp_send;
 		}
 
-		/* resume data packet rx and tx */
-		_radio.conn_curr->pause_rx = 0U;
-		_radio.conn_curr->pause_tx = 0U;
-
-		/* Procedure complete */
-		_radio.conn_curr->llcp_ack = _radio.conn_curr->llcp_req;
-		_radio.conn_curr->procedure_expire = 0U;
-
-		/* enqueue the reject ind */
-		*rx_enqueue = 1U;
+		isr_rx_conn_pkt_ctrl_rej_enc(node_rx, rx_enqueue);
 		break;
 #endif /* CONFIG_BT_CTLR_LE_ENC */
 
@@ -3440,6 +3608,7 @@ isr_rx_conn_pkt_ctrl(struct radio_pdu_node_rx *node_rx,
 		}
 		break;
 
+#if defined(CONFIG_BT_CENTRAL)
 	case PDU_DATA_LLCTRL_TYPE_PHY_RSP:
 		if (_radio.conn_curr->role ||
 		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_PHY_RSP,
@@ -3470,7 +3639,9 @@ isr_rx_conn_pkt_ctrl(struct radio_pdu_node_rx *node_rx,
 			_radio.conn_curr->procedure_expire = 0U;
 		}
 		break;
+#endif /* CONFIG_BT_CENTRAL */
 
+#if defined(CONFIG_BT_PERIPHERAL)
 	case PDU_DATA_LLCTRL_TYPE_PHY_UPD_IND:
 	{
 		u8_t err;
@@ -3487,6 +3658,7 @@ isr_rx_conn_pkt_ctrl(struct radio_pdu_node_rx *node_rx,
 		}
 	}
 	break;
+#endif /* CONFIG_BT_PERIPHERAL */
 #endif /* CONFIG_BT_CTLR_PHY */
 
 #if defined(CONFIG_BT_CTLR_MIN_USED_CHAN)
@@ -3559,12 +3731,6 @@ static inline bool isr_rx_conn_enc_unexpected(struct connection *conn,
 		  (opcode != PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND)))) ||
 	       (conn->role &&
 		((!conn->refresh &&
-		  /* As a workaround to IOP with some old peer controllers that
-		   * respond with Unknown Rsp PDU to our local Slave Initiated
-		   * Feature request during Encryption Setup initiated by the
-		   * peer, we accept this Unknown Rsp PDU during the Encryption
-		   * setup procedure in progress.
-		   */
 		  (opcode != PDU_DATA_LLCTRL_TYPE_UNKNOWN_RSP) &&
 		  (opcode != PDU_DATA_LLCTRL_TYPE_TERMINATE_IND) &&
 		  (opcode != PDU_DATA_LLCTRL_TYPE_START_ENC_RSP) &&
@@ -3590,6 +3756,7 @@ isr_rx_conn_pkt(struct radio_pdu_node_rx *node_rx,
 	/* Ack for transmitted data */
 	pdu_data_rx = (void *)node_rx->pdu_data;
 	if (pdu_data_rx->nesn != _radio.conn_curr->sn) {
+		struct radio_pdu_node_tx *node_tx;
 
 		/* Increment serial number */
 		_radio.conn_curr->sn++;
@@ -3601,11 +3768,17 @@ isr_rx_conn_pkt(struct radio_pdu_node_rx *node_rx,
 			_radio.conn_curr->slave.latency_enabled = 1U;
 		}
 
-		if (_radio.conn_curr->empty == 0) {
-			struct radio_pdu_node_tx *node_tx;
+		if (!_radio.conn_curr->empty) {
+			node_tx = _radio.conn_curr->pkt_tx_head;
+		} else {
+			_radio.conn_curr->empty = 0U;
+			node_tx = NULL;
+		}
+
+		if (node_tx) {
 			u8_t pdu_data_tx_len;
+			u8_t offset;
 
-			node_tx = _radio.conn_curr->pkt_tx_head;
 			pdu_data_tx = (void *)(node_tx->pdu_data +
 				_radio.conn_curr->packet_tx_head_offset);
 
@@ -3623,13 +3796,15 @@ isr_rx_conn_pkt(struct radio_pdu_node_rx *node_rx,
 				}
 			}
 
-			_radio.conn_curr->packet_tx_head_offset += pdu_data_tx_len;
-			if (_radio.conn_curr->packet_tx_head_offset ==
-			    _radio.conn_curr->packet_tx_head_len) {
+			offset = _radio.conn_curr->packet_tx_head_offset +
+				 pdu_data_tx_len;
+			if (offset < _radio.conn_curr->packet_tx_head_len) {
+				_radio.conn_curr->packet_tx_head_offset =
+					offset;
+			} else if (offset ==
+				   _radio.conn_curr->packet_tx_head_len) {
 				*tx_release = isr_rx_conn_pkt_release(node_tx);
 			}
-		} else {
-			_radio.conn_curr->empty = 0U;
 		}
 #if defined(CONFIG_BT_CTLR_TX_RETRY_DISABLE)
 	} else if (_radio.packet_counter != 1) {
@@ -4716,9 +4891,10 @@ static inline void isr_close_conn(void)
 #endif /* CONFIG_BT_CTLR_CONN_RSSI */
 
 	/* break latency based on ctrl procedure pending */
-	if ((_radio.conn_curr->llcp_ack != _radio.conn_curr->llcp_req) &&
-	    ((_radio.conn_curr->llcp_type == LLCP_CONN_UPD) ||
-	     (_radio.conn_curr->llcp_type == LLCP_CHAN_MAP))) {
+	if (((_radio.conn_curr->llcp_ack != _radio.conn_curr->llcp_req) &&
+	     ((_radio.conn_curr->llcp_type == LLCP_CONN_UPD) ||
+	      (_radio.conn_curr->llcp_type == LLCP_CHAN_MAP))) ||
+	    (_radio.conn_curr->llcp_cu.req != _radio.conn_curr->llcp_cu.ack)) {
 		_radio.conn_curr->latency_event = 0U;
 	}
 
@@ -4875,7 +5051,9 @@ static inline void isr_radio_state_close(void)
 		DEBUG_RADIO_XTAL(0);
 	}
 
+#if (RADIO_TICKER_USER_ID_WORKER_PRIO == RADIO_TICKER_USER_ID_JOB_PRIO)
 	mayfly_enable(RADIO_TICKER_USER_ID_WORKER, RADIO_TICKER_USER_ID_JOB, 1);
+#endif
 
 	DEBUG_RADIO_CLOSE(0);
 }
@@ -5726,8 +5904,11 @@ static void sched_free_win_offset_calc(struct connection *conn_curr,
 		ticks_slot_abs = ticks_prepare_to_start;
 	}
 
-	ticks_slot_abs += conn_curr->hdr.ticks_slot +
-			  HAL_TICKER_US_TO_TICKS(RADIO_TIES_US + 1250);
+	ticks_slot_abs += conn_curr->hdr.ticks_slot;
+
+	if (conn_curr->role) {
+		ticks_slot_abs += HAL_TICKER_US_TO_TICKS(RADIO_TIES_US);
+	}
 
 	ticker_id = ticker_id_prev = ticker_id_other = 0xFF;
 	ticks_to_expire = ticks_to_expire_prev = ticks_anchor =
@@ -5794,6 +5975,7 @@ static void sched_free_win_offset_calc(struct connection *conn_curr,
 		if ((conn != conn_curr) && (is_select || !conn->role)) {
 			u32_t ticks_to_expire_normal =
 				ticks_to_expire + ticks_prepare_reduced;
+			u32_t ticks_slot_margin = 0U;
 			u32_t ticks_slot_abs_curr;
 
 #if defined(CONFIG_BT_CTLR_XTAL_ADVANCED)
@@ -5818,12 +6000,18 @@ static void sched_free_win_offset_calc(struct connection *conn_curr,
 				ticks_slot_abs_curr = ticks_prepare_to_start;
 			}
 
-			ticks_slot_abs_curr +=
-				conn->hdr.ticks_slot +
-				HAL_TICKER_US_TO_TICKS(RADIO_TIES_US + 1250);
+			ticks_slot_abs_curr += conn->hdr.ticks_slot +
+					       HAL_TICKER_US_TO_TICKS(1250);
+
+			if (conn->role) {
+				ticks_slot_margin =
+					HAL_TICKER_US_TO_TICKS(RADIO_TIES_US);
+				ticks_slot_abs_curr += ticks_slot_margin;
+			}
 
 			if (*ticks_to_offset_next < ticks_to_expire_normal) {
-				if (ticks_to_expire_prev < *ticks_to_offset_next) {
+				if (ticks_to_expire_prev <
+				    *ticks_to_offset_next) {
 					ticks_to_expire_prev =
 						*ticks_to_offset_next;
 				}
@@ -5832,8 +6020,8 @@ static void sched_free_win_offset_calc(struct connection *conn_curr,
 				       (ticker_ticks_diff_get(
 							ticks_to_expire_normal,
 							ticks_to_expire_prev) >=
-					(ticks_slot_abs_prev +
-					 ticks_slot_abs))) {
+					(ticks_slot_abs_prev + ticks_slot_abs +
+					 ticks_slot_margin))) {
 					_win_offset = HAL_TICKER_TICKS_TO_US(
 						ticks_to_expire_prev +
 						ticks_slot_abs_prev) / 1250;
@@ -6704,18 +6892,16 @@ static void event_adv(u32_t ticks_at_expire, u32_t remainder,
 #endif /* CONFIG_BT_HCI_MESH_EXT */
 
 
-#if defined(CONFIG_BT_CTLR_PRIVACY)
-	if (ctrl_rl_enabled()) {
+	/* Setup Radio Filter */
+	if (IS_ENABLED(CONFIG_BT_CTLR_PRIVACY) && ctrl_rl_enabled()) {
 		struct ll_filter *filter =
 			ctrl_filter_get(!!(_radio.advertiser.filter_policy));
 
 		radio_filter_configure(filter->enable_bitmask,
 				       filter->addr_type_bitmask,
 				       (u8_t *)filter->bdaddr);
-	} else
-#endif /* CONFIG_BT_CTLR_PRIVACY */
-	/* Setup Radio Filter */
-	if (_radio.advertiser.filter_policy) {
+	} else if (IS_ENABLED(CONFIG_BT_CTLR_FILTER) &&
+		   _radio.advertiser.filter_policy) {
 
 		struct ll_filter *wl = ctrl_filter_get(true);
 
@@ -6751,9 +6937,9 @@ static void event_adv(u32_t ticks_at_expire, u32_t remainder,
 	} else
 #endif /* CONFIG_BT_CTLR_XTAL_ADVANCED */
 
-	{
-	/* Ticker Job Silence */
 #if (RADIO_TICKER_USER_ID_WORKER_PRIO == RADIO_TICKER_USER_ID_JOB_PRIO)
+	/* Ticker Job Silence */
+	{
 		u32_t ticker_status;
 
 		ticker_status =
@@ -6762,8 +6948,8 @@ static void event_adv(u32_t ticks_at_expire, u32_t remainder,
 					ticker_job_disable, NULL);
 		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
 			  (ticker_status == TICKER_STATUS_BUSY));
-#endif
 	}
+#endif
 
 	DEBUG_RADIO_START_A(0);
 }
@@ -6815,8 +7001,10 @@ static inline void ticker_stop_adv_stop_active(void)
 			  ticker_if_done, (void *)&ret_cb_evt);
 
 	if (ret == TICKER_STATUS_BUSY) {
+#if (RADIO_TICKER_USER_ID_WORKER_PRIO == RADIO_TICKER_USER_ID_JOB_PRIO)
 		mayfly_enable(RADIO_TICKER_USER_ID_JOB,
 			      RADIO_TICKER_USER_ID_JOB, 1);
+#endif
 
 		while (ret_cb_evt == TICKER_STATUS_BUSY) {
 			ticker_job_sched(RADIO_TICKER_INSTANCE_ID_RADIO,
@@ -6843,8 +7031,10 @@ static inline void ticker_stop_adv_stop_active(void)
 				  ticker_if_done, (void *)&ret_cb_m0);
 
 		if (ret == TICKER_STATUS_BUSY) {
+#if (RADIO_TICKER_USER_ID_WORKER_PRIO == RADIO_TICKER_USER_ID_JOB_PRIO)
 			mayfly_enable(RADIO_TICKER_USER_ID_JOB,
 				      RADIO_TICKER_USER_ID_JOB, 1);
+#endif
 
 			while (ret_cb_m0 == TICKER_STATUS_BUSY) {
 				ticker_job_sched(RADIO_TICKER_INSTANCE_ID_RADIO,
@@ -7115,8 +7305,8 @@ static void event_scan(u32_t ticks_at_expire, u32_t remainder, u16_t lazy,
 	radio_pkt_rx_set(_radio.packet_rx[_radio.packet_rx_last]->pdu_data);
 	radio_rssi_measure();
 
-#if defined(CONFIG_BT_CTLR_PRIVACY)
-	if (ctrl_rl_enabled()) {
+	/* Setup Radio Filter */
+	if (IS_ENABLED(CONFIG_BT_CTLR_PRIVACY) && ctrl_rl_enabled()) {
 		struct ll_filter *filter =
 			ctrl_filter_get(!!(_radio.scanner.filter_policy & 0x1));
 		u8_t count, *irks = ctrl_irks_get(&count);
@@ -7126,11 +7316,8 @@ static void event_scan(u32_t ticks_at_expire, u32_t remainder, u16_t lazy,
 				       (u8_t *)filter->bdaddr);
 
 		radio_ar_configure(count, irks);
-	} else
-#endif /* CONFIG_BT_CTLR_PRIVACY */
-	/* Setup Radio Filter */
-	if (_radio.scanner.filter_policy) {
-
+	} else if (IS_ENABLED(CONFIG_BT_CTLR_FILTER) &&
+		   _radio.scanner.filter_policy) {
 		struct ll_filter *wl = ctrl_filter_get(true);
 
 		radio_filter_configure(wl->enable_bitmask,
@@ -7183,8 +7370,8 @@ static void event_scan(u32_t ticks_at_expire, u32_t remainder, u16_t lazy,
 		LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
 			  (ret == TICKER_STATUS_BUSY));
 
-		/* Ticker Job Silence */
 #if (RADIO_TICKER_USER_ID_WORKER_PRIO == RADIO_TICKER_USER_ID_JOB_PRIO)
+		/* Ticker Job Silence */
 		ret = ticker_job_idle_get(RADIO_TICKER_INSTANCE_ID_RADIO,
 					  RADIO_TICKER_USER_ID_WORKER,
 					  ticker_job_disable, NULL);
@@ -7329,7 +7516,6 @@ static inline u32_t event_conn_upd_prep(struct connection *conn,
 	} else if (instant_latency <= 0x7FFF) {
 		struct radio_le_conn_update_cmplt *radio_le_conn_update_cmplt;
 		struct radio_pdu_node_rx *node_rx;
-		u32_t mayfly_was_enabled;
 		u16_t conn_interval_old;
 		u16_t conn_interval_new;
 		u32_t ticks_slot_offset;
@@ -7353,10 +7539,6 @@ static inline u32_t event_conn_upd_prep(struct connection *conn,
 			conn->procedure_expire = 0U;
 		}
 #endif /* CONFIG_BT_CTLR_CONN_PARAM_REQ */
-		/* Reset ticker_id_prepare as role is not continued further
-		 * due to conn update at this event.
-		 */
-		_radio.ticker_id_prepare = 0U;
 
 		/* reset mutex */
 		if (_radio.conn_upd == conn) {
@@ -7494,14 +7676,16 @@ static inline u32_t event_conn_upd_prep(struct connection *conn,
 			conn->supervision_expire = 0U;
 		}
 
+#if (RADIO_TICKER_USER_ID_WORKER_PRIO == RADIO_TICKER_USER_ID_JOB_PRIO)
 		/* disable ticker job, in order to chain stop and start
 		 * to avoid RTC being stopped if no tickers active.
 		 */
-		mayfly_was_enabled =
+		u32_t mayfly_was_enabled =
 			mayfly_is_enabled(RADIO_TICKER_USER_ID_WORKER,
 					  RADIO_TICKER_USER_ID_JOB);
 		mayfly_enable(RADIO_TICKER_USER_ID_WORKER,
 			      RADIO_TICKER_USER_ID_JOB, 0);
+#endif
 
 		/* start slave/master with new timings */
 		ticker_id = RADIO_TICKER_ID_FIRST_CONNECTION + conn->handle;
@@ -7533,11 +7717,13 @@ static inline u32_t event_conn_upd_prep(struct connection *conn,
 		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
 			  (ticker_status == TICKER_STATUS_BUSY));
 
+#if (RADIO_TICKER_USER_ID_WORKER_PRIO == RADIO_TICKER_USER_ID_JOB_PRIO)
 		/* enable ticker job, if disabled in this function */
 		if (mayfly_was_enabled) {
 			mayfly_enable(RADIO_TICKER_USER_ID_WORKER,
 				      RADIO_TICKER_USER_ID_JOB, 1);
 		}
+#endif
 
 		return 0;
 	}
@@ -7635,7 +7821,54 @@ static inline void event_enc_prep(struct connection *conn)
 	struct radio_pdu_node_tx *node_tx;
 	struct pdu_data *pdu_ctrl_tx;
 
-	if (conn->llcp.encryption.initiate) {
+	if (conn->llcp.encryption.state) {
+#if !defined(CONFIG_BT_CTLR_FAST_ENC) && defined(CONFIG_BT_PERIPHERAL)
+		if (conn->role &&
+		    (conn->llcp.encryption.state == LLCP_ENC_STATE_INIT)) {
+			struct radio_pdu_node_rx *node_rx;
+			struct pdu_data *pdu_ctrl_rx;
+			u8_t err;
+
+			/* TODO BT Spec. text: may finalize the sending
+			 * of additional data channel PDUs queued in the
+			 * controller.
+			 */
+			err = enc_rsp_send(conn);
+			if (err) {
+				return;
+			}
+
+			/* Prepare the rx packet structure */
+			node_rx = packet_rx_reserve_get(2);
+			LL_ASSERT(node_rx);
+
+			node_rx->hdr.handle = conn->handle;
+			node_rx->hdr.type = NODE_RX_TYPE_DC_PDU;
+
+			/* prepare enc req structure */
+			pdu_ctrl_rx = (void *)node_rx->pdu_data;
+			pdu_ctrl_rx->ll_id = PDU_DATA_LLID_CTRL;
+			pdu_ctrl_rx->len =
+				offsetof(struct pdu_data_llctrl, enc_req) +
+				sizeof(struct pdu_data_llctrl_enc_req);
+			pdu_ctrl_rx->llctrl.opcode =
+				PDU_DATA_LLCTRL_TYPE_ENC_REQ;
+			memcpy(&pdu_ctrl_rx->llctrl.enc_req.rand[0],
+			       &conn->llcp_enc.rand[0],
+			       sizeof(pdu_ctrl_rx->llctrl.enc_req.rand));
+			pdu_ctrl_rx->llctrl.enc_req.ediv[0] =
+				conn->llcp_enc.ediv[0];
+			pdu_ctrl_rx->llctrl.enc_req.ediv[1] =
+				conn->llcp_enc.ediv[1];
+
+			/* enqueue enc req structure into rx queue */
+			packet_rx_enqueue();
+
+			/* Wait for LTK reply */
+			conn->llcp.encryption.state = LLCP_ENC_STATE_LTK_WAIT;
+		}
+#endif /* !CONFIG_BT_CTLR_FAST_ENC && CONFIG_BT_PERIPHERAL */
+
 		return;
 	}
 
@@ -7683,7 +7916,7 @@ static inline void event_enc_prep(struct connection *conn)
 #if defined(CONFIG_BT_CTLR_FAST_ENC)
 	else {
 #else /* !CONFIG_BT_CTLR_FAST_ENC */
-	else if (!conn->pause_tx || conn->refresh) {
+	else if (!conn->enc_rx) {
 #endif /* !CONFIG_BT_CTLR_FAST_ENC */
 
 		/* place the reject ind packet as next in tx queue */
@@ -7692,22 +7925,6 @@ static inline void event_enc_prep(struct connection *conn)
 		}
 		/* place the start enc req packet as next in tx queue */
 		else {
-
-#if !defined(CONFIG_BT_CTLR_FAST_ENC)
-			u8_t err;
-
-			/* TODO BT Spec. text: may finalize the sending
-			 * of additional data channel PDUs queued in the
-			 * controller.
-			 */
-			err = enc_rsp_send(conn);
-			if (err) {
-				mem_release(node_tx, &_radio.pkt_tx_ctrl_free);
-
-				return;
-			}
-#endif /* !CONFIG_BT_CTLR_FAST_ENC */
-
 			/* calc the Session Key */
 			ecb_encrypt(&conn->llcp_enc.ltk[0],
 				    &conn->llcp.encryption.skd[0], NULL,
@@ -8268,49 +8485,7 @@ static inline int event_len_prep(struct connection *conn)
 		lr->max_rx_octets = LL_LENGTH_OCTETS_RX_MAX;
 		lr->max_tx_octets = conn->default_tx_octets;
 
-		if (!conn->common.fex_valid ||
-#if defined(CONFIG_BT_CTLR_PHY)
-		     (
-#if defined(CONFIG_BT_CTLR_PHY_CODED)
-		      !(conn->llcp_feature.features &
-			BIT(BT_LE_FEAT_BIT_PHY_CODED)) &&
-#endif /* CONFIG_BT_CTLR_PHY_CODED */
-
-#if defined(CONFIG_BT_CTLR_PHY_2M)
-		      !(conn->llcp_feature.features &
-			BIT(BT_LE_FEAT_BIT_PHY_2M)) &&
-#endif /* CONFIG_BT_CTLR_PHY_2M */
-		      1)
-#else /* !CONFIG_BT_CTLR_PHY */
-		    0
-#endif /* !CONFIG_BT_CTLR_PHY */
-		   ) {
-			lr->max_rx_time =
-				RADIO_PKT_TIME(LL_LENGTH_OCTETS_RX_MAX, 0);
-			lr->max_tx_time =
-				RADIO_PKT_TIME(conn->default_tx_octets, 0);
-#if defined(CONFIG_BT_CTLR_PHY)
-#if defined(CONFIG_BT_CTLR_PHY_CODED)
-		} else if (conn->llcp_feature.features &
-			   BIT(BT_LE_FEAT_BIT_PHY_CODED)) {
-			lr->max_rx_time =
-				RADIO_PKT_TIME(LL_LENGTH_OCTETS_RX_MAX, BIT(2));
-			lr->max_tx_time = conn->default_tx_time;
-#endif /* CONFIG_BT_CTLR_PHY_CODED */
-
-#if defined(CONFIG_BT_CTLR_PHY_2M)
-		} else if (conn->llcp_feature.features &
-			   BIT(BT_LE_FEAT_BIT_PHY_2M)) {
-			lr->max_rx_time =
-				RADIO_PKT_TIME(LL_LENGTH_OCTETS_RX_MAX, BIT(1));
-			if (conn->default_tx_time > lr->max_rx_time) {
-				lr->max_tx_time = lr->max_rx_time;
-			} else {
-				lr->max_tx_time = conn->default_tx_time;
-			}
-#endif /* CONFIG_BT_CTLR_PHY_2M */
-#endif /* CONFIG_BT_CTLR_PHY */
-		}
+		dle_max_time_get(conn, &lr->max_rx_time, &lr->max_tx_time);
 
 		ctrl_tx_enqueue(conn, node_tx);
 
@@ -8706,52 +8881,44 @@ static inline void event_phy_upd_ind_prep(struct connection *conn,
 #if defined(CONFIG_BT_CTLR_DATA_LENGTH)
 		u16_t eff_tx_time = conn->max_tx_time;
 		u16_t eff_rx_time = conn->max_rx_time;
+		u16_t max_rx_time, max_tx_time;
+
+		dle_max_time_get(conn, &max_rx_time, &max_tx_time);
 #endif /* CONFIG_BT_CTLR_DATA_LENGTH */
 
 		if (conn->llcp.phy_upd_ind.tx) {
 			conn->phy_tx = conn->llcp.phy_upd_ind.tx;
 
 #if defined(CONFIG_BT_CTLR_DATA_LENGTH)
-			u16_t tx_time = RADIO_PKT_TIME(conn->max_tx_octets,
-						       conn->phy_tx);
-			if (tx_time >=
-			    RADIO_PKT_TIME(PDU_DC_PAYLOAD_SIZE_MIN, 0)) {
-				eff_tx_time = MIN(tx_time,
-						  conn->default_tx_time);
+			eff_tx_time =
+				MAX(RADIO_PKT_TIME(conn->max_tx_octets,
+						   conn->phy_tx),
+				    RADIO_PKT_TIME(PDU_DC_PAYLOAD_SIZE_MIN, 0));
+			eff_tx_time = MIN(eff_tx_time, max_tx_time);
+
 #if defined(CONFIG_BT_CTLR_PHY_CODED)
-				eff_tx_time = MAX(eff_tx_time,
-					RADIO_PKT_TIME(PDU_DC_PAYLOAD_SIZE_MIN,
-						       conn->phy_tx));
+			eff_tx_time = MAX(eff_tx_time,
+				RADIO_PKT_TIME(PDU_DC_PAYLOAD_SIZE_MIN,
+					       conn->phy_tx));
 #endif /* CONFIG_BT_CTLR_PHY_CODED */
-			} else {
-				eff_tx_time =
-					RADIO_PKT_TIME(PDU_DC_PAYLOAD_SIZE_MIN,
-						       0);
-			}
 #endif /* CONFIG_BT_CTLR_DATA_LENGTH */
 		}
 
 		if (conn->llcp.phy_upd_ind.rx) {
 			conn->phy_rx = conn->llcp.phy_upd_ind.rx;
 
 #if defined(CONFIG_BT_CTLR_DATA_LENGTH)
-			u16_t rx_time = RADIO_PKT_TIME(conn->max_rx_octets,
-						       conn->phy_rx);
-			if (rx_time >=
-			    RADIO_PKT_TIME(PDU_DC_PAYLOAD_SIZE_MIN, 0)) {
-				eff_rx_time = MIN(rx_time,
-					RADIO_PKT_TIME(LL_LENGTH_OCTETS_RX_MAX,
-						       BIT(2)));
+			eff_rx_time =
+				MAX(RADIO_PKT_TIME(conn->max_rx_octets,
+						   conn->phy_rx),
+				    RADIO_PKT_TIME(PDU_DC_PAYLOAD_SIZE_MIN, 0));
+			eff_rx_time = MIN(eff_rx_time, max_rx_time);
+
 #if defined(CONFIG_BT_CTLR_PHY_CODED)
-				eff_rx_time = MAX(eff_rx_time,
-					RADIO_PKT_TIME(PDU_DC_PAYLOAD_SIZE_MIN,
-						       conn->phy_rx));
+			eff_rx_time = MAX(eff_rx_time,
+				RADIO_PKT_TIME(PDU_DC_PAYLOAD_SIZE_MIN,
+					       conn->phy_rx));
 #endif /* CONFIG_BT_CTLR_PHY_CODED */
-			} else {
-				eff_rx_time =
-					RADIO_PKT_TIME(PDU_DC_PAYLOAD_SIZE_MIN,
-						       0);
-			}
 #endif /* CONFIG_BT_CTLR_DATA_LENGTH */
 		}
 		conn->phy_flags = conn->phy_pref_flags;
@@ -8788,7 +8955,9 @@ static inline void event_phy_upd_ind_prep(struct connection *conn,
 #if defined(CONFIG_BT_CTLR_DATA_LENGTH)
 		/* Update max tx and/or max rx if changed */
 		if ((eff_tx_time <= conn->max_tx_time) &&
-		    (eff_rx_time <= conn->max_rx_time)) {
+		    (conn->max_tx_time <= max_tx_time) &&
+		    (eff_rx_time <= conn->max_rx_time) &&
+		    (conn->max_rx_time <= max_rx_time)) {
 			return;
 		}
 		conn->max_tx_time = eff_tx_time;
@@ -8936,17 +9105,49 @@ static void event_connection_prepare(u32_t ticks_at_expire,
 		}
 	}
 
-	/* check if procedure is requested */
+	/* Check if procedures with instant or encryption setup is requested or
+	 * active.
+	 */
 	if (conn->llcp_ack != conn->llcp_req) {
 		/* Stop previous event, to avoid Radio DMA corrupting the
 		 * rx queue
 		 */
 		event_stop(0, 0, 0, (void *)STATE_ABORT);
 
+		/* Process parallel procedures that are active */
+		if (0) {
+#if defined(CONFIG_BT_CTLR_DATA_LENGTH)
+		/* Check if DLE in progress */
+		} else if (conn->llcp_length.ack != conn->llcp_length.req) {
+			if ((conn->llcp_length.state ==
+			     LLCP_LENGTH_STATE_RESIZE) ||
+			    (conn->llcp_length.state ==
+			     LLCP_LENGTH_STATE_RESIZE_RSP)) {
+				/* handle DLU state machine */
+				if (event_len_prep(conn)) {
+					/* NOTE: rx pool could not be resized,
+					 * lets skip this event and try in the
+					 * next event.
+					 */
+					_radio.ticker_id_prepare = 0U;
+
+					goto event_connection_prepare_skip;
+				}
+			}
+#endif /* CONFIG_BT_CTLR_DATA_LENGTH */
+		}
+
+		/* Process procedures with instants or encryption setup */
+		/* FIXME: Make LE Ping cacheable */
 		switch (conn->llcp_type) {
 		case LLCP_CONN_UPD:
-			if (event_conn_upd_prep(conn, event_counter,
-						ticks_at_expire) == 0) {
+			if (!event_conn_upd_prep(conn, event_counter,
+						 ticks_at_expire)) {
+				/* Reset ticker_id_prepare as role is not
+				 * continued further due to conn update at
+				 * this event.
+				 */
+				_radio.ticker_id_prepare = 0U;
 				return;
 			}
 			break;
@@ -9203,9 +9404,9 @@ static void event_slave(u32_t ticks_at_expire, u32_t remainder, u16_t lazy,
 	} else
 #endif /* CONFIG_BT_CTLR_XTAL_ADVANCED */
 
-	{
-	/* Ticker Job Silence */
 #if (RADIO_TICKER_USER_ID_WORKER_PRIO == RADIO_TICKER_USER_ID_JOB_PRIO)
+	/* Ticker Job Silence */
+	{
 		u32_t ticker_status;
 
 		ticker_status =
@@ -9214,8 +9415,8 @@ static void event_slave(u32_t ticks_at_expire, u32_t remainder, u16_t lazy,
 					    ticker_job_disable, NULL);
 		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
 			  (ticker_status == TICKER_STATUS_BUSY));
-#endif
 	}
+#endif
 
 	/* Route the tx packet to respective connections */
 	packet_tx_enqueue(2);
@@ -9414,9 +9615,9 @@ static void event_master(u32_t ticks_at_expire, u32_t remainder, u16_t lazy,
 	} else
 #endif /* CONFIG_BT_CTLR_XTAL_ADVANCED */
 
-	{
-	/* Ticker Job Silence */
 #if (RADIO_TICKER_USER_ID_WORKER_PRIO == RADIO_TICKER_USER_ID_JOB_PRIO)
+	/* Ticker Job Silence */
+	{
 		u32_t ticker_status;
 
 		ticker_status =
@@ -9425,8 +9626,8 @@ static void event_master(u32_t ticks_at_expire, u32_t remainder, u16_t lazy,
 					    ticker_job_disable, NULL);
 		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
 			  (ticker_status == TICKER_STATUS_BUSY));
-#endif
 	}
+#endif
 
 	DEBUG_RADIO_START_M(0);
 }
@@ -9869,7 +10070,7 @@ static bool is_enc_req_pause_tx(struct connection *conn)
 		}
 
 		if (conn->llcp_req == conn->llcp_ack) {
-			conn->llcp.encryption.initiate = 1U;
+			conn->llcp.encryption.state = LLCP_ENC_STATE_INIT;
 
 			conn->llcp_type = LLCP_ENCRYPTION;
 			conn->llcp_ack--;
@@ -10114,6 +10315,9 @@ static void ctrl_tx_enqueue(struct connection *conn,
 static void ctrl_tx_sec_enqueue(struct connection *conn,
 				  struct radio_pdu_node_tx *node_tx)
 {
+	bool pause = false;
+
+#if defined(CONFIG_BT_CTLR_LE_ENC)
 	if (conn->pause_tx) {
 		if (!conn->pkt_tx_ctrl) {
 			/* As data PDU tx is paused and no control PDU in queue,
@@ -10139,8 +10343,6 @@ static void ctrl_tx_sec_enqueue(struct connection *conn,
 			conn->pkt_tx_last = node_tx;
 		}
 	} else {
-		bool pause = false;
-
 		/* check if Encryption Request is at head, it may have been
 		 * transmitted and not ack-ed. Hence, enqueue this control PDU
 		 * after control last marker and before data marker.
@@ -10150,13 +10352,21 @@ static void ctrl_tx_sec_enqueue(struct connection *conn,
 			struct pdu_data *pdu_data_tx;
 
 			pdu_data_tx = (void *)conn->pkt_tx_head->pdu_data;
-			if ((pdu_data_tx->ll_id == PDU_DATA_LLID_CTRL) &&
-			    (pdu_data_tx->llctrl.opcode ==
-			     PDU_DATA_LLCTRL_TYPE_ENC_REQ)) {
+			if ((conn->llcp_req != conn->llcp_ack) &&
+			    (conn->llcp_type == LLCP_ENCRYPTION) &&
+			    (pdu_data_tx->ll_id == PDU_DATA_LLID_CTRL) &&
+			    ((pdu_data_tx->llctrl.opcode ==
+			      PDU_DATA_LLCTRL_TYPE_ENC_REQ) ||
+			     (pdu_data_tx->llctrl.opcode ==
+			      PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_REQ))) {
 				pause = true;
 			}
 		}
 
+#else /* !CONFIG_BT_CTLR_LE_ENC */
+	{
+#endif /* !CONFIG_BT_CTLR_LE_ENC */
+
 		ctrl_tx_pause_enqueue(conn, node_tx, pause);
 	}
 }
@@ -10165,10 +10375,12 @@ static void connection_release(struct connection *conn)
 {
 	u32_t ticker_status;
 
+#if (RADIO_TICKER_USER_ID_WORKER_PRIO == RADIO_TICKER_USER_ID_JOB_PRIO)
 	/* Enable Ticker Job, we are in a radio event which disabled it if
 	 * worker0 and job0 priority where same.
 	 */
 	mayfly_enable(RADIO_TICKER_USER_ID_WORKER, RADIO_TICKER_USER_ID_JOB, 1);
+#endif
 
 	/** @todo correctly stop tickers ensuring crystal and radio active are
 	 * placed in right states
@@ -10290,6 +10502,7 @@ static void terminate_ind_rx_enqueue(struct connection *conn, u8_t reason)
 	packet_rx_callback();
 }
 
+#if defined(CONFIG_BT_PERIPHERAL)
 static u8_t conn_update(struct connection *conn, struct pdu_data *pdu_data_rx)
 {
 	if (((pdu_data_rx->llctrl.conn_update_ind.instant -
@@ -10332,6 +10545,7 @@ static u8_t conn_update(struct connection *conn, struct pdu_data *pdu_data_rx)
 
 	return 0;
 }
+#endif /* CONFIG_BT_PERIPHERAL */
 
 #if defined (CONFIG_BT_CTLR_XTAL_ADVANCED) && \
     defined(CONFIG_BT_CTLR_SCHED_ADVANCED)
@@ -10386,6 +10600,7 @@ static u32_t conn_update_req(struct connection *conn)
 }
 #endif /* CONFIG_BT_CTLR_XTAL_ADVANCED && CONFIG_BT_CTLR_SCHED_ADVANCED */
 
+#if defined(CONFIG_BT_PERIPHERAL)
 static u8_t chan_map_update(struct connection *conn,
 			    struct pdu_data *pdu_data_rx)
 {
@@ -10412,6 +10627,7 @@ static u8_t chan_map_update(struct connection *conn,
 
 	return 0;
 }
+#endif /* CONFIG_BT_PERIPHERAL */
 
 #if defined(CONFIG_BT_CTLR_PHY)
 static inline u8_t phy_upd_ind_recv(struct radio_pdu_node_rx *node_rx,
@@ -10530,6 +10746,7 @@ static void enc_req_reused_send(struct connection *conn,
 				sizeof(pdu_ctrl_tx->llctrl.enc_req.ivm), 0);
 }
 
+#if defined(CONFIG_BT_PERIPHERAL)
 static u8_t enc_rsp_send(struct connection *conn)
 {
 	struct radio_pdu_node_tx *node_tx;
@@ -10572,6 +10789,7 @@ static u8_t enc_rsp_send(struct connection *conn)
 
 	return 0;
 }
+#endif /* CONFIG_BT_PERIPHERAL */
 
 static u8_t start_enc_rsp_send(struct connection *conn,
 			       struct pdu_data *pdu_ctrl_tx)
@@ -10785,7 +11003,7 @@ static u8_t ping_resp_send(struct connection *conn)
 			   sizeof(struct pdu_data_llctrl_ping_rsp);
 	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PING_RSP;
 
-	ctrl_tx_enqueue(conn, node_tx);
+	ctrl_tx_sec_enqueue(conn, node_tx);
 
 	return 0;
 }
@@ -10850,7 +11068,7 @@ static void length_resp_send(struct connection *conn,
 	pdu_ctrl_tx->llctrl.length_rsp.max_tx_time = eff_tx_time;
 #endif /* CONFIG_BT_CTLR_PHY */
 
-	ctrl_tx_enqueue(conn, node_tx);
+	ctrl_tx_sec_enqueue(conn, node_tx);
 }
 #endif /* CONFIG_BT_CTLR_DATA_LENGTH */
 
@@ -10970,8 +11188,10 @@ static inline void role_active_disable(u8_t ticker_id_stop,
 			  ticker_if_done, (void *)&ret_cb_evt);
 
 	if (ret == TICKER_STATUS_BUSY) {
+#if (RADIO_TICKER_USER_ID_WORKER_PRIO == RADIO_TICKER_USER_ID_JOB_PRIO)
 		mayfly_enable(RADIO_TICKER_USER_ID_APP,
 			      RADIO_TICKER_USER_ID_JOB, 1);
+#endif
 
 		LL_ASSERT(ret_cb_evt != TICKER_STATUS_BUSY);
 	}
@@ -10995,8 +11215,10 @@ static inline void role_active_disable(u8_t ticker_id_stop,
 				  ticker_if_done, (void *)&ret_cb_m0);
 
 		if (ret == TICKER_STATUS_BUSY) {
+#if (RADIO_TICKER_USER_ID_WORKER_PRIO == RADIO_TICKER_USER_ID_JOB_PRIO)
 			mayfly_enable(RADIO_TICKER_USER_ID_APP,
 				      RADIO_TICKER_USER_ID_JOB, 1);
+#endif
 
 			LL_ASSERT(ret_cb_m0 != TICKER_STATUS_BUSY);
 		}
@@ -11089,8 +11311,10 @@ static inline void role_active_disable(u8_t ticker_id_stop,
 					  (void *)&ret_cb_stop);
 
 			if (ret == TICKER_STATUS_BUSY) {
+#if (RADIO_TICKER_USER_ID_WORKER_PRIO == RADIO_TICKER_USER_ID_JOB_PRIO)
 				mayfly_enable(RADIO_TICKER_USER_ID_APP,
 					      RADIO_TICKER_USER_ID_JOB, 1);
+#endif
 
 				LL_ASSERT(ret_cb_stop != TICKER_STATUS_BUSY);
 			}
@@ -11208,11 +11432,13 @@ static u8_t role_disable(u8_t ticker_id_primary, u8_t ticker_id_stop)
 			  ticker_if_done, (void *)&ret_cb);
 
 	if (ret == TICKER_STATUS_BUSY) {
+#if (RADIO_TICKER_USER_ID_WORKER_PRIO == RADIO_TICKER_USER_ID_JOB_PRIO)
 		/* if inside our event, enable Job. */
 		if (_radio.ticker_id_event == ticker_id_primary) {
 			mayfly_enable(RADIO_TICKER_USER_ID_APP,
 				      RADIO_TICKER_USER_ID_JOB, 1);
 		}
+#endif
 
 		/* wait for ticker to be stopped */
 		while (ret_cb == TICKER_STATUS_BUSY) {
@@ -12221,15 +12447,13 @@ u8_t ll_start_enc_req_send(u16_t handle, u8_t error_code,
 
 	if (error_code) {
 		if (conn->refresh == 0) {
-			if (conn->llcp_req != conn->llcp_ack) {
+			if ((conn->llcp_req == conn->llcp_ack) ||
+			     (conn->llcp_type != LLCP_ENCRYPTION)) {
 				return BT_HCI_ERR_CMD_DISALLOWED;
 			}
 
 			conn->llcp.encryption.error_code = error_code;
-			conn->llcp.encryption.initiate = 0U;
-
-			conn->llcp_type = LLCP_ENCRYPTION;
-			conn->llcp_req++;
+			conn->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
 		} else {
 			if (conn->llcp_terminate.ack !=
 			    conn->llcp_terminate.req) {
@@ -12241,18 +12465,16 @@ u8_t ll_start_enc_req_send(u16_t handle, u8_t error_code,
 			conn->llcp_terminate.req++;
 		}
 	} else {
-		if (conn->llcp_req != conn->llcp_ack) {
+		if ((conn->llcp_req == conn->llcp_ack) ||
+		     (conn->llcp_type != LLCP_ENCRYPTION)) {
 			return BT_HCI_ERR_CMD_DISALLOWED;
 		}
 
 		memcpy(&conn->llcp_enc.ltk[0], ltk,
 		       sizeof(conn->llcp_enc.ltk));
 
 		conn->llcp.encryption.error_code = 0U;
-		conn->llcp.encryption.initiate = 0U;
-
-		conn->llcp_type = LLCP_ENCRYPTION;
-		conn->llcp_req++;
+		conn->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
 	}
 
 	return 0;
@@ -12761,7 +12983,7 @@ void ll_rx_mem_release(void **node_rx)
 					break;
 				}
 			}
-			/* passthrough */
+			/* fall through */
 		case NODE_RX_TYPE_DC_PDU:
 #endif /* CONFIG_BT_CONN */
 
@@ -12810,6 +13032,13 @@ void ll_rx_mem_release(void **node_rx)
 		case NODE_RX_TYPE_MESH_REPORT:
 #endif /* CONFIG_BT_HCI_MESH_EXT */
 
+		/* fall through */
+
+		/* Ensure that at least one 'case' statement is present for this
+		 * code block.
+		 */
+		case NODE_RX_TYPE_NONE:
+			LL_ASSERT(_node_rx_free->hdr.type != NODE_RX_TYPE_NONE);
 			mem_release(_node_rx_free,
 				    &_radio.pkt_rx_data_free);
 			break;