@@ -6,15 +6,19 @@ import (
 
 	"github.com/dgrijalva/jwt-go"
 	"github.com/stretchr/testify/assert"
+	"google.golang.org/grpc/codes"
+	"google.golang.org/grpc/status"
 	v1 "k8s.io/api/core/v1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/client-go/kubernetes/fake"
 
+	"github.com/argoproj/argo-cd/common"
 	"github.com/argoproj/argo-cd/errors"
 	"github.com/argoproj/argo-cd/pkg/apiclient/account"
 	sessionpkg "github.com/argoproj/argo-cd/pkg/apiclient/session"
 	"github.com/argoproj/argo-cd/server/session"
 	"github.com/argoproj/argo-cd/util/password"
+	"github.com/argoproj/argo-cd/util/rbac"
 	sessionutil "github.com/argoproj/argo-cd/util/session"
 	"github.com/argoproj/argo-cd/util/settings"
 )
@@ -24,18 +28,20 @@ const (
 )
 
 // return an AccountServer which returns fake data
-func newTestAccountServer(ctx context.Context) (*fake.Clientset, *Server, *session.Server) {
+func newTestAccountServer(ctx context.Context, opts ...func(cm *v1.ConfigMap, secret *v1.Secret)) (*Server, *session.Server) {
 	bcrypt, err := password.HashPassword("oldpassword")
 	errors.CheckError(err)
-	kubeclientset := fake.NewSimpleClientset(&v1.ConfigMap{
+	cm := &v1.ConfigMap{
 		ObjectMeta: metav1.ObjectMeta{
 			Name:      "argocd-cm",
 			Namespace: testNamespace,
 			Labels: map[string]string{
 				"app.kubernetes.io/part-of": "argocd",
 			},
 		},
-	}, &v1.Secret{
+		Data: map[string]string{},
+	}
+	secret := &v1.Secret{
 		ObjectMeta: metav1.ObjectMeta{
 			Name:      "argocd-secret",
 			Namespace: testNamespace,
@@ -44,16 +50,37 @@ func newTestAccountServer(ctx context.Context) (*fake.Clientset, *Server, *sessi
 			"admin.password":   []byte(bcrypt),
 			"server.secretkey": []byte("test"),
 		},
-	})
+	}
+	for i := range opts {
+		opts[i](cm, secret)
+	}
+	kubeclientset := fake.NewSimpleClientset(cm, secret)
 	settingsMgr := settings.NewSettingsManager(ctx, kubeclientset, testNamespace)
-	sessionMgr := sessionutil.NewSessionManager(settingsMgr, "", false)
-	return kubeclientset, NewServer(sessionMgr, settingsMgr, nil), session.NewServer(sessionMgr, nil)
+	sessionMgr := sessionutil.NewSessionManager(settingsMgr, "")
+	enforcer := rbac.NewEnforcer(kubeclientset, testNamespace, common.ArgoCDRBACConfigMapName, nil)
+	enforcer.SetClaimsEnforcerFunc(func(claims jwt.Claims, rvals ...interface{}) bool {
+		return true
+	})
+
+	return NewServer(sessionMgr, settingsMgr, enforcer), session.NewServer(sessionMgr, nil)
+}
+
+func getAdminAccount(mgr *settings.SettingsManager) (*settings.Account, error) {
+	accounts, err := mgr.GetAccounts()
+	if err != nil {
+		return nil, err
+	}
+	adminAccount := accounts[common.ArgoCDAdminUsername]
+	return &adminAccount, nil
+}
+
+func adminContext(ctx context.Context) context.Context {
+	return context.WithValue(ctx, "claims", &jwt.StandardClaims{Subject: "admin", Issuer: sessionutil.SessionManagerClaimsIssuer})
 }
 
 func TestUpdatePassword(t *testing.T) {
-	ctx := context.Background()
-	_, accountServer, sessionServer := newTestAccountServer(ctx)
-	ctx = context.WithValue(ctx, "claims", &jwt.StandardClaims{Subject: "admin"})
+	accountServer, sessionServer := newTestAccountServer(context.Background())
+	ctx := adminContext(context.Background())
 	var err error
 
 	// ensure password is not allowed to be updated if given bad password
@@ -69,14 +96,14 @@ func TestUpdatePassword(t *testing.T) {
 	assert.Error(t, err)
 
 	// ensure password can be updated with valid password and immediately be used
-	settings, err := accountServer.settingsMgr.GetSettings()
+	adminAccount, err := getAdminAccount(accountServer.settingsMgr)
 	assert.NoError(t, err)
-	prevHash := settings.AdminPasswordHash
+	prevHash := adminAccount.PasswordHash
 	_, err = accountServer.UpdatePassword(ctx, &account.UpdatePasswordRequest{CurrentPassword: "oldpassword", NewPassword: "newpassword"})
 	assert.NoError(t, err)
-	settings, err = accountServer.settingsMgr.GetSettings()
+	adminAccount, err = getAdminAccount(accountServer.settingsMgr)
 	assert.NoError(t, err)
-	assert.NotEqual(t, prevHash, settings.AdminPasswordHash)
+	assert.NotEqual(t, prevHash, adminAccount.PasswordHash)
 	assert.NoError(t, accountServer.sessionMgr.VerifyUsernamePassword("admin", "newpassword"))
 	assert.Error(t, accountServer.sessionMgr.VerifyUsernamePassword("admin", "oldpassword"))
 	// verify old password is invalid
@@ -86,3 +113,91 @@ func TestUpdatePassword(t *testing.T) {
 	_, err = sessionServer.Create(ctx, &sessionpkg.SessionCreateRequest{Username: "admin", Password: "newpassword"})
 	assert.NoError(t, err)
 }
+
+func TestListAccounts_NoAccountsConfigured(t *testing.T) {
+	ctx := adminContext(context.Background())
+
+	accountServer, _ := newTestAccountServer(ctx)
+	resp, err := accountServer.ListAccounts(ctx, &account.ListAccountRequest{})
+	assert.NoError(t, err)
+	assert.Len(t, resp.Items, 1)
+}
+
+func TestListAccounts_AccountsAreConfigured(t *testing.T) {
+	ctx := adminContext(context.Background())
+	accountServer, _ := newTestAccountServer(ctx, func(cm *v1.ConfigMap, secret *v1.Secret) {
+		cm.Data["accounts.account1"] = "apiKey"
+		cm.Data["accounts.account2"] = "login, apiKey"
+		cm.Data["accounts.account2.enabled"] = "false"
+	})
+
+	resp, err := accountServer.ListAccounts(ctx, &account.ListAccountRequest{})
+	assert.NoError(t, err)
+	assert.Len(t, resp.Items, 3)
+	assert.ElementsMatch(t, []*account.Account{
+		{Name: "admin", Capabilities: []string{"login"}, Enabled: true},
+		{Name: "account1", Capabilities: []string{"apiKey"}, Enabled: true},
+		{Name: "account2", Capabilities: []string{"login", "apiKey"}, Enabled: false},
+	}, resp.Items)
+}
+
+func TestGetAccount(t *testing.T) {
+	ctx := adminContext(context.Background())
+	accountServer, _ := newTestAccountServer(ctx, func(cm *v1.ConfigMap, secret *v1.Secret) {
+		cm.Data["accounts.account1"] = "apiKey"
+	})
+
+	t.Run("ExistingAccount", func(t *testing.T) {
+		acc, err := accountServer.GetAccount(ctx, &account.GetAccountRequest{Name: "account1"})
+		assert.NoError(t, err)
+
+		assert.Equal(t, acc.Name, "account1")
+	})
+
+	t.Run("NonExistingAccount", func(t *testing.T) {
+		_, err := accountServer.GetAccount(ctx, &account.GetAccountRequest{Name: "bad-name"})
+		assert.Error(t, err)
+		assert.Equal(t, status.Code(err), codes.NotFound)
+	})
+}
+
+func TestCreateToken_SuccessfullyCreated(t *testing.T) {
+	ctx := adminContext(context.Background())
+	accountServer, _ := newTestAccountServer(ctx, func(cm *v1.ConfigMap, secret *v1.Secret) {
+		cm.Data["accounts.account1"] = "apiKey"
+	})
+
+	_, err := accountServer.CreateToken(ctx, &account.CreateTokenRequest{Name: "account1"})
+	assert.NoError(t, err)
+
+	acc, err := accountServer.GetAccount(ctx, &account.GetAccountRequest{Name: "account1"})
+	assert.NoError(t, err)
+
+	assert.Len(t, acc.Tokens, 1)
+}
+
+func TestCreateToken_DoesNotHaveCapability(t *testing.T) {
+	ctx := adminContext(context.Background())
+	accountServer, _ := newTestAccountServer(ctx, func(cm *v1.ConfigMap, secret *v1.Secret) {
+		cm.Data["accounts.account1"] = "login"
+	})
+
+	_, err := accountServer.CreateToken(ctx, &account.CreateTokenRequest{Name: "account1"})
+	assert.Error(t, err)
+}
+
+func TestDeleteToken_SuccessfullyRemoved(t *testing.T) {
+	ctx := adminContext(context.Background())
+	accountServer, _ := newTestAccountServer(ctx, func(cm *v1.ConfigMap, secret *v1.Secret) {
+		cm.Data["accounts.account1"] = "apiKey"
+		secret.Data["accounts.account1.tokens"] = []byte(`[{"id":"123","iat":1583789194,"exp":1583789194}]`)
+	})
+
+	_, err := accountServer.DeleteToken(ctx, &account.DeleteTokenRequest{Name: "account1", Id: "123"})
+	assert.NoError(t, err)
+
+	acc, err := accountServer.GetAccount(ctx, &account.GetAccountRequest{Name: "account1"})
+	assert.NoError(t, err)
+
+	assert.Len(t, acc.Tokens, 0)
+}
