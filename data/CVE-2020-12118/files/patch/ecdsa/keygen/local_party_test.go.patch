@@ -22,6 +22,7 @@ import (
 
 	"github.com/binance-chain/tss-lib/common"
 	"github.com/binance-chain/tss-lib/crypto"
+	"github.com/binance-chain/tss-lib/crypto/dlnproof"
 	"github.com/binance-chain/tss-lib/crypto/paillier"
 	"github.com/binance-chain/tss-lib/crypto/vss"
 	"github.com/binance-chain/tss-lib/test"
@@ -47,8 +48,19 @@ func TestStartRound1Paillier(t *testing.T) {
 	threshold := 1
 	params := tss.NewParameters(p2pCtx, pIDs[0], len(pIDs), threshold)
 
+	fixtures, pIDs, err := LoadKeygenTestFixtures(testParticipants)
+	if err != nil {
+		common.Logger.Info("No test fixtures were found, so the safe primes will be generated from scratch. This may take a while...")
+		pIDs = tss.GenerateTestPartyIDs(testParticipants)
+	}
+
+	var lp *LocalParty
 	out := make(chan tss.Message, len(pIDs))
-	lp := NewLocalParty(params, out, nil).(*LocalParty)
+	if 0 < len(fixtures) {
+		lp = NewLocalParty(params, out, nil, fixtures[0].LocalPreParams).(*LocalParty)
+	} else {
+		lp = NewLocalParty(params, out, nil).(*LocalParty)
+	}
 	if err := lp.Start(); err != nil {
 		assert.FailNow(t, err.Error())
 	}
@@ -76,8 +88,19 @@ func TestFinishAndSaveH1H2(t *testing.T) {
 	threshold := 1
 	params := tss.NewParameters(p2pCtx, pIDs[0], len(pIDs), threshold)
 
+	fixtures, pIDs, err := LoadKeygenTestFixtures(testParticipants)
+	if err != nil {
+		common.Logger.Info("No test fixtures were found, so the safe primes will be generated from scratch. This may take a while...")
+		pIDs = tss.GenerateTestPartyIDs(testParticipants)
+	}
+
+	var lp *LocalParty
 	out := make(chan tss.Message, len(pIDs))
-	lp := NewLocalParty(params, out, nil).(*LocalParty)
+	if 0 < len(fixtures) {
+		lp = NewLocalParty(params, out, nil, fixtures[0].LocalPreParams).(*LocalParty)
+	} else {
+		lp = NewLocalParty(params, out, nil).(*LocalParty)
+	}
 	if err := lp.Start(); err != nil {
 		assert.FailNow(t, err.Error())
 	}
@@ -112,22 +135,35 @@ func TestBadMessageCulprits(t *testing.T) {
 	p2pCtx := tss.NewPeerContext(pIDs)
 	params := tss.NewParameters(p2pCtx, pIDs[0], len(pIDs), 1)
 
+	fixtures, pIDs, err := LoadKeygenTestFixtures(testParticipants)
+	if err != nil {
+		common.Logger.Info("No test fixtures were found, so the safe primes will be generated from scratch. This may take a while...")
+		pIDs = tss.GenerateTestPartyIDs(testParticipants)
+	}
+
+	var lp *LocalParty
 	out := make(chan tss.Message, len(pIDs))
-	lp := NewLocalParty(params, out, nil)
+	if 0 < len(fixtures) {
+		lp = NewLocalParty(params, out, nil, fixtures[0].LocalPreParams).(*LocalParty)
+	} else {
+		lp = NewLocalParty(params, out, nil).(*LocalParty)
+	}
 	if err := lp.Start(); err != nil {
 		assert.FailNow(t, err.Error())
 	}
 
-	badMsg := NewKGRound1Message(pIDs[1], zero, &paillier.PublicKey{N: zero}, zero, zero, zero)
-	ok, err := lp.Update(badMsg)
-	t.Log(err)
+	badMsg, _ := NewKGRound1Message(pIDs[1], zero, &paillier.PublicKey{N: zero}, zero, zero, zero, new(dlnproof.Proof), new(dlnproof.Proof))
+	ok, err2 := lp.Update(badMsg)
+	t.Log(err2)
 	assert.False(t, ok)
-	assert.Error(t, err)
-	assert.Equal(t, 1, len(err.Culprits()))
-	assert.Equal(t, pIDs[1], err.Culprits()[0])
+	if !assert.Error(t, err2) {
+		return
+	}
+	assert.Equal(t, 1, len(err2.Culprits()))
+	assert.Equal(t, pIDs[1], err2.Culprits()[0])
 	assert.Equal(t,
-		"task keygen, party {0,P[1]}, round 1, culprits [{1,P[2]}]: message failed ValidateBasic: Type: binance.tss-lib.ecdsa.keygen.KGRound1Message, From: {1,P[2]}, To: all",
-		err.Error())
+		"task keygen, party {0,P[1]}, round 1, culprits [{1,2}]: message failed ValidateBasic: Type: binance.tss-lib.ecdsa.keygen.KGRound1Message, From: {1,2}, To: all",
+		err2.Error())
 }
 
 func TestE2EConcurrentAndSaveFixtures(t *testing.T) {