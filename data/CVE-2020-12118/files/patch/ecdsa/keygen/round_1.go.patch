@@ -13,6 +13,7 @@ import (
 	"github.com/binance-chain/tss-lib/common"
 	"github.com/binance-chain/tss-lib/crypto"
 	cmts "github.com/binance-chain/tss-lib/crypto/commitments"
+	"github.com/binance-chain/tss-lib/crypto/dlnproof"
 	"github.com/binance-chain/tss-lib/crypto/vss"
 	"github.com/binance-chain/tss-lib/tss"
 )
@@ -66,7 +67,10 @@ func (round *round1) Start() *tss.Error {
 	// 9-11. compute ntilde, h1, h2 (uses safe primes)
 	// use the pre-params if they were provided to the LocalParty constructor
 	var preParams *LocalPreParams
-	if round.save.LocalPreParams.Validate() {
+	if round.save.LocalPreParams.Validate() && !round.save.LocalPreParams.ValidateWithProof() {
+		return round.WrapError(
+			errors.New("`optionalPreParams` failed to validate; it might have been generated with an older version of tss-lib"))
+	} else if round.save.LocalPreParams.ValidateWithProof() {
 		preParams = &round.save.LocalPreParams
 	} else {
 		preParams, err = GeneratePreParams(round.SafePrimeGenTimeout(), 3)
@@ -78,6 +82,18 @@ func (round *round1) Start() *tss.Error {
 	round.save.NTildej[i] = preParams.NTildei
 	round.save.H1j[i], round.save.H2j[i] = preParams.H1i, preParams.H2i
 
+	// generate the dlnproofs for keygen
+	h1i, h2i, alpha, beta, p, q, NTildei :=
+		preParams.H1i,
+		preParams.H2i,
+		preParams.Alpha,
+		preParams.Beta,
+		preParams.P,
+		preParams.Q,
+		preParams.NTildei
+	dlnProof1 := dlnproof.NewDLNProof(h1i, h2i, alpha, p, q, NTildei)
+	dlnProof2 := dlnproof.NewDLNProof(h2i, h1i, beta, p, q, NTildei)
+
 	// for this P: SAVE
 	// - shareID
 	// and keep in temporary storage:
@@ -94,7 +110,11 @@ func (round *round1) Start() *tss.Error {
 
 	// BROADCAST commitments, paillier pk + proof; round 1 message
 	{
-		msg := NewKGRound1Message(round.PartyID(), cmt.C, &preParams.PaillierSK.PublicKey, preParams.NTildei, preParams.H1i, preParams.H2i)
+		msg, err := NewKGRound1Message(
+			round.PartyID(), cmt.C, &preParams.PaillierSK.PublicKey, preParams.NTildei, preParams.H1i, preParams.H2i, dlnProof1, dlnProof2)
+		if err != nil {
+			return round.WrapError(err, Pi)
+		}
 		round.temp.kgRound1Messages[i] = msg
 		round.out <- msg
 	}