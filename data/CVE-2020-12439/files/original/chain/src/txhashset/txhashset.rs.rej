--- /dev/null
+++ /dev/null
@@ -1573,13 +1510,40 @@ fn input_pos_to_rewind(
 	head_header: &BlockHeader,
 	batch: &Batch<'_>,
 ) -> Result<Bitmap, Error> {
-	let mut bitmap = Bitmap::create();
+	if head_header.height <= block_header.height {
+		return Ok(Bitmap::create());
+	}
+
+	// Batching up the block input bitmaps, and running fast_or() on every batch of 256 bitmaps.
+	// so to avoid maintaining a huge vec of bitmaps.
+	let bitmap_fast_or = |b_res, block_input_bitmaps: &mut Vec<Bitmap>| -> Option<Bitmap> {
+		if let Some(b) = b_res {
+			block_input_bitmaps.push(b);
+			if block_input_bitmaps.len() < 256 {
+				return None;
+			}
+		}
+		let bitmap = Bitmap::fast_or(&block_input_bitmaps.iter().collect::<Vec<&Bitmap>>());
+		block_input_bitmaps.clear();
+		block_input_bitmaps.push(bitmap.clone());
+		Some(bitmap)
+	};
+
+	let mut block_input_bitmaps: Vec<Bitmap> = vec![];
+
 	let mut current = head_header.clone();
-	while current.height > block_header.height {
-		if let Ok(block_bitmap) = batch.get_block_input_bitmap(&current.hash()) {
-			bitmap.or_inplace(&block_bitmap);
+	while current.hash() != block_header.hash() {
+		if current.height < 1 {
+			break;
+		}
+
+		// I/O should be minimized or eliminated here for most
+		// rewind scenarios.
+		if let Ok(b_res) = batch.get_block_input_bitmap(&current.hash()) {
+			bitmap_fast_or(Some(b_res), &mut block_input_bitmaps);
 		}
 		current = batch.get_previous_header(&current)?;
 	}
-	Ok(bitmap)
+
+	bitmap_fast_or(None, &mut block_input_bitmaps).ok_or_else(|| ErrorKind::Bitmap.into())
 
