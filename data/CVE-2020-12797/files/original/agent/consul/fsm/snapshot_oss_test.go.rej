--- /dev/null
+++ /dev/null
@@ -664,60 +677,84 @@ func TestFSM_BadRestore_OSS(t *testing.T) {
 	// Create an FSM with some state.
 	logger := testutil.Logger(t)
 	fsm, err := New(nil, logger)
-	require.NoError(t, err)
+	if err != nil {
+		t.Fatalf("err: %v", err)
+	}
 	fsm.state.EnsureNode(1, &structs.Node{Node: "foo", Address: "127.0.0.1"})
 	abandonCh := fsm.state.AbandonCh()
 
 	// Do a bad restore.
 	buf := bytes.NewBuffer([]byte("bad snapshot"))
 	sink := &MockSink{buf, false}
-	require.Error(t, fsm.Restore(sink))
+	if err := fsm.Restore(sink); err == nil {
+		t.Fatalf("err: %v", err)
+	}
 
 	// Verify the contents didn't get corrupted.
 	_, nodes, err := fsm.state.Nodes(nil)
-	require.NoError(t, err)
-	require.Len(t, nodes, 1)
-	require.Equal(t, "foo", nodes[0].Node)
-	require.Equal(t, "127.0.0.1", nodes[0].Address)
-	require.Empty(t, nodes[0].TaggedAddresses)
+	if err != nil {
+		t.Fatalf("err: %s", err)
+	}
+	if len(nodes) != 1 {
+		t.Fatalf("bad: %v", nodes)
+	}
+	if nodes[0].Node != "foo" ||
+		nodes[0].Address != "127.0.0.1" ||
+		len(nodes[0].TaggedAddresses) != 0 {
+		t.Fatalf("bad: %v", nodes[0])
+	}
 
 	// Verify the old state store didn't get abandoned.
 	select {
 	case <-abandonCh:
-		require.FailNow(t, "FSM state was abandoned when it should not have been")
+		t.Fatalf("bad")
 	default:
 	}
 }
 
 func TestFSM_BadSnapshot_NilCAConfig(t *testing.T) {
 	t.Parallel()
 
+	require := require.New(t)
+
 	// Create an FSM with no config entry.
 	logger := testutil.Logger(t)
 	fsm, err := New(nil, logger)
-	require.NoError(t, err)
+	if err != nil {
+		t.Fatalf("err: %v", err)
+	}
 
 	// Snapshot
 	snap, err := fsm.Snapshot()
-	require.NoError(t, err)
+	if err != nil {
+		t.Fatalf("err: %v", err)
+	}
 	defer snap.Release()
 
 	// Persist
 	buf := bytes.NewBuffer(nil)
 	sink := &MockSink{buf, false}
-	require.NoError(t, snap.Persist(sink))
+	if err := snap.Persist(sink); err != nil {
+		t.Fatalf("err: %v", err)
+	}
 
 	// Try to restore on a new FSM
 	fsm2, err := New(nil, logger)
-	require.NoError(t, err)
+	if err != nil {
+		t.Fatalf("err: %v", err)
+	}
 
 	// Do a restore
-	require.NoError(t, fsm2.Restore(sink))
+	if err := fsm2.Restore(sink); err != nil {
+		t.Fatalf("err: %v", err)
+	}
 
 	// Make sure there's no entry in the CA config table.
 	state := fsm2.State()
 	idx, config, err := state.CAConfig(nil)
-	require.NoError(t, err)
-	require.EqualValues(t, 0, idx)
-	require.Nil(t, config)
+	require.NoError(err)
+	require.Equal(uint64(0), idx)
+	if config != nil {
+		t.Fatalf("config should be nil")
+	}
 
