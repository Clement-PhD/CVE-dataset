@@ -242,6 +242,16 @@ func (r *controlPlaneInstanceReconciler) Reconcile(ctx context.Context) (result
 		}
 	}
 
+	// validate generated manifests
+	// this has to be done always before applying because the memberroll might have changed
+	err = r.validateManifests(ctx)
+	if err != nil {
+		reconciliationReason = v1.ConditionReasonReconcileError
+		reconciliationMessage = "Error validating generated manifests"
+		err = errors.Wrap(err, reconciliationMessage)
+		return
+	}
+
 	// create components
 	for _, key := range r.getChartsInInstallationOrder() {
 		if ready, err = r.processComponentManifests(ctx, key); !ready {
@@ -646,6 +656,55 @@ func (r *controlPlaneInstanceReconciler) renderCharts(ctx context.Context) error
 	return nil
 }
 
+func (r *controlPlaneInstanceReconciler) validateManifests(ctx context.Context) error {
+	log := common.LogFromContext(ctx)
+	allErrors := []error{}
+	// validate resource namespaces
+	smmr := &v1.ServiceMeshMemberRoll{}
+	var smmrRetrievalError error
+	if smmrRetrievalError = r.Client.Get(context.TODO(), client.ObjectKey{Namespace: r.Instance.GetNamespace(), Name: common.MemberRollName}, smmr); smmrRetrievalError != nil {
+		if !apierrors.IsNotFound(smmrRetrievalError) {
+			// log error, but don't fail validation just yet: we'll just assume that the control plane namespace is the only namespace for now
+			// if we end up failing validation because of this assumption, we'll return this error
+			log.Error(smmrRetrievalError, "failed to retrieve SMMR for SMCP")
+			smmr = nil
+		}
+	}
+	meshNamespaces := common.GetMeshNamespaces(r.Instance, smmr)
+	for _, manifestList := range r.renderings {
+		for _, manifestBundle := range manifestList {
+			for _, manifest := range strings.Split(manifestBundle.Content, "---") {
+				obj := map[string]interface{}{}
+				err := yaml.Unmarshal([]byte(manifest), &obj)
+				if err != nil || obj == nil {
+					continue
+				}
+				metadata, ok := obj["metadata"].(map[string]interface{})
+				if !ok {
+					// if it doesn't have a metadata section, ignore
+					continue
+				}
+				objNs, ok := metadata["namespace"].(string)
+				if !ok {
+					// if namespace is not set, ignore
+					continue
+				}
+				if !meshNamespaces.Has(objNs) {
+					allErrors = append(allErrors, fmt.Errorf("%s: namespace of manifest %s/%s not in mesh", manifestBundle.Name, metadata["namespace"], metadata["name"]))
+				}
+			}
+		}
+	}
+	if len(allErrors) > 0 {
+		// if validation fails because we couldn't Get() the SMMR, return that error
+		if smmrRetrievalError != nil {
+			return smmrRetrievalError
+		}
+		return utilerrors.NewAggregate(allErrors)
+	}
+	return nil
+}
+
 func (r *controlPlaneInstanceReconciler) PostStatus(ctx context.Context) error {
 	log := common.LogFromContext(ctx)
 	instance := &v1.ServiceMeshControlPlane{}