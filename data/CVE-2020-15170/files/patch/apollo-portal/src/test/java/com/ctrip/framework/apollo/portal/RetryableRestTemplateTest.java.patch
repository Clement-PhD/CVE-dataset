@@ -1,6 +1,14 @@
 package com.ctrip.framework.apollo.portal;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
 import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.ArgumentMatchers.isNull;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
@@ -9,20 +17,28 @@
 import com.ctrip.framework.apollo.core.dto.ServiceDTO;
 import com.ctrip.framework.apollo.portal.component.AdminServiceAddressLocator;
 import com.ctrip.framework.apollo.portal.component.RetryableRestTemplate;
+import com.ctrip.framework.apollo.portal.component.config.PortalConfig;
 import com.ctrip.framework.apollo.portal.environment.Env;
 import com.ctrip.framework.apollo.portal.environment.PortalMetaDomainService;
+import com.google.common.collect.Maps;
+import com.google.gson.Gson;
 import java.net.SocketTimeoutException;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.List;
+import java.util.Map;
 import org.apache.http.HttpHost;
 import org.apache.http.conn.ConnectTimeoutException;
 import org.apache.http.conn.HttpHostConnectException;
-import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
+import org.mockito.ArgumentCaptor;
 import org.mockito.InjectMocks;
 import org.mockito.Mock;
-import org.springframework.http.HttpStatus;
+import org.springframework.core.ParameterizedTypeReference;
+import org.springframework.http.HttpEntity;
+import org.springframework.http.HttpHeaders;
+import org.springframework.http.HttpMethod;
 import org.springframework.http.ResponseEntity;
 import org.springframework.web.client.ResourceAccessException;
 import org.springframework.web.client.RestTemplate;
@@ -35,9 +51,13 @@ public class RetryableRestTemplateTest extends AbstractUnitTest {
   private RestTemplate restTemplate;
   @Mock
   private PortalMetaDomainService portalMetaDomainService;
+  @Mock
+  private PortalConfig portalConfig;
   @InjectMocks
   private RetryableRestTemplate retryableRestTemplate;
 
+  private Gson gson = new Gson();
+
   private String path = "app";
   private String serviceOne = "http://10.0.0.1";
   private String serviceTwo = "http://10.0.0.2";
@@ -46,15 +66,16 @@ public class RetryableRestTemplateTest extends AbstractUnitTest {
   private ResourceAccessException httpHostConnectException = new ResourceAccessException("");
   private ResourceAccessException connectTimeoutException = new ResourceAccessException("");
   private Object request = new Object();
-  private ResponseEntity<Object> entity = new ResponseEntity<>(HttpStatus.OK);
-
+  private Object result = new Object();
+  private Class<?> requestType = request.getClass();
 
   @Before
   public void init() {
     socketTimeoutException.initCause(new SocketTimeoutException());
 
     httpHostConnectException
-        .initCause(new HttpHostConnectException(new ConnectTimeoutException(), new HttpHost(serviceOne, 80)));
+        .initCause(new HttpHostConnectException(new ConnectTimeoutException(),
+            new HttpHost(serviceOne, 80)));
     connectTimeoutException.initCause(new ConnectTimeoutException());
   }
 
@@ -70,72 +91,397 @@ public void testNoAdminServer() {
   public void testAllServerDown() {
 
     when(serviceAddressLocator.getServiceList(any()))
-        .thenReturn(Arrays.asList(mockService(serviceOne), mockService(serviceTwo), mockService(serviceThree)));
-    when(restTemplate.getForObject(serviceOne + "/" + path, Object.class)).thenThrow(socketTimeoutException);
-    when(restTemplate.getForObject(serviceTwo + "/" + path, Object.class)).thenThrow(httpHostConnectException);
-    when(restTemplate.getForObject(serviceThree + "/" + path, Object.class)).thenThrow(connectTimeoutException);
+        .thenReturn(Arrays
+            .asList(mockService(serviceOne), mockService(serviceTwo), mockService(serviceThree)));
+    when(restTemplate
+        .exchange(eq(serviceOne + "/" + path), eq(HttpMethod.GET), any(HttpEntity.class),
+            eq(Object.class))).thenThrow(socketTimeoutException);
+    when(restTemplate
+        .exchange(eq(serviceTwo + "/" + path), eq(HttpMethod.GET), any(HttpEntity.class),
+            eq(Object.class))).thenThrow(httpHostConnectException);
+    when(restTemplate
+        .exchange(eq(serviceThree + "/" + path), eq(HttpMethod.GET), any(HttpEntity.class),
+            eq(Object.class))).thenThrow(connectTimeoutException);
 
     retryableRestTemplate.get(Env.DEV, path, Object.class);
 
-    verify(restTemplate).getForObject(serviceOne + "/" + path, Object.class);
-    verify(restTemplate).getForObject(serviceTwo + "/" + path, Object.class);
-    verify(restTemplate).getForObject(serviceThree + "/" + path, Object.class);
+    verify(restTemplate, times(1))
+        .exchange(eq(serviceOne + "/" + path), eq(HttpMethod.GET), any(HttpEntity.class),
+            eq(Object.class));
+    verify(restTemplate, times(1))
+        .exchange(eq(serviceTwo + "/" + path), eq(HttpMethod.GET), any(HttpEntity.class),
+            eq(Object.class));
+    verify(restTemplate, times(1))
+        .exchange(eq(serviceThree + "/" + path), eq(HttpMethod.GET), any(HttpEntity.class),
+            eq(Object.class));
+  }
 
+  @Test
+  public void testOneServerDown() {
+    ResponseEntity someEntity = mock(ResponseEntity.class);
+    when(someEntity.getBody()).thenReturn(result);
 
+    when(serviceAddressLocator.getServiceList(any()))
+        .thenReturn(Arrays
+            .asList(mockService(serviceOne), mockService(serviceTwo), mockService(serviceThree)));
+    when(restTemplate
+        .exchange(eq(serviceOne + "/" + path), eq(HttpMethod.GET), any(HttpEntity.class),
+            eq(Object.class))).thenThrow(socketTimeoutException);
+    when(restTemplate
+        .exchange(eq(serviceTwo + "/" + path), eq(HttpMethod.GET), any(HttpEntity.class),
+            eq(Object.class))).thenReturn(someEntity);
+    when(restTemplate
+        .exchange(eq(serviceThree + "/" + path), eq(HttpMethod.GET), any(HttpEntity.class),
+            eq(Object.class))).thenThrow(connectTimeoutException);
+
+    Object actualResult = retryableRestTemplate.get(Env.DEV, path, Object.class);
+
+    verify(restTemplate, times(1))
+        .exchange(eq(serviceOne + "/" + path), eq(HttpMethod.GET), any(HttpEntity.class),
+            eq(Object.class));
+    verify(restTemplate, times(1))
+        .exchange(eq(serviceTwo + "/" + path), eq(HttpMethod.GET), any(HttpEntity.class),
+            eq(Object.class));
+    verify(restTemplate, never())
+        .exchange(eq(serviceThree + "/" + path), eq(HttpMethod.GET), any(HttpEntity.class),
+            eq(Object.class));
+    assertEquals(result, actualResult);
   }
 
   @Test
-  public void testOneServerDown() {
+  public void testPostSocketTimeoutNotRetry() {
+    ResponseEntity someEntity = mock(ResponseEntity.class);
+    when(someEntity.getBody()).thenReturn(result);
+
+    when(serviceAddressLocator.getServiceList(any()))
+        .thenReturn(Arrays
+            .asList(mockService(serviceOne), mockService(serviceTwo), mockService(serviceThree)));
+    when(restTemplate
+        .exchange(eq(serviceOne + "/" + path), eq(HttpMethod.POST), any(HttpEntity.class),
+            eq(Object.class))).thenThrow(socketTimeoutException);
+    when(restTemplate
+        .exchange(eq(serviceTwo + "/" + path), eq(HttpMethod.POST), any(HttpEntity.class),
+            eq(Object.class))).thenReturn(someEntity);
+
+    Throwable exception = null;
+    Object actualResult = null;
+    try {
+      actualResult = retryableRestTemplate.post(Env.DEV, path, request, Object.class);
+    } catch (Throwable ex) {
+      exception = ex;
+    }
+
+    assertNull(actualResult);
+    assertSame(socketTimeoutException, exception);
+    verify(restTemplate, times(1))
+        .exchange(eq(serviceOne + "/" + path), eq(HttpMethod.POST), any(HttpEntity.class),
+            eq(Object.class));
+    verify(restTemplate, never())
+        .exchange(eq(serviceTwo + "/" + path), eq(HttpMethod.POST), any(HttpEntity.class),
+            eq(Object.class));
+  }
+
+  @Test
+  public void testDelete() {
+    ResponseEntity someEntity = mock(ResponseEntity.class);
 
-    Object result = new Object();
     when(serviceAddressLocator.getServiceList(any()))
-        .thenReturn(Arrays.asList(mockService(serviceOne), mockService(serviceTwo), mockService(serviceThree)));
-    when(restTemplate.getForObject(serviceOne + "/" + path, Object.class)).thenThrow(socketTimeoutException);
-    when(restTemplate.getForObject(serviceTwo + "/" + path, Object.class)).thenReturn(result);
-    when(restTemplate.getForObject(serviceThree + "/" + path, Object.class)).thenThrow(connectTimeoutException);
+        .thenReturn(Arrays
+            .asList(mockService(serviceOne), mockService(serviceTwo), mockService(serviceThree)));
+    when(restTemplate
+        .exchange(eq(serviceOne + "/" + path), eq(HttpMethod.DELETE), any(HttpEntity.class),
+            (Class<Object>) isNull())).thenReturn(someEntity);
 
-    Object o = retryableRestTemplate.get(Env.DEV, path, Object.class);
+    retryableRestTemplate.delete(Env.DEV, path);
 
-    verify(restTemplate).getForObject(serviceOne + "/" + path, Object.class);
-    verify(restTemplate).getForObject(serviceTwo + "/" + path, Object.class);
-    verify(restTemplate, times(0)).getForObject(serviceThree + "/" + path, Object.class);
-    Assert.assertEquals(result, o);
+    verify(restTemplate)
+        .exchange(eq(serviceOne + "/" + path), eq(HttpMethod.DELETE), any(HttpEntity.class),
+            (Class<Object>) isNull());
   }
 
-  @Test(expected = ResourceAccessException.class)
-  public void testPostSocketTimeoutNotRetry(){
+  @Test
+  public void testPut() {
+    ResponseEntity someEntity = mock(ResponseEntity.class);
+
     when(serviceAddressLocator.getServiceList(any()))
-        .thenReturn(Arrays.asList(mockService(serviceOne), mockService(serviceTwo), mockService(serviceThree)));
+        .thenReturn(Arrays
+            .asList(mockService(serviceOne), mockService(serviceTwo), mockService(serviceThree)));
+    when(restTemplate
+        .exchange(eq(serviceOne + "/" + path), eq(HttpMethod.PUT), any(HttpEntity.class),
+            (Class<Object>) isNull())).thenReturn(someEntity);
+
+    retryableRestTemplate.put(Env.DEV, path, request);
+
+    ArgumentCaptor<HttpEntity> argumentCaptor = ArgumentCaptor.forClass(HttpEntity.class);
+    verify(restTemplate)
+        .exchange(eq(serviceOne + "/" + path), eq(HttpMethod.PUT), argumentCaptor.capture(),
+            (Class<Object>) isNull());
+
+    assertEquals(request, argumentCaptor.getValue().getBody());
+  }
+
+  @Test
+  public void testPostObjectWithNoAccessToken() {
+    Env someEnv = Env.DEV;
+    ResponseEntity someEntity = mock(ResponseEntity.class);
+
+    when(serviceAddressLocator.getServiceList(someEnv))
+        .thenReturn(Collections.singletonList(mockService(serviceOne)));
+    when(restTemplate
+        .exchange(eq(serviceOne + "/" + path), eq(HttpMethod.POST), any(HttpEntity.class),
+            eq(requestType))).thenReturn(someEntity);
+    when(someEntity.getBody()).thenReturn(result);
 
-    when(restTemplate.postForEntity(serviceOne + "/" + path, request, Object.class)).thenThrow(socketTimeoutException);
-    when(restTemplate.postForEntity(serviceTwo + "/" + path, request, Object.class)).thenReturn(entity);
+    Object actualResult = retryableRestTemplate.post(someEnv, path, request, requestType);
 
-    retryableRestTemplate.post(Env.DEV, path, request, Object.class);
+    assertEquals(result, actualResult);
 
-    verify(restTemplate).postForEntity(serviceOne + "/" + path, request, Object.class);
-    verify(restTemplate, times(0)).postForEntity(serviceTwo + "/" + path, request, Object.class);
+    ArgumentCaptor<HttpEntity> argumentCaptor = ArgumentCaptor.forClass(HttpEntity.class);
+    verify(restTemplate, times(1))
+        .exchange(eq(serviceOne + "/" + path), eq(HttpMethod.POST), argumentCaptor.capture(),
+            eq(requestType));
+
+    HttpEntity entity = argumentCaptor.getValue();
+    HttpHeaders headers = entity.getHeaders();
+
+    assertSame(request, entity.getBody());
+    assertTrue(headers.isEmpty());
   }
 
+  @Test
+  public void testPostObjectWithAccessToken() {
+    Env someEnv = Env.DEV;
+    String someToken = "someToken";
+    ResponseEntity someEntity = mock(ResponseEntity.class);
+
+    when(portalConfig.getAdminServiceAccessTokens())
+        .thenReturn(mockAdminServiceTokens(someEnv, someToken));
+    when(serviceAddressLocator.getServiceList(someEnv))
+        .thenReturn(Collections.singletonList(mockService(serviceOne)));
+    when(restTemplate
+        .exchange(eq(serviceOne + "/" + path), eq(HttpMethod.POST), any(HttpEntity.class),
+            eq(requestType))).thenReturn(someEntity);
+    when(someEntity.getBody()).thenReturn(result);
+
+    Object actualResult = retryableRestTemplate.post(someEnv, path, request, requestType);
+
+    assertEquals(result, actualResult);
+
+    ArgumentCaptor<HttpEntity> argumentCaptor = ArgumentCaptor.forClass(HttpEntity.class);
+    verify(restTemplate, times(1))
+        .exchange(eq(serviceOne + "/" + path), eq(HttpMethod.POST), argumentCaptor.capture(),
+            eq(requestType));
+
+    HttpEntity entity = argumentCaptor.getValue();
+    HttpHeaders headers = entity.getHeaders();
+    List<String> headerValue = headers.get(HttpHeaders.AUTHORIZATION);
+
+    assertSame(request, entity.getBody());
+    assertEquals(1, headers.size());
+    assertEquals(1, headerValue.size());
+    assertEquals(someToken, headerValue.get(0));
+  }
 
   @Test
-  public void testDelete(){
-    when(serviceAddressLocator.getServiceList(any()))
-        .thenReturn(Arrays.asList(mockService(serviceOne), mockService(serviceTwo), mockService(serviceThree)));
+  public void testPostObjectWithNoAccessTokenForEnv() {
+    Env someEnv = Env.DEV;
+    Env anotherEnv = Env.PRO;
+    String someToken = "someToken";
+    ResponseEntity someEntity = mock(ResponseEntity.class);
+
+    when(portalConfig.getAdminServiceAccessTokens())
+        .thenReturn(mockAdminServiceTokens(someEnv, someToken));
+    when(serviceAddressLocator.getServiceList(someEnv))
+        .thenReturn(Collections.singletonList(mockService(serviceOne)));
+    when(serviceAddressLocator.getServiceList(anotherEnv))
+        .thenReturn(Collections.singletonList(mockService(serviceTwo)));
+    when(restTemplate
+        .exchange(eq(serviceTwo + "/" + path), eq(HttpMethod.POST), any(HttpEntity.class),
+            eq(requestType))).thenReturn(someEntity);
+    when(someEntity.getBody()).thenReturn(result);
+
+    Object actualResult = retryableRestTemplate.post(anotherEnv, path, request, requestType);
+
+    assertEquals(result, actualResult);
+
+    ArgumentCaptor<HttpEntity> argumentCaptor = ArgumentCaptor.forClass(HttpEntity.class);
+    verify(restTemplate, times(1))
+        .exchange(eq(serviceTwo + "/" + path), eq(HttpMethod.POST), argumentCaptor.capture(),
+            eq(requestType));
+
+    HttpEntity entity = argumentCaptor.getValue();
+    HttpHeaders headers = entity.getHeaders();
+
+    assertSame(request, entity.getBody());
+    assertTrue(headers.isEmpty());
+  }
 
-    retryableRestTemplate.delete(Env.DEV, path);
+  @Test
+  public void testPostEntityWithNoAccessToken() {
+    Env someEnv = Env.DEV;
+    String originalHeader = "someHeader";
+    String originalValue = "someValue";
+    HttpHeaders originalHeaders = new HttpHeaders();
+    originalHeaders.add(originalHeader, originalValue);
+    HttpEntity<Object> requestEntity = new HttpEntity<>(request, originalHeaders);
+    ResponseEntity someEntity = mock(ResponseEntity.class);
+
+    when(serviceAddressLocator.getServiceList(someEnv))
+        .thenReturn(Collections.singletonList(mockService(serviceOne)));
+    when(restTemplate
+        .exchange(eq(serviceOne + "/" + path), eq(HttpMethod.POST), any(HttpEntity.class),
+            eq(requestType))).thenReturn(someEntity);
+    when(someEntity.getBody()).thenReturn(result);
+
+    Object actualResult = retryableRestTemplate.post(someEnv, path, requestEntity, requestType);
+
+    assertEquals(result, actualResult);
+
+    ArgumentCaptor<HttpEntity> argumentCaptor = ArgumentCaptor.forClass(HttpEntity.class);
+    verify(restTemplate, times(1))
+        .exchange(eq(serviceOne + "/" + path), eq(HttpMethod.POST), argumentCaptor.capture(),
+            eq(requestType));
+
+    HttpEntity entity = argumentCaptor.getValue();
+
+    assertSame(requestEntity, entity);
+    assertSame(request, entity.getBody());
+    assertEquals(originalHeaders, entity.getHeaders());
+  }
+
+  @Test
+  public void testPostEntityWithAccessToken() {
+    Env someEnv = Env.DEV;
+    String someToken = "someToken";
+    String originalHeader = "someHeader";
+    String originalValue = "someValue";
+    HttpHeaders originalHeaders = new HttpHeaders();
+    originalHeaders.add(originalHeader, originalValue);
+    HttpEntity<Object> requestEntity = new HttpEntity<>(request, originalHeaders);
+    ResponseEntity someEntity = mock(ResponseEntity.class);
+
+    when(portalConfig.getAdminServiceAccessTokens())
+        .thenReturn(mockAdminServiceTokens(someEnv, someToken));
+    when(serviceAddressLocator.getServiceList(someEnv))
+        .thenReturn(Collections.singletonList(mockService(serviceOne)));
+    when(restTemplate
+        .exchange(eq(serviceOne + "/" + path), eq(HttpMethod.POST), any(HttpEntity.class),
+            eq(requestType))).thenReturn(someEntity);
+    when(someEntity.getBody()).thenReturn(result);
+
+    Object actualResult = retryableRestTemplate.post(someEnv, path, requestEntity, requestType);
+
+    assertEquals(result, actualResult);
+
+    ArgumentCaptor<HttpEntity> argumentCaptor = ArgumentCaptor.forClass(HttpEntity.class);
+    verify(restTemplate, times(1))
+        .exchange(eq(serviceOne + "/" + path), eq(HttpMethod.POST), argumentCaptor.capture(),
+            eq(requestType));
+
+    HttpEntity entity = argumentCaptor.getValue();
+    HttpHeaders headers = entity.getHeaders();
+
+    assertSame(request, entity.getBody());
+    assertEquals(2, headers.size());
+    assertEquals(originalValue, headers.get(originalHeader).get(0));
+    assertEquals(someToken, headers.get(HttpHeaders.AUTHORIZATION).get(0));
+  }
 
-    verify(restTemplate).delete(serviceOne + "/" + path);
+  @Test
+  public void testGetEntityWithNoAccessToken() {
+    Env someEnv = Env.DEV;
+    ParameterizedTypeReference requestType = mock(ParameterizedTypeReference.class);
+    ResponseEntity someEntity = mock(ResponseEntity.class);
+
+    when(serviceAddressLocator.getServiceList(someEnv))
+        .thenReturn(Collections.singletonList(mockService(serviceOne)));
+    when(restTemplate
+        .exchange(eq(serviceOne + "/" + path), eq(HttpMethod.GET), any(HttpEntity.class),
+            eq(requestType))).thenReturn(someEntity);
+
+    ResponseEntity actualResult = retryableRestTemplate.get(someEnv, path, requestType);
+
+    assertEquals(someEntity, actualResult);
+
+    ArgumentCaptor<HttpEntity> argumentCaptor = ArgumentCaptor.forClass(HttpEntity.class);
+    verify(restTemplate, times(1))
+        .exchange(eq(serviceOne + "/" + path), eq(HttpMethod.GET), argumentCaptor.capture(),
+            eq(requestType));
+
+    HttpHeaders headers = argumentCaptor.getValue().getHeaders();
 
+    assertTrue(headers.isEmpty());
   }
 
   @Test
-  public void testPut(){
-    when(serviceAddressLocator.getServiceList(any()))
-        .thenReturn(Arrays.asList(mockService(serviceOne), mockService(serviceTwo), mockService(serviceThree)));
+  public void testGetEntityWithAccessToken() {
+    Env someEnv = Env.DEV;
+    String someToken = "someToken";
+    ParameterizedTypeReference requestType = mock(ParameterizedTypeReference.class);
+    ResponseEntity someEntity = mock(ResponseEntity.class);
+
+    when(portalConfig.getAdminServiceAccessTokens())
+        .thenReturn(mockAdminServiceTokens(someEnv, someToken));
+    when(serviceAddressLocator.getServiceList(someEnv))
+        .thenReturn(Collections.singletonList(mockService(serviceOne)));
+    when(restTemplate
+        .exchange(eq(serviceOne + "/" + path), eq(HttpMethod.GET), any(HttpEntity.class),
+            eq(requestType))).thenReturn(someEntity);
+
+    ResponseEntity actualResult = retryableRestTemplate.get(someEnv, path, requestType);
+
+    assertEquals(someEntity, actualResult);
+
+    ArgumentCaptor<HttpEntity> argumentCaptor = ArgumentCaptor.forClass(HttpEntity.class);
+    verify(restTemplate, times(1))
+        .exchange(eq(serviceOne + "/" + path), eq(HttpMethod.GET), argumentCaptor.capture(),
+            eq(requestType));
+
+    HttpHeaders headers = argumentCaptor.getValue().getHeaders();
+    List<String> headerValue = headers.get(HttpHeaders.AUTHORIZATION);
+
+    assertEquals(1, headers.size());
+    assertEquals(1, headerValue.size());
+    assertEquals(someToken, headerValue.get(0));
+  }
 
-    retryableRestTemplate.put(Env.DEV, path, request);
+  @Test
+  public void testGetEntityWithNoAccessTokenForEnv() {
+    Env someEnv = Env.DEV;
+    Env anotherEnv = Env.PRO;
+    String someToken = "someToken";
+    ParameterizedTypeReference requestType = mock(ParameterizedTypeReference.class);
+    ResponseEntity someEntity = mock(ResponseEntity.class);
+
+    when(portalConfig.getAdminServiceAccessTokens())
+        .thenReturn(mockAdminServiceTokens(someEnv, someToken));
+    when(serviceAddressLocator.getServiceList(someEnv))
+        .thenReturn(Collections.singletonList(mockService(serviceOne)));
+    when(serviceAddressLocator.getServiceList(anotherEnv))
+        .thenReturn(Collections.singletonList(mockService(serviceTwo)));
+    when(restTemplate
+        .exchange(eq(serviceTwo + "/" + path), eq(HttpMethod.GET), any(HttpEntity.class),
+            eq(requestType))).thenReturn(someEntity);
+
+    ResponseEntity actualResult = retryableRestTemplate.get(anotherEnv, path, requestType);
+
+    assertEquals(someEntity, actualResult);
+
+    ArgumentCaptor<HttpEntity> argumentCaptor = ArgumentCaptor.forClass(HttpEntity.class);
+    verify(restTemplate, times(1))
+        .exchange(eq(serviceTwo + "/" + path), eq(HttpMethod.GET), argumentCaptor.capture(),
+            eq(requestType));
+
+    HttpHeaders headers = argumentCaptor.getValue().getHeaders();
+
+    assertTrue(headers.isEmpty());
+  }
+
+  private String mockAdminServiceTokens(Env env, String token) {
+    Map<String, String> tokenMap = Maps.newHashMap();
+    tokenMap.put(env.getName(), token);
 
-    verify(restTemplate).put(serviceOne + "/" + path, request);
+    return gson.toJson(tokenMap);
   }
 
   private ServiceDTO mockService(String homeUrl) {