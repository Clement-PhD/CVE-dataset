@@ -19,6 +19,8 @@
  */
 
 #include <stdbool.h>
+#include <stdint.h>
+
 #include "base64.h"
 #include "kernel_defines.h"
 
@@ -35,7 +37,7 @@
 /*
  * returns the corresponding ascii symbol value for the given base64 code
  */
-static char getsymbol(unsigned char code, bool urlsafe)
+static char getsymbol(uint8_t code, bool urlsafe)
 {
     if (!IS_ACTIVE(MODULE_BASE64URL)) {
         urlsafe = false;
@@ -73,10 +75,11 @@ static char getsymbol(unsigned char code, bool urlsafe)
 }
 
 static int base64_encode_base(const void *data_in, size_t data_in_size,
-                              unsigned char *base64_out, size_t *base64_out_size,
+                              void *base64_out, size_t *base64_out_size,
                               bool urlsafe)
 {
-    const unsigned char *in = data_in;
+    const uint8_t *in = data_in;
+    uint8_t *out = base64_out;
     size_t required_size = base64_estimate_encode_size(data_in_size);
 
     if (data_in == NULL) {
@@ -93,45 +96,45 @@ static int base64_encode_base(const void *data_in, size_t data_in_size,
         return BASE64_ERROR_BUFFER_OUT_SIZE;
     }
 
-    if (base64_out == NULL) {
+    if (out == NULL) {
         return BASE64_ERROR_BUFFER_OUT;
     }
 
     int iterate_base64_buffer = 0;
-    unsigned char nNum = 0;
+    uint8_t n_num = 0;
     int nLst = 0;
     int njump = 0;
 
     for (int i = 0; i < (int)(data_in_size); ++i) {
-        unsigned char tmpval;
+        uint8_t tmpval;
         njump++;
         tmpval = *(in + i);
 
-        nNum = (tmpval >> (2 * njump));
+        n_num = (tmpval >> (2 * njump));
 
         if (njump == 4) {
-            nNum = nLst << (8 - 2 * njump);
+            n_num = nLst << (8 - 2 * njump);
             njump = 0;
             nLst = 0;
             --i;
         }
         else {
-            nNum += nLst << (8 - 2 * njump);
+            n_num += nLst << (8 - 2 * njump);
             nLst =  tmpval & ((1 << njump * 2) - 1);
         }
 
-        base64_out[iterate_base64_buffer++] = getsymbol(nNum, urlsafe);
+        out[iterate_base64_buffer++] = getsymbol(n_num, urlsafe);
     }
 
     /* The last character is not finished yet */
     njump++;
 
-    nNum = nLst << (8 - 2 * njump);
-    base64_out[iterate_base64_buffer++] = getsymbol(nNum, urlsafe);
+    n_num = nLst << (8 - 2 * njump);
+    out[iterate_base64_buffer++] = getsymbol(n_num, urlsafe);
 
     /* if required we append '=' for the required dividability */
     while (iterate_base64_buffer % 4) {
-        base64_out[iterate_base64_buffer++] = '=';
+        out[iterate_base64_buffer++] = '=';
     }
 
     *base64_out_size = iterate_base64_buffer;
@@ -140,14 +143,14 @@ static int base64_encode_base(const void *data_in, size_t data_in_size,
 }
 
 int base64_encode(const void *data_in, size_t data_in_size,
-                  unsigned char *base64_out, size_t *base64_out_size)
+                  void *base64_out, size_t *base64_out_size)
 {
     return base64_encode_base(data_in, data_in_size, base64_out, base64_out_size, false);
 }
 
 #if IS_ACTIVE(MODULE_BASE64URL)
 int base64url_encode(const void *data_in, size_t data_in_size,
-                     unsigned char *base64_out, size_t *base64_out_size)
+                     void *base64_out, size_t *base64_out_size)
 {
     return base64_encode_base(data_in, data_in_size, base64_out, base64_out_size, true);
 }
@@ -156,7 +159,7 @@ int base64url_encode(const void *data_in, size_t data_in_size,
 /*
  *  returns the corresponding base64 code for the given ascii symbol
  */
-static int getcode(char symbol)
+static uint8_t getcode(char symbol)
 {
     if (symbol == '/') {
         return BASE64_SLASH;
@@ -200,13 +203,14 @@ static int getcode(char symbol)
     return BASE64_NOT_DEFINED;
 }
 
-int base64_decode(const unsigned char *base64_in, size_t base64_in_size,
+int base64_decode(const void *base64_in, size_t base64_in_size,
                   void *data_out, size_t *data_out_size)
 {
-    unsigned char *out = data_out;
+    uint8_t *out = data_out;
+    const uint8_t *in = base64_in;
     size_t required_size = base64_estimate_decode_size(base64_in_size);
 
-    if (base64_in == NULL) {
+    if (in == NULL) {
         return BASE64_ERROR_DATA_IN;
     }
 
@@ -229,31 +233,31 @@ int base64_decode(const unsigned char *base64_in, size_t base64_in_size,
     }
 
     int iterate_data_buffer = 0;
-    unsigned char nNum = 0;
-    int nLst = getcode(base64_in[0]) << 2;
+    uint8_t n_num = 0;
+    int nLst = getcode(in[0]) << 2;
     int code = 0;
 
     int mask = 2;
 
     for (int i = 1; i < (int)(base64_in_size); i++) {
-        code = getcode(base64_in[i]);
+        code = getcode(in[i]);
 
         if (code == BASE64_NOT_DEFINED || code == BASE64_EQUALS) {
             continue;
         }
 
         int nm = (0xFF << (2 * mask));
 
-        nNum = nLst + ((code & (0xFF & nm)) >> (2 * mask));
+        n_num = nLst + ((code & (0xFF & nm)) >> (2 * mask));
         nLst = (code & (0xFF & ~nm)) << (8 - (2 * mask));
 
-        (mask != 3) ? out[iterate_data_buffer++] = nNum : nNum;
+        (mask != 3) ? out[iterate_data_buffer++] = n_num : n_num;
         (mask == 0) ? mask = 3 : mask--;
     }
 
     if (code == BASE64_EQUALS) {
         /* add the last character to the data_out buffer */
-        out[iterate_data_buffer] = nNum;
+        out[iterate_data_buffer] = n_num;
     }
 
     *data_out_size = iterate_data_buffer;