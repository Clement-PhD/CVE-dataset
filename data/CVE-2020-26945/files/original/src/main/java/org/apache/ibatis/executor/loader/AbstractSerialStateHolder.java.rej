--- /dev/null
+++ /dev/null
@@ -130,4 +129,33 @@ protected final Object readResolve() throws ObjectStreamException {
 
   protected abstract Object createDeserializationProxy(Object target, Map<String, ResultLoaderMap.LoadPair> unloadedProperties, ObjectFactory objectFactory,
           List<Class<?>> constructorArgTypes, List<Object> constructorArgs);
+
+  private static class LookAheadObjectInputStream extends ObjectInputStream {
+    private static final List<String> blacklist = Arrays.asList(
+        "org.apache.commons.beanutils.BeanComparator",
+        "org.apache.commons.collections.functors.InvokerTransformer",
+        "org.apache.commons.collections.functors.InstantiateTransformer",
+        "org.apache.commons.collections4.functors.InvokerTransformer",
+        "org.apache.commons.collections4.functors.InstantiateTransformer",
+        "org.codehaus.groovy.runtime.ConvertedClosure",
+        "org.codehaus.groovy.runtime.MethodClosure",
+        "org.springframework.beans.factory.ObjectFactory",
+        "org.springframework.transaction.jta.JtaTransactionManager",
+        "com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl");
+
+    public LookAheadObjectInputStream(InputStream in) throws IOException {
+      super(in);
+    }
+
+    @Override
+    protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
+      String className = desc.getName();
+      if (blacklist.contains(className)) {
+        throw new InvalidClassException(className, "Deserialization is not allowed for security reasons. "
+            + "It is strongly recommended to configure the deserialization filter provided by JDK. "
+            + "See http://openjdk.java.net/jeps/290 for the details.");
+      }
+      return super.resolveClass(desc);
+    }
+  }
 
