--- /dev/null
+++ /dev/null
@@ -599,34 +566,4 @@ mod tests {
         // have the same value).
         assert_eq!(serial.read(MSR_OFFSET), MSR_DSR_BIT | MSR_CTS_BIT);
     }
-
-    #[test]
-    fn test_fifo_max_size() {
-        let event_fd = EventFd::new(libc::EFD_NONBLOCK).unwrap();
-        let mut serial = Serial::new(event_fd, sink());
-
-        // Test case: trying to write too many bytes in an empty fifo will just write
-        // `FIFO_SIZE`. Any other subsequent writes, will return a `ENOBUFS` error.
-        let too_many_bytes = vec![1u8; FIFO_SIZE + 1];
-        let written_bytes = serial.enqueue_raw_bytes(&too_many_bytes).unwrap();
-        assert_eq!(written_bytes, FIFO_SIZE);
-        assert_eq!(serial.in_buffer.len(), FIFO_SIZE);
-
-        // A subsequent call to `enqueue_raw_bytes` fails because the fifo is
-        // now full.
-        let one_byte_input = [1u8];
-        let err_code = serial
-            .enqueue_raw_bytes(&one_byte_input)
-            .unwrap_err()
-            .raw_os_error()
-            .unwrap();
-        assert_eq!(err_code, libc::ENOBUFS);
-
-        // Test case: consuming one byte from a full fifo does not allow writes
-        // bigger than one byte.
-        let _ = serial.read(DATA_OFFSET);
-        let written_bytes = serial.enqueue_raw_bytes(&too_many_bytes[..2]).unwrap();
-        assert_eq!(written_bytes, 1);
-        assert_eq!(serial.in_buffer.len(), FIFO_SIZE);
-    }
 
