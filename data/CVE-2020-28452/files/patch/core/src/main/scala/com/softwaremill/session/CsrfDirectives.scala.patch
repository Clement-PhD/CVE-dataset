@@ -1,7 +1,7 @@
 package com.softwaremill.session
 
 import akka.http.scaladsl.server.Directives._
-import akka.http.scaladsl.server.{Directive0, Directive1}
+import akka.http.scaladsl.server.{ Directive0, Directive1 }
 import akka.stream.Materializer
 
 trait CsrfDirectives {
@@ -11,19 +11,23 @@ trait CsrfDirectives {
     * doesn't have the token set in the header. For all other requests, the value of the token from the CSRF cookie must
     * match the value in the custom header (or request body, if `checkFormBody` is `true`).
     *
+    * The cookie value is the concatenation of a timestamp and its HMAC hash following the OWASP recommendation for
+    * CSRF prevention:
+    * @see <a href="https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#hmac-based-token-pattern">OWASP</a>
+    *
     * Note that this scheme can be broken when not all subdomains are protected or not using HTTPS and secure cookies,
     * and the token is placed in the request body (not in the header).
     *
     * See the documentation for more details.
     */
-  def randomTokenCsrfProtection[T](checkMode: CsrfCheckMode[T]): Directive0 = {
+  def hmacTokenCsrfProtection[T](checkMode: CsrfCheckMode[T]): Directive0 = {
     csrfTokenFromCookie(checkMode).flatMap {
       case Some(cookie) =>
         // if a cookie is already set, we let through all get requests (without setting a new token), or validate
         // that the token matches.
         get.recover { _ =>
           submittedCsrfToken(checkMode).flatMap { submitted =>
-            if (submitted == cookie && !cookie.isEmpty) {
+            if (submitted == cookie && !cookie.isEmpty && checkMode.csrfManager.validateToken(cookie)) {
               pass
             } else {
               reject(checkMode.csrfManager.tokenInvalidRejection).toDirective[Unit]
@@ -36,6 +40,9 @@ trait CsrfDirectives {
     }
   }
 
+  @deprecated("use hmacTokenCsrfProtection", "0.6.1")
+  def randomTokenCsrfProtection[T](checkMode: CsrfCheckMode[T]): Directive0 = hmacTokenCsrfProtection(checkMode)
+
   def submittedCsrfToken[T](checkMode: CsrfCheckMode[T]): Directive1[String] = {
     headerValueByName(checkMode.manager.config.csrfSubmittedName).recover { rejections =>
       checkMode match {