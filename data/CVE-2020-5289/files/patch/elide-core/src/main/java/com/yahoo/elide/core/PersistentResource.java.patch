@@ -95,7 +95,7 @@ public String toString() {
         return String.format("PersistentResource{type=%s, id=%s}", type, uuid.orElse(getId()));
     }
 
-   /**
+    /**
      * Create a resource in the database.
      * @param parent - The immediate ancestor in the lineage or null if this is a root.
      * @param entityClass the entity class
@@ -234,7 +234,7 @@ public boolean matchesId(String checkId) {
      * @return a FilterExpression defined by FilterExpressionCheck.
      */
     private static <T> Optional<FilterExpression> getPermissionFilterExpression(Class<T> loadClass,
-                                                                      RequestScope requestScope) {
+            RequestScope requestScope) {
         try {
             return requestScope.getPermissionExecutor().getReadPermissionFilter(loadClass);
         } catch (ForbiddenAccessException e) {
@@ -305,7 +305,7 @@ public static Set<PersistentResource> loadRecords(
             }
         }
 
-        Set<PersistentResource> existingResources = filter(ReadPermission.class,
+        Set<PersistentResource> existingResources = filter(ReadPermission.class, filter,
                 new PersistentResourceSet(tx.loadObjects(loadClass, Optional.ofNullable(filterExpression), sorting,
                 pagination.map(p -> p.evaluate(loadClass)), requestScope), requestScope));
 
@@ -369,7 +369,7 @@ public boolean updateAttribute(String fieldName, Object newVal) {
      */
     public boolean updateRelation(String fieldName, Set<PersistentResource> resourceIdentifiers) {
         RelationshipType type = getRelationshipType(fieldName);
-        Set<PersistentResource> resources = filter(ReadPermission.class,
+        Set<PersistentResource> resources = filter(ReadPermission.class, Optional.empty(),
                 getRelationUncheckedUnfiltered(fieldName));
         boolean isUpdated;
         if (type.isToMany()) {
@@ -402,8 +402,8 @@ public boolean updateRelation(String fieldName, Set<PersistentResource> resource
      * @return true if updated. false otherwise
      */
     protected boolean updateToManyRelation(String fieldName,
-                                           Set<PersistentResource> resourceIdentifiers,
-                                           Set<PersistentResource> mine) {
+            Set<PersistentResource> resourceIdentifiers,
+            Set<PersistentResource> mine) {
 
         Set<PersistentResource> requested;
         Set<PersistentResource> updated;
@@ -479,8 +479,8 @@ protected boolean updateToManyRelation(String fieldName,
      * @return true if updated. false otherwise
      */
     protected boolean updateToOneRelation(String fieldName,
-                                          Set<PersistentResource> resourceIdentifiers,
-                                          Set<PersistentResource> mine) {
+            Set<PersistentResource> resourceIdentifiers,
+            Set<PersistentResource> mine) {
         Object newValue = null;
         PersistentResource newResource = null;
         if (CollectionUtils.isNotEmpty(resourceIdentifiers)) {
@@ -527,7 +527,8 @@ protected boolean updateToOneRelation(String fieldName,
      * @return True if object updated, false otherwise
      */
     public boolean clearRelation(String relationName) {
-        Set<PersistentResource> mine = filter(ReadPermission.class, getRelationUncheckedUnfiltered(relationName));
+        Set<PersistentResource> mine = filter(ReadPermission.class, Optional.empty(),
+                getRelationUncheckedUnfiltered(relationName));
         checkFieldAwareDeferPermissions(UpdatePermission.class, relationName, Collections.emptySet(),
                 mine.stream().map(PersistentResource::getObject).collect(Collectors.toSet()));
 
@@ -816,10 +817,10 @@ public PersistentResource getRelation(String relation, String id) {
      * @return PersistentResource relation
      */
     public Set<PersistentResource> getRelation(String relation,
-                                          List<String> ids,
-                                          Optional<FilterExpression> filter,
-                                          Optional<Sorting> sorting,
-                                          Optional<Pagination> pagination) {
+            List<String> ids,
+            Optional<FilterExpression> filter,
+            Optional<Sorting> sorting,
+            Optional<Pagination> pagination) {
 
         FilterExpression filterExpression;
 
@@ -851,8 +852,8 @@ public Set<PersistentResource> getRelation(String relation,
         // TODO: Filter on new resources?
         // TODO: Update pagination to subtract the number of new resources created?
 
-        Set<PersistentResource> existingResources = filter(ReadPermission.class,
-            getRelation(relation, Optional.ofNullable(filterExpression), sorting, pagination, true));
+        Set<PersistentResource> existingResources = filter(ReadPermission.class, filter,
+                getRelation(relation, Optional.ofNullable(filterExpression), sorting, pagination, true));
 
         // TODO: Sort again in memory now that two sets are glommed together?
 
@@ -877,9 +878,9 @@ public Set<PersistentResource> getRelation(String relation,
      * @return Filter expression for given ids and type.
      */
     private static FilterExpression buildIdFilterExpression(List<String> ids,
-                                                            Class<?> entityType,
-                                                            EntityDictionary dictionary,
-                                                            RequestScope scope) {
+            Class<?> entityType,
+            EntityDictionary dictionary,
+            RequestScope scope) {
         Class<?> idType = dictionary.getIdType(entityType);
         String idField = dictionary.getIdFieldName(entityType);
         String typeAlias = dictionary.getJsonAliasFor(entityType);
@@ -907,11 +908,11 @@ private static FilterExpression buildIdFilterExpression(List<String> ids,
      * @return collection relation
      */
     public Set<PersistentResource> getRelationCheckedFiltered(String relationName,
-                                                              Optional<FilterExpression> filterExpression,
-                                                              Optional<Sorting> sorting,
-                                                              Optional<Pagination> pagination) {
+            Optional<FilterExpression> filterExpression,
+            Optional<Sorting> sorting,
+            Optional<Pagination> pagination) {
 
-        return filter(ReadPermission.class,
+        return filter(ReadPermission.class, filterExpression,
                 getRelation(relationName, filterExpression, sorting, pagination, true));
     }
 
@@ -924,10 +925,10 @@ private Set<PersistentResource> getRelationCheckedUnfiltered(String relationName
     }
 
     private Set<PersistentResource> getRelation(String relationName,
-                                                Optional<FilterExpression> filterExpression,
-                                                Optional<Sorting> sorting,
-                                                Optional<Pagination> pagination,
-                                                boolean checked) {
+            Optional<FilterExpression> filterExpression,
+            Optional<Sorting> sorting,
+            Optional<Pagination> pagination,
+            boolean checked) {
 
         if (checked && !checkRelation(relationName)) {
             return Collections.emptySet();
@@ -974,9 +975,9 @@ protected boolean checkRelation(String relationName) {
      * @return collection relation
      */
     protected Set<PersistentResource> getRelationChecked(String relationName,
-                                                         Optional<FilterExpression> filterExpression,
-                                                         Optional<Sorting> sorting,
-                                                         Optional<Pagination> pagination) {
+            Optional<FilterExpression> filterExpression,
+            Optional<Sorting> sorting,
+            Optional<Pagination> pagination) {
         if (!checkRelation(relationName)) {
             return Collections.emptySet();
         }
@@ -994,9 +995,9 @@ protected Set<PersistentResource> getRelationChecked(String relationName,
      * @return the resources in the relationship
      */
     private Set<PersistentResource> getRelationUnchecked(String relationName,
-                                                         Optional<FilterExpression> filterExpression,
-                                                         Optional<Sorting> sorting,
-                                                         Optional<Pagination> pagination) {
+            Optional<FilterExpression> filterExpression,
+            Optional<Sorting> sorting,
+            Optional<Pagination> pagination) {
         RelationshipType type = getRelationshipType(relationName);
         final Class<?> relationClass = dictionary.getParameterizedType(obj, relationName);
         if (relationClass == null) {
@@ -1047,7 +1048,7 @@ private Set<PersistentResource> getRelationUnchecked(String relationName,
      * @return True if collection should be skipped (i.e. denied access), false otherwise
      */
     private static boolean shouldSkipCollection(Class<?> resourceClass, Class<? extends Annotation> annotationClass,
-                                                RequestScope requestScope) {
+            RequestScope requestScope) {
         try {
             requestScope.getPermissionExecutor().checkUserPermissions(resourceClass, annotationClass);
         } catch (ForbiddenAccessException e) {
@@ -1551,13 +1552,15 @@ protected void addInverseRelation(String relationName, Object inverseObj) {
 
     /**
      * Filter a set of PersistentResources.
+     * Verify fields have ReadPermission on filter join.
      *
      * @param permission the permission
      * @param resources  the resources
      * @return Filtered set of resources
      */
     protected static Set<PersistentResource> filter(Class<? extends Annotation> permission,
-                                                    Set<PersistentResource> resources) {
+            Optional<FilterExpression> filter,
+            Set<PersistentResource> resources) {
         Set<PersistentResource> filteredSet = new LinkedHashSet<>();
         for (PersistentResource resource : resources) {
             try {
@@ -1569,6 +1572,11 @@ protected static Set<PersistentResource> filter(Class<? extends Annotation> perm
                 // object will behave as expected.
                 if (!resource.getRequestScope().getNewResources().contains(resource)) {
                     resource.checkFieldAwarePermissions(permission);
+                    // Verify fields have ReadPermission on filter join
+                    if (filter.isPresent()
+                            && !filter.get().accept(new VerifyFieldAccessFilterExpressionVisitor(resource))) {
+                        continue;
+                    }
                 }
                 filteredSet.add(resource);
             } catch (ForbiddenAccessException e) {
@@ -1632,9 +1640,9 @@ private <A extends Annotation> ExpressionResult checkFieldAwareReadPermissions(S
     }
 
     private <A extends Annotation> ExpressionResult checkFieldAwareDeferPermissions(Class<A> annotationClass,
-                                                                        String fieldName,
-                                                                        Object modified,
-                                                                        Object original) {
+            String fieldName,
+            Object modified,
+            Object original) {
         ChangeSpec changeSpec = (UpdatePermission.class.isAssignableFrom(annotationClass))
                 ? new ChangeSpec(this, fieldName, original, modified)
                 : null;
@@ -1645,7 +1653,7 @@ private <A extends Annotation> ExpressionResult checkFieldAwareDeferPermissions(
     }
 
     protected static boolean checkIncludeSparseField(Map<String, Set<String>> sparseFields, String type,
-                                                     String fieldName) {
+            String fieldName) {
         if (!sparseFields.isEmpty()) {
             if (!sparseFields.containsKey(type)) {
                 return false;