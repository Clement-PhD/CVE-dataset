@@ -67,14 +67,22 @@ pub fn download(config: &DownloadConfig) -> Result<()> {
         // check the old signature.  If we didn't decompress last time but are
         // decompressing this time, we're not smart enough to decompress the
         // existing file.
-        if !config.decompress && check_image_and_sig(source, &path, &sig_path).is_ok() {
+        if !config.decompress
+            && check_image_and_sig(source, &path, &sig_path, VerifyKeys::Production).is_ok()
+        {
             // report the output file path and keep going
             println!("{}", path.display());
             continue;
         }
 
         // write the image and signature
-        if let Err(err) = write_image_and_sig(&mut source, &path, &sig_path, config.decompress) {
+        if let Err(err) = write_image_and_sig(
+            &mut source,
+            &path,
+            &sig_path,
+            config.decompress,
+            VerifyKeys::Production,
+        ) {
             // delete output files, which may not have been created yet
             let _ = remove_file(&path);
             let _ = remove_file(&sig_path);
@@ -93,7 +101,12 @@ pub fn download(config: &DownloadConfig) -> Result<()> {
 // Check an existing image and signature for validity.  The image cannot
 // have been decompressed after downloading.  Return an error if invalid for
 // any reason.
-fn check_image_and_sig(source: &ImageSource, path: &Path, sig_path: &Path) -> Result<()> {
+fn check_image_and_sig(
+    source: &ImageSource,
+    path: &Path,
+    sig_path: &Path,
+    keys: VerifyKeys,
+) -> Result<()> {
     // ensure we have something to check
     if source.signature.is_none() {
         bail!("no signature available; can't check existing file");
@@ -120,7 +133,7 @@ fn check_image_and_sig(source: &ImageSource, path: &Path, sig_path: &Path) -> Re
         .with_context(|| format!("opening {}", path.display()))?;
 
     // perform GPG verification
-    GpgReader::new(&mut file, signature)?.consume()?;
+    GpgReader::new(&mut file, signature, keys)?.consume()?;
 
     Ok(())
 }
@@ -131,6 +144,7 @@ fn write_image_and_sig(
     path: &Path,
     sig_path: &Path,
     decompress: bool,
+    keys: VerifyKeys,
 ) -> Result<()> {
     // open output
     let mut dest = OpenOptions::new()
@@ -150,6 +164,7 @@ fn write_image_and_sig(
         decompress,
         None,
         None,
+        keys,
     )?;
 
     // write signature, if relevant
@@ -169,6 +184,7 @@ fn write_image_and_sig(
 }
 
 /// Copy the image to disk and verify its signature.
+#[allow(clippy::too_many_arguments)]
 pub fn write_image<F>(
     source: &mut ImageSource,
     dest: &mut File,
@@ -177,14 +193,15 @@ pub fn write_image<F>(
     decompress: bool,
     saved: Option<&SavedPartitions>,
     expected_sector_size: Option<NonZeroU32>,
+    keys: VerifyKeys,
 ) -> Result<()>
 where
     F: FnOnce(&[u8], &mut dyn Read, &mut File, &Path, Option<&SavedPartitions>) -> Result<()>,
 {
     // wrap source for GPG verification
     let mut verify_reader: Box<dyn Read> = {
         if let Some(signature) = source.signature.as_ref() {
-            Box::new(GpgReader::new(&mut source.reader, signature)?)
+            Box::new(GpgReader::new(&mut source.reader, signature, keys)?)
         } else {
             Box::new(&mut source.reader)
         }
@@ -447,9 +464,107 @@ impl<'a, R: Read> Drop for ProgressReader<'a, R> {
 mod tests {
     use super::*;
     use gptman::{GPTPartitionEntry, GPT};
+    use std::fs::{read, write};
     use std::io::{Seek, SeekFrom};
+    use tempfile::TempDir;
     use uuid::Uuid;
 
+    /// Test that the fetch pipeline notices a bad signature
+    #[test]
+    fn test_signature_checks() {
+        test_one_signed_file(
+            &[0; 1 << 20][..],
+            &include_bytes!("../fixtures/verify/1M.sig")[..],
+            &[0; 1 << 20][..],
+        );
+        test_one_signed_file(
+            &include_bytes!("../fixtures/verify/1M.gz")[..],
+            &include_bytes!("../fixtures/verify/1M.gz.sig")[..],
+            &[0; 1 << 20][..],
+        );
+        test_one_signed_file(
+            &include_bytes!("../fixtures/verify/1M.xz")[..],
+            &include_bytes!("../fixtures/verify/1M.xz.sig")[..],
+            &[0; 1 << 20][..],
+        );
+    }
+
+    fn test_one_signed_file(data: &[u8], sig: &[u8], decompressed_data: &[u8]) {
+        // set up input files
+        let dir = TempDir::new().unwrap();
+        let good_path = dir.path().join("good");
+        write(&good_path, data).unwrap();
+        let good_sig_path = dir.path().join("good.sig");
+        write(&good_sig_path, sig).unwrap();
+        let bad_path = dir.path().join("bad");
+        let mut bad_data = data.to_vec();
+        bad_data.push(0);
+        write(&bad_path, &bad_data).unwrap();
+        // same contents as good_sig_path, different path
+        let bad_sig_path = dir.path().join("bad.sig");
+        write(&bad_sig_path, sig).unwrap();
+
+        // check existing copy
+        let source = FileLocation::new(good_path.to_str().unwrap())
+            .sources()
+            .unwrap()
+            .remove(0);
+        check_image_and_sig(
+            &source,
+            &good_path,
+            &good_sig_path,
+            VerifyKeys::InsecureTest,
+        )
+        .unwrap();
+
+        // check existing copy with bad sig
+        let source = FileLocation::new(bad_path.to_str().unwrap())
+            .sources()
+            .unwrap()
+            .remove(0);
+        check_image_and_sig(&source, &bad_path, &bad_sig_path, VerifyKeys::InsecureTest)
+            .unwrap_err();
+
+        // new copy
+        let mut source = FileLocation::new(good_path.to_str().unwrap())
+            .sources()
+            .unwrap()
+            .remove(0);
+        let out_path = dir.path().join("out");
+        let mut out_file = File::create(&out_path).unwrap();
+        write_image(
+            &mut source,
+            &mut out_file,
+            &out_path,
+            image_copy_default,
+            true,
+            None,
+            None,
+            VerifyKeys::InsecureTest,
+        )
+        .unwrap();
+        assert_eq!(&read(&out_path).unwrap(), decompressed_data);
+
+        // new copy with bad sig
+        let mut source = FileLocation::new(bad_path.to_str().unwrap())
+            .sources()
+            .unwrap()
+            .remove(0);
+        let out_path = dir.path().join("out");
+        let mut out_file = File::create(&out_path).unwrap();
+        write_image(
+            &mut source,
+            &mut out_file,
+            &out_path,
+            image_copy_default,
+            true,
+            None,
+            None,
+            VerifyKeys::InsecureTest,
+        )
+        .unwrap_err();
+    }
+
     #[test]
     fn test_write_image_limit() {
         // source must be partitioned if we're saving partitions
@@ -492,6 +607,7 @@ mod tests {
             false,
             Some(&saved),
             None,
+            VerifyKeys::InsecureTest,
         )
         .unwrap_err();
         assert!(