@@ -9,10 +9,12 @@ import (
 	"errors"
 	"fmt"
 	"net/http"
+	"net/url"
+	"strings"
 
 	"github.com/go-vela/server/random"
-
 	"github.com/go-vela/types/library"
+	"github.com/google/go-github/v33/github"
 
 	"github.com/sirupsen/logrus"
 )
@@ -110,6 +112,49 @@ func (c *client) AuthenticateToken(r *http.Request) (*library.User, error) {
 		return nil, errors.New("no token provided")
 	}
 
+	// create http client to connect to GitHub
+	//
+	// nolint: lll // ignore long line length due to variable names
+	transport := github.BasicAuthTransport{Username: c.OConfig.ClientID, Password: c.OConfig.ClientSecret}
+	// create client to connect to GitHub API
+	client := github.NewClient(transport.Client())
+	// check if github url was set
+	if c.URL != "" && c.URL != "https://github.com" {
+		// check if address has trailing slash
+		if !strings.HasSuffix(c.URL, "/") {
+			// add trailing slash
+			c.URL = c.URL + "/api/v3/"
+		}
+		// parse the provided url into url type
+		enterpriseURL, err := url.Parse(c.URL)
+		if err != nil {
+			return nil, err
+		}
+		// set the base and upload url
+		client.BaseURL = enterpriseURL
+		client.UploadURL = enterpriseURL
+	}
+	// check if the provided token was created by Vela
+	_, resp, err := client.Authorizations.Check(context.Background(), c.OConfig.ClientID, token)
+	// check if the error is of type ErrorResponse
+	if gerr, ok := err.(*github.ErrorResponse); ok {
+		// check the status code
+		switch gerr.Response.StatusCode {
+		// 404 is expected when non vela token is used
+		case http.StatusNotFound:
+			break
+		default:
+			return nil, err
+		}
+	} else if err != nil {
+		return nil, err
+	}
+
+	// return error if the token was created by Vela
+	if resp.StatusCode != http.StatusNotFound {
+		return nil, errors.New("token must not be created by vela")
+	}
+
 	u, err := c.Authorize(token)
 	if err != nil {
 		return nil, err