@@ -25,6 +25,7 @@
 import ca.uhn.fhir.interceptor.api.IInterceptorBroadcaster;
 import ca.uhn.fhir.interceptor.api.Pointcut;
 import ca.uhn.fhir.interceptor.model.RequestPartitionId;
+import ca.uhn.fhir.jpa.api.config.DaoConfig;
 import ca.uhn.fhir.jpa.api.dao.DaoRegistry;
 import ca.uhn.fhir.jpa.api.dao.IFhirResourceDao;
 import ca.uhn.fhir.jpa.api.svc.ISearchCoordinatorSvc;
@@ -34,21 +35,22 @@
 import ca.uhn.fhir.jpa.dao.SearchBuilderFactory;
 import ca.uhn.fhir.jpa.entity.Search;
 import ca.uhn.fhir.jpa.entity.SearchTypeEnum;
-import ca.uhn.fhir.jpa.search.cache.SearchCacheStatusEnum;
-import ca.uhn.fhir.rest.api.server.storage.ResourcePersistentId;
 import ca.uhn.fhir.jpa.model.entity.BaseHasResource;
 import ca.uhn.fhir.jpa.model.entity.ResourceHistoryTable;
 import ca.uhn.fhir.jpa.partition.RequestPartitionHelperSvc;
 import ca.uhn.fhir.jpa.search.cache.ISearchCacheSvc;
+import ca.uhn.fhir.jpa.search.cache.SearchCacheStatusEnum;
 import ca.uhn.fhir.jpa.util.InterceptorUtil;
 import ca.uhn.fhir.jpa.util.JpaInterceptorBroadcaster;
+import ca.uhn.fhir.jpa.util.MemoryCacheService;
 import ca.uhn.fhir.model.primitive.InstantDt;
 import ca.uhn.fhir.rest.api.server.IBundleProvider;
 import ca.uhn.fhir.rest.api.server.IPreResourceAccessDetails;
 import ca.uhn.fhir.rest.api.server.IPreResourceShowDetails;
 import ca.uhn.fhir.rest.api.server.RequestDetails;
 import ca.uhn.fhir.rest.api.server.SimplePreResourceAccessDetails;
 import ca.uhn.fhir.rest.api.server.SimplePreResourceShowDetails;
+import ca.uhn.fhir.rest.api.server.storage.ResourcePersistentId;
 import ca.uhn.fhir.rest.server.servlet.ServletRequestDetails;
 import com.google.common.annotations.VisibleForTesting;
 import org.hl7.fhir.instance.model.api.IBaseResource;
@@ -70,6 +72,7 @@
 import java.util.List;
 import java.util.Optional;
 import java.util.Set;
+import java.util.function.Function;
 
 public class PersistedJpaBundleProvider implements IBundleProvider {
 
@@ -78,7 +81,9 @@ public class PersistedJpaBundleProvider implements IBundleProvider {
 	/*
 	 * Autowired fields
 	 */
-
+	private final RequestDetails myRequest;
+	@Autowired
+	protected PlatformTransactionManager myTxManager;
 	@PersistenceContext
 	private EntityManager myEntityManager;
 	@Autowired
@@ -90,22 +95,22 @@ public class PersistedJpaBundleProvider implements IBundleProvider {
 	@Autowired
 	private DaoRegistry myDaoRegistry;
 	@Autowired
-	protected PlatformTransactionManager myTxManager;
-	@Autowired
 	private FhirContext myContext;
 	@Autowired
 	private ISearchCoordinatorSvc mySearchCoordinatorSvc;
 	@Autowired
 	private ISearchCacheSvc mySearchCacheSvc;
 	@Autowired
 	private RequestPartitionHelperSvc myRequestPartitionHelperSvc;
+	@Autowired
+	private DaoConfig myDaoConfig;
 
 	/*
 	 * Non autowired fields (will be different for every instance
 	 * of this class, since it's a prototype
 	 */
-
-	private final RequestDetails myRequest;
+	@Autowired
+	private MemoryCacheService myMemoryCacheService;
 	private Search mySearchEntity;
 	private String myUuid;
 	private SearchCacheStatusEnum myCacheStatus;
@@ -241,17 +246,57 @@ public boolean ensureSearchEntityLoaded() {
 
 		if (mySearchEntity.getSearchType() == SearchTypeEnum.HISTORY) {
 			if (mySearchEntity.getTotalCount() == null) {
-				new TransactionTemplate(myTxManager).executeWithoutResult(t->{
-					HistoryBuilder historyBuilder = myHistoryBuilderFactory.newHistoryBuilder(mySearchEntity.getResourceType(), mySearchEntity.getResourceId(), mySearchEntity.getLastUpdatedLow(), mySearchEntity.getLastUpdatedHigh());
-					Long count = historyBuilder.fetchCount(getRequestPartitionId());
-					mySearchEntity.setTotalCount(count.intValue());
-				});
+				calculateHistoryCount();
 			}
 		}
 
 		return true;
 	}
 
+	/**
+	 * Note that this method is called outside a DB transaction, and uses a loading cache
+	 * (assuming the default {@literal COUNT_CACHED} mode) so this effectively throttles
+	 * access to the database by preventing multiple concurrent DB calls for an expensive
+	 * count operation.
+	 */
+	private void calculateHistoryCount() {
+		MemoryCacheService.HistoryCountKey key;
+		if (mySearchEntity.getResourceId() != null) {
+			key = MemoryCacheService.HistoryCountKey.forInstance(mySearchEntity.getResourceId());
+		} else if (mySearchEntity.getResourceType() != null) {
+			key = MemoryCacheService.HistoryCountKey.forType(mySearchEntity.getResourceType());
+		} else {
+			key = MemoryCacheService.HistoryCountKey.forSystem();
+		}
+
+		Function<MemoryCacheService.HistoryCountKey, Integer> supplier = k -> new TransactionTemplate(myTxManager).execute(t -> {
+			HistoryBuilder historyBuilder = myHistoryBuilderFactory.newHistoryBuilder(mySearchEntity.getResourceType(), mySearchEntity.getResourceId(), mySearchEntity.getLastUpdatedLow(), mySearchEntity.getLastUpdatedHigh());
+			Long count = historyBuilder.fetchCount(getRequestPartitionId());
+			return count.intValue();
+		});
+
+		boolean haveOffset = mySearchEntity.getLastUpdatedLow() != null || mySearchEntity.getLastUpdatedHigh() != null;
+
+		switch (myDaoConfig.getHistoryCountMode()) {
+			case COUNT_ACCURATE: {
+				int count = supplier.apply(key);
+				mySearchEntity.setTotalCount(count);
+				break;
+			}
+			case CACHED_ONLY_WITHOUT_OFFSET: {
+				if (!haveOffset) {
+					int count = myMemoryCacheService.get(MemoryCacheService.CacheEnum.HISTORY_COUNT, key, supplier);
+					mySearchEntity.setTotalCount(count);
+				}
+				break;
+			}
+			case COUNT_DISABLED: {
+				break;
+			}
+		}
+
+	}
+
 	@Override
 	public InstantDt getPublished() {
 		ensureSearchEntityLoaded();