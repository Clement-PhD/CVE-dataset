@@ -1197,6 +1197,7 @@ try // clang-format on
     InfoReply response;
 
     fmt::memory_buffer errors;
+    bool have_mounts = false;
     std::vector<decltype(vm_instances)::key_type> instances_for_info;
 
     if (request->instance_names().instance_name().empty())
@@ -1263,24 +1264,30 @@ try // clang-format on
 
         mount_info->set_longest_path_len(0);
 
-        for (const auto& mount : vm_specs.mounts)
+        if (!vm_specs.mounts.empty())
+            have_mounts = true;
+
+        if (MP_SETTINGS.get_as<bool>(mp::mounts_key))
         {
-            if (mount.second.source_path.size() > mount_info->longest_path_len())
+            for (const auto& mount : vm_specs.mounts)
             {
-                mount_info->set_longest_path_len(mount.second.source_path.size());
-            }
+                if (mount.second.source_path.size() > mount_info->longest_path_len())
+                {
+                    mount_info->set_longest_path_len(mount.second.source_path.size());
+                }
 
-            auto entry = mount_info->add_mount_paths();
-            entry->set_source_path(mount.second.source_path);
-            entry->set_target_path(mount.first);
+                auto entry = mount_info->add_mount_paths();
+                entry->set_source_path(mount.second.source_path);
+                entry->set_target_path(mount.first);
 
-            for (const auto& uid_map : mount.second.uid_map)
-            {
-                (*entry->mutable_mount_maps()->mutable_uid_map())[uid_map.first] = uid_map.second;
-            }
-            for (const auto& gid_map : mount.second.gid_map)
-            {
-                (*entry->mutable_mount_maps()->mutable_gid_map())[gid_map.first] = gid_map.second;
+                for (const auto& uid_map : mount.second.uid_map)
+                {
+                    (*entry->mutable_mount_maps()->mutable_uid_map())[uid_map.first] = uid_map.second;
+                }
+                for (const auto& gid_map : mount.second.gid_map)
+                {
+                    (*entry->mutable_mount_maps()->mutable_gid_map())[gid_map.first] = gid_map.second;
+                }
             }
         }
 
@@ -1314,6 +1321,9 @@ try // clang-format on
         }
     }
 
+    if (have_mounts && !MP_SETTINGS.get_as<bool>(mp::mounts_key))
+        mpl::log(mpl::Level::error, category, "Mounts have been disabled on this instance of Multipass");
+
     auto status = grpc_status_for(errors);
     if (status.ok())
         server->Write(response);
@@ -1425,6 +1435,15 @@ try // clang-format on
 {
     mpl::ClientLogger<MountReply> logger{mpl::level_from(request->verbosity_level()), *config->logger, server};
 
+    if (!MP_SETTINGS.get_as<bool>(mp::mounts_key))
+    {
+        return status_promise->set_value(
+            grpc::Status(grpc::StatusCode::FAILED_PRECONDITION,
+                         "Mounts are disabled on this installation of Multipass.\n\n"
+                         "See https://multipass.run/docs/set-command#local.privileged-mounts for information\n"
+                         "on how to enable them."));
+    }
+
     QFileInfo source_dir(QString::fromStdString(request->source_path()));
     if (!source_dir.exists())
     {
@@ -1644,6 +1663,7 @@ try // clang-format on
 
     mp::StartError start_error;
     auto* errors = start_error.mutable_instance_errors();
+    bool have_mounts = false;
 
     std::vector<decltype(vm_instances)::key_type> vms;
     for (const auto& name : request->instance_names().instance_name())
@@ -1653,16 +1673,24 @@ try // clang-format on
             errors->insert({name, deleted_instances.find(name) == deleted_instances.end()
                                       ? mp::StartError::DOES_NOT_EXIST
                                       : mp::StartError::INSTANCE_DELETED});
-        else if (it->second->current_state() == VirtualMachine::State::delayed_shutdown)
-            delayed_shutdown_instances.erase(name);
-        else if (it->second->current_state() != VirtualMachine::State::running)
-            vms.push_back(name);
+        else
+        {
+            if (!vm_instance_specs[name].mounts.empty())
+                have_mounts = true;
+            if (it->second->current_state() == VirtualMachine::State::delayed_shutdown)
+                delayed_shutdown_instances.erase(name);
+            else if (it->second->current_state() != VirtualMachine::State::running)
+                vms.push_back(name);
+        }
     }
 
     if (start_error.instance_errors_size())
         return status_promise->set_value(
             grpc::Status(grpc::StatusCode::ABORTED, "instance(s) missing", start_error.SerializeAsString()));
 
+    if (have_mounts && !MP_SETTINGS.get_as<bool>(mp::mounts_key))
+        mpl::log(mpl::Level::error, category, "Mounts have been disabled on this instance of Multipass");
+
     if (request->instance_names().instance_name().empty())
     {
         for (auto& pair : vm_instances)
@@ -2428,48 +2456,51 @@ error_string mp::Daemon::async_wait_for_ssh_and_start_mounts_for(const std::stri
             MP_UTILS.wait_for_cloud_init(vm.get(), timeout, *config->ssh_key_provider);
         }
 
-        std::vector<std::string> invalid_mounts;
-        auto& mounts = vm_instance_specs[name].mounts;
-        auto& vm_specs = vm_instance_specs[name];
-        for (const auto& mount_entry : mounts)
+        if (MP_SETTINGS.get_as<bool>(mp::mounts_key))
         {
-            auto& target_path = mount_entry.first;
-            auto& source_path = mount_entry.second.source_path;
-            auto& uid_map = mount_entry.second.uid_map;
-            auto& gid_map = mount_entry.second.gid_map;
-
-            try
-            {
-                instance_mounts.start_mount(vm.get(), source_path, target_path, gid_map, uid_map);
-            }
-            catch (const mp::SSHFSMissingError&)
+            std::vector<std::string> invalid_mounts;
+            auto& mounts = vm_instance_specs[name].mounts;
+            auto& vm_specs = vm_instance_specs[name];
+            for (const auto& mount_entry : mounts)
             {
+                auto& target_path = mount_entry.first;
+                auto& source_path = mount_entry.second.source_path;
+                auto& uid_map = mount_entry.second.uid_map;
+                auto& gid_map = mount_entry.second.gid_map;
+
                 try
                 {
-                    if (server)
-                    {
-                        Reply reply;
-                        reply.set_reply_message("Enabling support for mounting");
-                        server->Write(reply);
-                    }
-
-                    mp::SSHSession session{vm->ssh_hostname(), vm->ssh_port(), vm_specs.ssh_username,
-                                           *config->ssh_key_provider};
-                    mp::utils::install_sshfs_for(name, session);
                     instance_mounts.start_mount(vm.get(), source_path, target_path, gid_map, uid_map);
                 }
                 catch (const mp::SSHFSMissingError&)
                 {
-                    fmt::format_to(errors, sshfs_error_template + "\n", name);
-                    break;
+                    try
+                    {
+                        if (server)
+                        {
+                            Reply reply;
+                            reply.set_reply_message("Enabling support for mounting");
+                            server->Write(reply);
+                        }
+
+                        mp::SSHSession session{vm->ssh_hostname(), vm->ssh_port(), vm_specs.ssh_username,
+                                               *config->ssh_key_provider};
+                        mp::utils::install_sshfs_for(name, session);
+                        instance_mounts.start_mount(vm.get(), source_path, target_path, gid_map, uid_map);
+                    }
+                    catch (const mp::SSHFSMissingError&)
+                    {
+                        fmt::format_to(errors, sshfs_error_template + "\n", name);
+                        break;
+                    }
                 }
+                catch (const std::exception& e)
+                {
+                    fmt::format_to(errors, "Removing \"{}\": {}\n", target_path, e.what());
+                    invalid_mounts.push_back(target_path);
+                }
+                persist_instances();
             }
-            catch (const std::exception& e)
-            {
-                fmt::format_to(errors, "Removing \"{}\": {}\n", target_path, e.what());
-                invalid_mounts.push_back(target_path);
-            }
-            persist_instances();
         }
     }
     catch (const std::exception& e)