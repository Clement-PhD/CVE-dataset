@@ -106,6 +106,8 @@ struct Client : public Test
         EXPECT_CALL(mock_settings, get(_)).Times(AnyNumber()); /* Admit get calls beyond explicitly expected in tests.
                                                                   This allows general actions to consult settings
                                                                   (e.g. Windows Terminal profile sync) */
+        EXPECT_CALL(mock_settings, get(Eq(mp::mounts_key)))
+            .WillRepeatedly(Return("true")); // Tests assume this default, but platforms may override.
         EXPECT_CALL(mpt::MockStandardPaths::mock_instance(), locate(_, _, _))
             .Times(AnyNumber()); // needed to allow general calls once we have added the specific expectation below
         EXPECT_CALL(mpt::MockStandardPaths::mock_instance(),
@@ -430,6 +432,21 @@ TEST_F(Client, shell_cmd_automounts_when_launching_petenv)
     EXPECT_THAT(send_command({"shell", petenv_name()}), Eq(mp::ReturnCode::Ok));
 }
 
+TEST_F(Client, shellCmdSkipsAutomountWhenDisabled)
+{
+    std::stringstream cout_stream;
+    const grpc::Status ok{}, notfound{grpc::StatusCode::NOT_FOUND, "msg"};
+    EXPECT_CALL(mock_settings, get(Eq(mp::mounts_key))).WillRepeatedly(Return("false"));
+
+    InSequence seq;
+    EXPECT_CALL(mock_daemon, ssh_info(_, _, _)).WillOnce(Return(notfound));
+    EXPECT_CALL(mock_daemon, launch(_, _, _)).WillOnce(Return(ok));
+    EXPECT_CALL(mock_daemon, mount(_, _, _)).Times(0);
+    EXPECT_CALL(mock_daemon, ssh_info(_, _, _)).WillOnce(Return(ok));
+    EXPECT_THAT(send_command({"shell", petenv_name()}, cout_stream, trash_stream), Eq(mp::ReturnCode::Ok));
+    EXPECT_THAT(cout_stream.str(), HasSubstr("Skipping 'Home' mount due to disabled mounts feature\n"));
+}
+
 TEST_F(Client, shell_cmd_forwards_verbosity_to_subcommands)
 {
     const grpc::Status ok{}, notfound{grpc::StatusCode::NOT_FOUND, "msg"};
@@ -1145,6 +1162,33 @@ TEST_F(Client, start_cmd_automounts_when_launching_petenv)
     EXPECT_THAT(send_command({"start", petenv_name()}), Eq(mp::ReturnCode::Ok));
 }
 
+TEST_F(Client, startCmdSkipsAutomountWhenDisabled)
+{
+    std::stringstream cout_stream;
+    const grpc::Status ok{}, aborted = aborted_start_status({petenv_name()});
+    EXPECT_CALL(mock_settings, get(Eq(mp::mounts_key))).WillRepeatedly(Return("false"));
+
+    InSequence seq;
+    EXPECT_CALL(mock_daemon, start(_, _, _)).WillOnce(Return(aborted));
+    EXPECT_CALL(mock_daemon, launch(_, _, _)).WillOnce(Return(ok));
+    EXPECT_CALL(mock_daemon, mount(_, _, _)).Times(0);
+    EXPECT_CALL(mock_daemon, start(_, _, _)).WillOnce(Return(ok));
+    EXPECT_THAT(send_command({"start", petenv_name()}, cout_stream, trash_stream), Eq(mp::ReturnCode::Ok));
+    EXPECT_THAT(cout_stream.str(), HasSubstr("Skipping 'Home' mount due to disabled mounts feature\n"));
+}
+
+TEST_F(Client, launchCmdOnlyWarnsMountForPetEnv)
+{
+    const auto invalid_argument = grpc::Status{grpc::StatusCode::INVALID_ARGUMENT, "msg"};
+    std::stringstream cout_stream;
+    EXPECT_CALL(mock_settings, get(Eq(mp::mounts_key))).WillRepeatedly(Return("false"));
+    EXPECT_CALL(mock_daemon, launch(_, _, _)).WillOnce(Return(invalid_argument));
+
+    EXPECT_THAT(send_command({"launch", "--name", ".asdf"}, cout_stream, trash_stream),
+                Eq(mp::ReturnCode::CommandFail));
+    EXPECT_THAT(cout_stream.str(), Not(HasSubstr("Skipping 'Home' mount due to disabled mounts feature\n")));
+}
+
 TEST_F(Client, start_cmd_forwards_verbosity_to_subcommands)
 {
     const grpc::Status ok{}, aborted = aborted_start_status({petenv_name()});
@@ -1680,7 +1724,7 @@ TEST_P(TestBasicGetSetOptions, set_cmd_allows_empty_val)
 
 INSTANTIATE_TEST_SUITE_P(Client, TestBasicGetSetOptions,
                          Values(mp::petenv_key, mp::driver_key, mp::autostart_key, mp::hotkey_key,
-                                mp::bridged_interface_key));
+                                mp::bridged_interface_key, mp::mounts_key));
 
 TEST_F(Client, get_cmd_fails_with_no_arguments)
 {
@@ -1943,6 +1987,31 @@ TEST_F(Client, get_and_set_can_read_and_write_winterm_integration)
 
 #endif // #ifndef MULTIPASS_PLATFORM_WINDOWS
 
+TEST_F(Client, getReturnsAcceptableMountsValueByDefault)
+{
+    EXPECT_THAT(get_setting(mp::mounts_key), AnyOf("true", "false"));
+}
+
+TEST_F(Client, setCmdRejectsBadMountsValues)
+{
+    aux_set_cmd_rejects_bad_val(mp::mounts_key, "asdf");
+    aux_set_cmd_rejects_bad_val(mp::mounts_key, "trueasdf");
+    aux_set_cmd_rejects_bad_val(mp::mounts_key, "123");
+    aux_set_cmd_rejects_bad_val(mp::mounts_key, "");
+}
+
+TEST_F(Client, getAndSetCanReadAndWriteMountsFlag)
+{
+    const auto orig = get_setting((mp::mounts_key));
+    const auto novel = negate_flag_string(orig);
+
+    EXPECT_CALL(mock_settings, set(Eq(mp::mounts_key), Eq(QString::fromStdString(novel))));
+    EXPECT_THAT(send_command({"set", keyval_arg(mp::mounts_key, novel)}), Eq(mp::ReturnCode::Ok));
+
+    EXPECT_CALL(mock_settings, get(Eq(mp::mounts_key))).WillRepeatedly(Return(QString::fromStdString(novel)));
+    EXPECT_THAT(get_setting(mp::mounts_key), Eq(novel));
+}
+
 // general help tests
 TEST_F(Client, help_returns_ok_return_code)
 {