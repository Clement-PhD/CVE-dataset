--- /dev/null
+++ /dev/null
@@ -1,94 +1,29 @@
 package template
 
 import (
-	"bytes"
 	"encoding/json"
-	"fmt"
-	"io"
-	"reflect"
-
-	log "github.com/sirupsen/logrus"
-
-	"github.com/valyala/fasttemplate"
-
-	exprenv "github.com/argoproj/argo-workflows/v3/util/expr/env"
+	"errors"
 )
 
-const (
-	prefix = "{{"
-	suffix = "}}"
-)
-
-func replace(v interface{}, f func(string) (string, error)) (interface{}, error) {
-	switch x := v.(type) {
-	case string:
-		y, err := f(x)
-		return y, err
-	case []interface{}:
-		for m, n := range x {
-			y, err := replace(n, f)
-			if err != nil {
-				return nil, err
-			}
-			x[m] = y
-		}
-		return x, nil
-	case map[string]interface{}:
-		for m, n := range x {
-			y, err := replace(n, f)
-			if err != nil {
-				return nil, err
-			}
-			x[m] = y
-		}
-		return x, nil
-	default:
-		// int, float etc
-		return v, nil
+// Replace takes a json-formatted string and performs variable replacement.
+func Replace(s string, replaceMap map[string]string, allowUnresolved bool) (string, error) {
+	if !json.Valid([]byte(s)) {
+		return "", errors.New("cannot do template replacements with invalid JSON")
 	}
-}
 
-func Replace(obj interface{}, replaceMap map[string]string, allowUnresolved bool) error {
-	switch kind := reflect.ValueOf(obj).Kind(); kind {
-	case reflect.Ptr, reflect.Slice, reflect.Map:
-	default:
-		return fmt.Errorf("obj must be pointer, slice or map, but is %q", kind)
-	}
-	data, err := json.Marshal(obj)
+	t, err := NewTemplate(s)
 	if err != nil {
-		return err
+		return "", err
 	}
-	log.Debugf("replacing %T; %q", obj, data)
-	var x interface{}
-	if err := json.Unmarshal(data, &x); err != nil {
-		return err
-	}
-	replaceText := func(text string) (string, error) {
-		template, err := fasttemplate.NewTemplate(text, prefix, suffix)
-		if err != nil {
-			return "", err
-		}
-		replacedTmpl := &bytes.Buffer{}
-		_, err = template.ExecuteFunc(replacedTmpl, func(w io.Writer, tag string) (int, error) {
-			kind, expression := parseTag(tag)
-			switch kind {
-			case kindExpression:
-				env := exprenv.GetFuncMap(envMap(replaceMap))
-				return expressionReplace(w, expression, env, allowUnresolved)
-			default:
-				return simpleReplace(w, tag, replaceMap, allowUnresolved)
-			}
-		})
-		return replacedTmpl.String(), err
-	}
-	y, err := replace(x, replaceText)
+
+	replacedString, err := t.Replace(replaceMap, allowUnresolved)
 	if err != nil {
-		return err
+		return s, err
 	}
-	data, err = json.Marshal(y)
-	if err != nil {
-		return err
+
+	if !json.Valid([]byte(replacedString)) {
+		return s, errors.New("cannot finish template replacement because the result was invalid JSON")
 	}
-	log.Debugf("replaced  %T: %q", obj, data)
-	return json.Unmarshal(data, &obj)
+
+	return replacedString, nil
 
