@@ -29,15 +29,19 @@
 import java.util.Collection;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
+import java.util.Optional;
 import java.util.concurrent.CancellationException;
 import java.util.concurrent.CompletableFuture;
 import java.util.function.Function;
 
 import javax.annotation.Nullable;
 
+import com.fasterxml.jackson.databind.JsonNode;
 import com.google.common.base.Throwables;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.Streams;
 
 import com.linecorp.armeria.common.HttpHeaderNames;
 import com.linecorp.armeria.common.HttpResponse;
@@ -76,6 +80,8 @@
 import com.linecorp.centraldogma.server.internal.api.converter.QueryRequestConverter;
 import com.linecorp.centraldogma.server.internal.api.converter.WatchRequestConverter;
 import com.linecorp.centraldogma.server.internal.api.converter.WatchRequestConverter.WatchRequest;
+import com.linecorp.centraldogma.server.internal.storage.repository.DefaultMetaRepository;
+import com.linecorp.centraldogma.server.storage.project.Project;
 import com.linecorp.centraldogma.server.storage.project.ProjectManager;
 import com.linecorp.centraldogma.server.storage.repository.FindOption;
 import com.linecorp.centraldogma.server.storage.repository.FindOptions;
@@ -90,6 +96,8 @@
 @ExceptionHandler(HttpApiExceptionHandler.class)
 public class ContentServiceV1 extends AbstractService {
 
+    private static final String MIRROR_LOCAL_REPO = "localRepo";
+
     private final WatchService watchService;
 
     public ContentServiceV1(ProjectManager projectManager, CommandExecutor executor,
@@ -177,6 +185,7 @@ public CompletableFuture<PushResultDto> push(
             Author author,
             CommitMessageDto commitMessage,
             @RequestConverter(ChangesRequestConverter.class) Iterable<Change<?>> changes) {
+        checkMirrorLocalRepo(repository.name(), changes);
 
         final long commitTimeMillis = System.currentTimeMillis();
         return push(commitTimeMillis, author, repository, new Revision(revision), commitMessage, changes)
@@ -390,4 +399,41 @@ public <T> CompletableFuture<MergedEntryDto<T>> mergeFiles(
             @RequestConverter(MergeQueryRequestConverter.class) MergeQuery<T> query) {
         return repository.mergeFiles(new Revision(revision), query).thenApply(DtoConverter::convert);
     }
+
+    /**
+     * Checks if the commit is for mirroring setting and raises an exception if the {@code localRepo} field
+     * is one of {@code meta} and {@code dogma} which are internal repositories.
+     */
+    public static void checkMirrorLocalRepo(String repoName, Iterable<Change<?>> changes) {
+        // TODO(minwoox): Provide an internal API for mirroring setup with a better UI(?) and check this there.
+        if (Project.REPO_META.equals(repoName)) {
+            final Optional<String> notAllowedLocalRepo =
+                    Streams.stream(changes)
+                           .filter(change -> DefaultMetaRepository.PATH_MIRRORS.equals(change.path()))
+                           .filter(change -> change.content() != null)
+                           .map(change -> {
+                               final Object content = change.content();
+                               if (content instanceof JsonNode) {
+                                   final JsonNode node = (JsonNode) content;
+                                   if (!node.isArray()) {
+                                       return null;
+                                   }
+                                   for (JsonNode jsonNode : node) {
+                                       final JsonNode localRepoNode = jsonNode.get(MIRROR_LOCAL_REPO);
+                                       if (localRepoNode != null) {
+                                           final String localRepo = localRepoNode.textValue();
+                                           if (Project.isReservedRepoName(localRepo)) {
+                                               return localRepo;
+                                           }
+                                       }
+                                   }
+                               }
+                               return null;
+                           }).filter(Objects::nonNull).findFirst();
+            if (notAllowedLocalRepo.isPresent()) {
+                throw new IllegalArgumentException("invalid " + MIRROR_LOCAL_REPO + ": " +
+                                                   notAllowedLocalRepo.get());
+            }
+        }
+    }
 }
