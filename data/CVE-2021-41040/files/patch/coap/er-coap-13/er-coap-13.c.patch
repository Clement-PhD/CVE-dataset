@@ -698,22 +698,29 @@ coap_status_t
 coap_parse_message(void *packet, uint8_t *data, uint16_t data_len)
 {
   coap_packet_t *const coap_pkt = (coap_packet_t *) packet;
+  const uint8_t * const data_end = data + data_len;
   uint8_t *current_option;
   uint32_t option_number = 0;
   uint32_t option_delta = 0;
   uint32_t option_length = 0;
   uint32_t *x;
+  int i;
 
   /* Initialize packet */
   memset(coap_pkt, 0, sizeof(coap_packet_t));
 
+  /* Care: Error case requries an initialized coap_pkt! */
+  if (data_len < COAP_HEADER_LEN) {
+    goto exit_parse_error;
+  }
+
   /* pointer to packet bytes */
   coap_pkt->buffer = data;
 
   /* parse header fields */
   coap_pkt->version = (COAP_HEADER_VERSION_MASK & coap_pkt->buffer[0])>>COAP_HEADER_VERSION_POSITION;
   coap_pkt->type = (coap_message_type_t) ((COAP_HEADER_TYPE_MASK & coap_pkt->buffer[0])>>COAP_HEADER_TYPE_POSITION);
-  coap_pkt->token_len = MIN(COAP_TOKEN_LEN, (COAP_HEADER_TOKEN_LEN_MASK & coap_pkt->buffer[0])>>COAP_HEADER_TOKEN_LEN_POSITION);
+  coap_pkt->token_len = (COAP_HEADER_TOKEN_LEN_MASK & coap_pkt->buffer[0])>>COAP_HEADER_TOKEN_LEN_POSITION;
   coap_pkt->code = coap_pkt->buffer[1];
   coap_pkt->mid = coap_pkt->buffer[2]<<8 | coap_pkt->buffer[3];
 
@@ -723,42 +730,73 @@ coap_parse_message(void *packet, uint8_t *data, uint16_t data_len)
     return BAD_REQUEST_4_00;
   }
 
+  /*
+   * Empty Message:
+   *   A message with a Code of 0.00; neither a request nor a response.
+   *   An Empty message only contains the 4-byte header.
+   *
+   * TODO: Error on requests and responses
+   */
+  if ((coap_pkt->code == COAP_EMPTY_MESSAGE_CODE) && (data_len > COAP_HEADER_LEN)) {
+    goto exit_parse_error;
+  }
+
+  /*
+   * Lengths 9-15 are reserved, MUST NOT be sent, and MUST be processed as a
+   * message format error.
+   */
+  if (coap_pkt->token_len > COAP_TOKEN_LEN) {
+    goto exit_parse_error;
+  }
+
   current_option = data + COAP_HEADER_LEN;
 
   if (coap_pkt->token_len != 0)
   {
+      if (current_option + coap_pkt->token_len > data_end) {
+        goto exit_parse_error;
+      }
       memcpy(coap_pkt->token, current_option, coap_pkt->token_len);
       SET_OPTION(coap_pkt, COAP_OPTION_TOKEN);
 
-      PRINTF("Token (len %u) [0x%02X%02X%02X%02X%02X%02X%02X%02X]\n", coap_pkt->token_len,
-        coap_pkt->token[0],
-        coap_pkt->token[1],
-        coap_pkt->token[2],
-        coap_pkt->token[3],
-        coap_pkt->token[4],
-        coap_pkt->token[5],
-        coap_pkt->token[6],
-        coap_pkt->token[7]
-      ); /*FIXME always prints 8 bytes */
+      PRINTF("Token (len %u) [0x%02X", coap_pkt->token_len, coap_pkt->token[0]);
+      for (i = 1; i < coap_pkt->token_len; i++) {
+        PRINTF("%02X", coap_pkt->token[i]);
+      }
+      PRINTF("]\n");
   }
 
   /* parse options */
   current_option += coap_pkt->token_len;
 
-  while (current_option < data+data_len)
+  while (current_option < data_end)
   {
-    /* Payload marker 0xFF, currently only checking for 0xF* because rest is reserved */
-    if ((current_option[0] & 0xF0)==0xF0)
+    if (current_option[0] == 0xFF)
     {
+      /*
+       * The presence of a marker followed by a zero-length payload MUST be
+       * processed as a message format error.
+       */
+      if (current_option + 1 == data_end) {
+        goto exit_parse_error;
+      }
       coap_pkt->payload = ++current_option;
-      coap_pkt->payload_len = data_len - (coap_pkt->payload - data);
+      coap_pkt->payload_len = data_end - coap_pkt->payload;
 
       break;
     }
 
     option_delta = current_option[0]>>4;
     option_length = current_option[0] & 0x0F;
-    ++current_option;
+    /* Error on reserved option values */
+    if ((option_delta == COAP_HEADER_OPTION_DELTA_RESERVED) ||
+        (option_length == COAP_HEADER_OPTION_LENGTH_RESERVED)) {
+      goto exit_parse_error;
+    }
+
+    if (++current_option == data_end) {
+      goto exit_parse_error;
+    }
 
     /* avoids code duplication without function overhead */
     x = &option_delta;
@@ -767,26 +805,31 @@ coap_parse_message(void *packet, uint8_t *data, uint16_t data_len)
       if (*x==13)
       {
         *x += current_option[0];
-        ++current_option;
+        if (++current_option == data_end) {
+          goto exit_parse_error;
+        }
       }
       else if (*x==14)
       {
         *x += 255;
         *x += current_option[0]<<8;
-        ++current_option;
+        if (++current_option == data_end) {
+          goto exit_parse_error;
+        }
         *x += current_option[0];
-        ++current_option;
+        if (++current_option == data_end) {
+          goto exit_parse_error;
+        }
       }
     }
     while (x != &option_length && (x = &option_length));
 
     option_number += option_delta;
 
-    if (current_option + option_length > data + data_len)
+    if (current_option + option_length > data_end)
     {
         PRINTF("OPTION %u (delta %u, len %u) has invalid length.\n", option_number, option_delta, option_length);
-        coap_free_header(coap_pkt);
-        return BAD_REQUEST_4_00;
+        goto exit_parse_error;
     }
     else
     {
@@ -808,16 +851,11 @@ coap_parse_message(void *packet, uint8_t *data, uint16_t data_len)
       case COAP_OPTION_ETAG:
         coap_pkt->etag_len = (uint8_t)(MIN(COAP_ETAG_LEN, option_length));
         memcpy(coap_pkt->etag, current_option, coap_pkt->etag_len);
-        PRINTF("ETag %u [0x%02X%02X%02X%02X%02X%02X%02X%02X]\n", coap_pkt->etag_len,
-          coap_pkt->etag[0],
-          coap_pkt->etag[1],
-          coap_pkt->etag[2],
-          coap_pkt->etag[3],
-          coap_pkt->etag[4],
-          coap_pkt->etag[5],
-          coap_pkt->etag[6],
-          coap_pkt->etag[7]
-        ); /*FIXME always prints 8 bytes */
+        PRINTF("ETag %u [0x%02X", coap_pkt->etag_len);
+        for (i = 1; i < coap_pkt->etag_len; i++) {
+          PRINTF("%02X", coap_pkt->etag[i]);
+        }
+        PRINTF("]\n");
         break;
       case COAP_OPTION_ACCEPT:
         if (coap_pkt->accept_num < COAP_MAX_ACCEPT_NUM)
@@ -831,16 +869,11 @@ coap_parse_message(void *packet, uint8_t *data, uint16_t data_len)
         /*FIXME support multiple ETags */
         coap_pkt->if_match_len = (uint8_t)(MIN(COAP_ETAG_LEN, option_length));
         memcpy(coap_pkt->if_match, current_option, coap_pkt->if_match_len);
-        PRINTF("If-Match %u [0x%02X%02X%02X%02X%02X%02X%02X%02X]\n", coap_pkt->if_match_len,
-          coap_pkt->if_match[0],
-          coap_pkt->if_match[1],
-          coap_pkt->if_match[2],
-          coap_pkt->if_match[3],
-          coap_pkt->if_match[4],
-          coap_pkt->if_match[5],
-          coap_pkt->if_match[6],
-          coap_pkt->if_match[7]
-        ); /*FIXME always prints 8 bytes */
+        PRINTF("If-Match %u [0x%02X", coap_pkt->if_match_len);
+        for (i = 1; i < coap_pkt->if_match_len; i++) {
+          PRINTF("%02X", coap_pkt->if_match[i]);
+        }
+        PRINTF("]\n");
         break;
       case COAP_OPTION_IF_NONE_MATCH:
         coap_pkt->if_none_match = 1;
@@ -929,6 +962,11 @@ coap_parse_message(void *packet, uint8_t *data, uint16_t data_len)
 
 
   return NO_ERROR;
+
+exit_parse_error:
+  coap_free_header(coap_pkt);
+  coap_error_message = "Invalid COAP message";
+  return BAD_REQUEST_4_00;
 }
 /*-----------------------------------------------------------------------------------*/
 /*- REST FRAMEWORK FUNCTIONS --------------------------------------------------------*/