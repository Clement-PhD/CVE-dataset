@@ -25,30 +25,48 @@ type CipherState struct {
 	invalid bool
 }
 
+// MaxNonce is the maximum value of n that is allowed. ErrMaxNonce is returned
+// by Encrypt and Decrypt after this has been reached. 2^64-1 is reserved for rekeys.
+const MaxNonce = uint64(math.MaxUint64) - 1
+
+var ErrMaxNonce = errors.New("noise: cipherstate has reached maximum n, a new handshake must be performed")
+var ErrCipherSuiteCopied = errors.New("noise: CipherSuite has been copied, state is invalid")
+
 // Encrypt encrypts the plaintext and then appends the ciphertext and an
 // authentication tag across the ciphertext and optional authenticated data to
 // out. This method automatically increments the nonce after every call, so
-// messages must be decrypted in the same order.
-func (s *CipherState) Encrypt(out, ad, plaintext []byte) []byte {
+// messages must be decrypted in the same order. ErrMaxNonce is returned after
+// the maximum nonce of 2^64-2 is reached.
+func (s *CipherState) Encrypt(out, ad, plaintext []byte) ([]byte, error) {
 	if s.invalid {
-		panic("noise: CipherSuite has been copied, state is invalid")
+		return nil, ErrCipherSuiteCopied
+	}
+	if s.n > MaxNonce {
+		return nil, ErrMaxNonce
 	}
 	out = s.c.Encrypt(out, s.n, ad, plaintext)
 	s.n++
-	return out
+	return out, nil
 }
 
 // Decrypt checks the authenticity of the ciphertext and authenticated data and
 // then decrypts and appends the plaintext to out. This method automatically
 // increments the nonce after every call, messages must be provided in the same
-// order that they were encrypted with no missing messages.
+// order that they were encrypted with no missing messages. ErrMaxNonce is
+// returned after the maximum nonce of 2^64-2 is reached.
 func (s *CipherState) Decrypt(out, ad, ciphertext []byte) ([]byte, error) {
 	if s.invalid {
-		panic("noise: CipherSuite has been copied, state is invalid")
+		return nil, ErrCipherSuiteCopied
+	}
+	if s.n > MaxNonce {
+		return nil, ErrMaxNonce
 	}
 	out, err := s.c.Decrypt(out, s.n, ad, ciphertext)
+	if err != nil {
+		return nil, err
+	}
 	s.n++
-	return out, err
+	return out, nil
 }
 
 // Cipher returns the low-level symmetric encryption primitive. It should only
@@ -62,6 +80,12 @@ func (s *CipherState) Cipher() Cipher {
 	return s.c
 }
 
+// Nonce returns the current value of n. This can be used to determine if a
+// new handshake should be performed due to approaching MaxNonce.
+func (s *CipherState) Nonce() uint64 {
+	return s.n
+}
+
 func (s *CipherState) Rekey() {
 	var zeros [32]byte
 	var out []byte
@@ -120,14 +144,17 @@ func (s *symmetricState) MixKeyAndHash(data []byte) {
 	s.hasK = true
 }
 
-func (s *symmetricState) EncryptAndHash(out, plaintext []byte) []byte {
+func (s *symmetricState) EncryptAndHash(out, plaintext []byte) ([]byte, error) {
 	if !s.hasK {
 		s.MixHash(plaintext)
-		return append(out, plaintext...)
+		return append(out, plaintext...), nil
+	}
+	ciphertext, err := s.Encrypt(out, s.h, plaintext)
+	if err != nil {
+		return nil, err
 	}
-	ciphertext := s.Encrypt(out, s.h, plaintext)
 	s.MixHash(ciphertext[len(out):])
-	return ciphertext
+	return ciphertext, nil
 }
 
 func (s *symmetricState) DecryptAndHash(out, data []byte) ([]byte, error) {
@@ -340,6 +367,7 @@ func (s *HandshakeState) WriteMessage(out, payload []byte) ([]byte, *CipherState
 		return nil, nil, nil, errors.New("noise: message is too long")
 	}
 
+	var err error
 	for _, msg := range s.messagePatterns[s.msgIdx] {
 		switch msg {
 		case MessagePatternE:
@@ -357,7 +385,10 @@ func (s *HandshakeState) WriteMessage(out, payload []byte) ([]byte, *CipherState
 			if len(s.s.Public) == 0 {
 				return nil, nil, nil, errors.New("noise: invalid state, s.Public is nil")
 			}
-			out = s.ss.EncryptAndHash(out, s.s.Public)
+			out, err = s.ss.EncryptAndHash(out, s.s.Public)
+			if err != nil {
+				return nil, nil, nil, err
+			}
 		case MessagePatternDHEE:
 			dh, err := s.ss.cs.DH(s.e.Private, s.re)
 			if err != nil {
@@ -404,7 +435,10 @@ func (s *HandshakeState) WriteMessage(out, payload []byte) ([]byte, *CipherState
 	}
 	s.shouldWrite = false
 	s.msgIdx++
-	out = s.ss.EncryptAndHash(out, payload)
+	out, err = s.ss.EncryptAndHash(out, payload)
+	if err != nil {
+		return nil, nil, nil, err
+	}
 
 	if s.msgIdx >= len(s.messagePatterns) {
 		cs1, cs2 := s.ss.Split()