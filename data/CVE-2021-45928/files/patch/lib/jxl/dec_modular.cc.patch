@@ -274,44 +274,36 @@ Status ModularFrameDecoder::DecodeGroup(const Rect& rect, BitReader* reader,
     Rect r(rect.x0() >> fc.hshift, rect.y0() >> fc.vshift,
            rect.xsize() >> fc.hshift, rect.ysize() >> fc.vshift, fc.w, fc.h);
     if (r.xsize() == 0 || r.ysize() == 0) continue;
-    Channel gc(r.xsize(), r.ysize());
-    gc.hshift = fc.hshift;
-    gc.vshift = fc.vshift;
-    gi.channel.emplace_back(std::move(gc));
-  }
-  if (zerofill) {
-    int gic = 0;
-    for (c = beginc; c < full_image.channel.size(); c++) {
-      Channel& fc = full_image.channel[c];
-      int shift = std::min(fc.hshift, fc.vshift);
-      if (shift > maxShift) continue;
-      if (shift < minShift) continue;
-      Rect r(rect.x0() >> fc.hshift, rect.y0() >> fc.vshift,
-             rect.xsize() >> fc.hshift, rect.ysize() >> fc.vshift, fc.w, fc.h);
-      if (r.xsize() == 0 || r.ysize() == 0) continue;
+    if (zerofill && use_full_image) {
       for (size_t y = 0; y < r.ysize(); ++y) {
         pixel_type* const JXL_RESTRICT row_out = r.Row(&fc.plane, y);
         memset(row_out, 0, r.xsize() * sizeof(*row_out));
       }
-      gic++;
+    } else {
+      Channel gc(r.xsize(), r.ysize());
+      if (zerofill) ZeroFillImage(&gc.plane);
+      gc.hshift = fc.hshift;
+      gc.vshift = fc.vshift;
+      gi.channel.emplace_back(std::move(gc));
     }
-    return true;
   }
+  if (zerofill && use_full_image) return true;
   ModularOptions options;
-  if (!ModularGenericDecompress(
-          reader, gi, /*header=*/nullptr, stream.ID(frame_dim), &options,
-          /*undo_transforms=*/-1, &tree, &code, &context_map))
-    return JXL_FAILURE("Failed to decode modular group");
-  if (minShift == 0) {
-    // Undo global transforms that have been pushed to the group level
+  if (!zerofill) {
+    if (!ModularGenericDecompress(
+            reader, gi, /*header=*/nullptr, stream.ID(frame_dim), &options,
+            /*undo_transforms=*/-1, &tree, &code, &context_map)) {
+      return JXL_FAILURE("Failed to decode modular group");
+    }
+  }
+  // Undo global transforms that have been pushed to the group level
+  if (!use_full_image) {
     for (auto t : global_transform) {
       JXL_RETURN_IF_ERROR(t.Inverse(gi, global_header.wp_header));
     }
-    if (!use_full_image) {
-      JXL_RETURN_IF_ERROR(ModularImageToDecodedRect(
-          gi, dec_state, nullptr, output, rect.Crop(dec_state->decoded)));
-      return true;
-    }
+    JXL_RETURN_IF_ERROR(ModularImageToDecodedRect(
+        gi, dec_state, nullptr, output, rect.Crop(dec_state->decoded)));
+    return true;
   }
   int gic = 0;
   for (c = beginc; c < full_image.channel.size(); c++) {
@@ -322,6 +314,7 @@ Status ModularFrameDecoder::DecodeGroup(const Rect& rect, BitReader* reader,
     Rect r(rect.x0() >> fc.hshift, rect.y0() >> fc.vshift,
            rect.xsize() >> fc.hshift, rect.ysize() >> fc.vshift, fc.w, fc.h);
     if (r.xsize() == 0 || r.ysize() == 0) continue;
+    JXL_ASSERT(use_full_image);
     CopyImageTo(/*rect_from=*/Rect(0, 0, r.xsize(), r.ysize()),
                 /*from=*/gi.channel[gic].plane,
                 /*rect_to=*/r, /*to=*/&fc.plane);