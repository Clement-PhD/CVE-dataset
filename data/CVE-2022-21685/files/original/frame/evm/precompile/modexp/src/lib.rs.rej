--- /dev/null
+++ /dev/null
@@ -423,39 +412,4 @@ mod tests {
 			}
 		}
 	}
-
-	#[test]
-	fn test_zero_exp_with_33_length() {
-		// This is a regression test which ensures that the 'iteration_count' calculation
-		// in 'calculate_iteration_count' cannot underflow.
-		//
-		// In debug mode, this underflow could cause a panic. Otherwise, it causes N**0 to
-		// be calculated at more-than-normal expense.
-		//
-		// TODO: cite security advisory
-
-		let input = vec![
-			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-			0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-			0, 0, 0, 0, 0, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-			0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
-		];
-
-		let cost: u64 = 100000;
-
-		let context: Context = Context {
-			address: Default::default(),
-			caller: Default::default(),
-			apparent_value: From::from(0),
-		};
-
-		let precompile_result = Modexp::execute(&input, Some(cost), &context, false)
-			.expect("Modexp::execute() returned error");
-
-		assert_eq!(precompile_result.output.len(), 1); // should be same length as mod
-		let result = BigUint::from_bytes_be(&precompile_result.output[..]);
-		let expected = BigUint::parse_bytes(b"0", 10).unwrap();
-		assert_eq!(result, expected);
-	}
 
