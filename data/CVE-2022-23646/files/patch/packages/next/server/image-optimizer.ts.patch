@@ -1,6 +1,6 @@
 import { mediaType } from 'next/dist/compiled/@hapi/accept'
 import { createHash } from 'crypto'
-import { createReadStream, promises } from 'fs'
+import { promises } from 'fs'
 import { getOrientation, Orientation } from 'next/dist/compiled/get-orientation'
 import imageSizeOf from 'next/dist/compiled/image-size'
 import { IncomingMessage, ServerResponse } from 'http'
@@ -10,14 +10,13 @@ import contentDisposition from 'next/dist/compiled/content-disposition'
 import { join } from 'path'
 import Stream from 'stream'
 import nodeUrl, { UrlWithParsedQuery } from 'url'
-import { NextConfig } from './config-shared'
-import { fileExists } from '../lib/file-exists'
-import { ImageConfig, imageConfigDefault } from './image-config'
+import { NextConfigComplete } from './config-shared'
 import { processBuffer, decodeBuffer, Operation } from './lib/squoosh/main'
 import { sendEtagResponse } from './send-payload'
 import { getContentType, getExtension } from './serve-static'
 import chalk from 'next/dist/compiled/chalk'
 import { NextUrlWithParsedQuery } from './request-meta'
+import { IncrementalCacheEntry, IncrementalCacheValue } from './response-cache'
 
 type XCacheHeader = 'MISS' | 'HIT' | 'STALE'
 
@@ -31,7 +30,6 @@ const CACHE_VERSION = 3
 const ANIMATABLE_TYPES = [WEBP, PNG, GIF]
 const VECTOR_TYPES = [SVG]
 const BLUR_IMG_SIZE = 8 // should match `next-image-loader`
-const inflightRequests = new Map<string, Promise<void>>()
 
 let sharp:
   | ((
@@ -48,489 +46,505 @@ try {
 
 let showSharpMissingWarning = process.env.NODE_ENV === 'production'
 
-export async function imageOptimizer(
-  req: IncomingMessage,
-  res: ServerResponse,
-  parsedUrl: UrlWithParsedQuery,
-  nextConfig: NextConfig,
-  distDir: string,
-  render404: () => Promise<void>,
-  handleRequest: (
-    newReq: IncomingMessage,
-    newRes: ServerResponse,
-    newParsedUrl?: NextUrlWithParsedQuery
-  ) => Promise<void>,
-  isDev = false
-) {
-  const imageData: ImageConfig = nextConfig.images || imageConfigDefault
-  const {
-    deviceSizes = [],
-    imageSizes = [],
-    domains = [],
-    loader,
-    minimumCacheTTL = 60,
-    formats = ['image/webp'],
-  } = imageData
-
-  if (loader !== 'default') {
-    await render404()
-    return { finished: true }
-  }
+export interface ImageParamsResult {
+  href: string
+  isAbsolute: boolean
+  isStatic: boolean
+  width: number
+  quality: number
+  mimeType: string
+  sizes: number[]
+  minimumCacheTTL: number
+}
 
-  const { headers } = req
-  const { url, w, q } = parsedUrl.query
-  const mimeType = getSupportedMimeType(formats, headers.accept)
-  let href: string
+export class ImageOptimizerCache {
+  private cacheDir: string
+  private nextConfig: NextConfigComplete
+
+  static validateParams(
+    req: IncomingMessage,
+    query: UrlWithParsedQuery['query'],
+    nextConfig: NextConfigComplete,
+    isDev: boolean
+  ): ImageParamsResult | { errorMessage: string } {
+    const imageData = nextConfig.images
+    const {
+      deviceSizes = [],
+      imageSizes = [],
+      domains = [],
+      minimumCacheTTL = 60,
+      formats = ['image/webp'],
+    } = imageData
+    const { url, w, q } = query
+    let href: string
+
+    if (!url) {
+      return { errorMessage: '"url" parameter is required' }
+    } else if (Array.isArray(url)) {
+      return { errorMessage: '"url" parameter cannot be an array' }
+    }
 
-  if (!url) {
-    res.statusCode = 400
-    res.end('"url" parameter is required')
-    return { finished: true }
-  } else if (Array.isArray(url)) {
-    res.statusCode = 400
-    res.end('"url" parameter cannot be an array')
-    return { finished: true }
-  }
+    let isAbsolute: boolean
 
-  let isAbsolute: boolean
+    if (url.startsWith('/')) {
+      href = url
+      isAbsolute = false
+    } else {
+      let hrefParsed: URL
 
-  if (url.startsWith('/')) {
-    href = url
-    isAbsolute = false
-  } else {
-    let hrefParsed: URL
+      try {
+        hrefParsed = new URL(url)
+        href = hrefParsed.toString()
+        isAbsolute = true
+      } catch (_error) {
+        return { errorMessage: '"url" parameter is invalid' }
+      }
 
-    try {
-      hrefParsed = new URL(url)
-      href = hrefParsed.toString()
-      isAbsolute = true
-    } catch (_error) {
-      res.statusCode = 400
-      res.end('"url" parameter is invalid')
-      return { finished: true }
+      if (!['http:', 'https:'].includes(hrefParsed.protocol)) {
+        return { errorMessage: '"url" parameter is invalid' }
+      }
+
+      if (!domains || !domains.includes(hrefParsed.hostname)) {
+        return { errorMessage: '"url" parameter is not allowed' }
+      }
     }
 
-    if (!['http:', 'https:'].includes(hrefParsed.protocol)) {
-      res.statusCode = 400
-      res.end('"url" parameter is invalid')
-      return { finished: true }
+    if (!w) {
+      return { errorMessage: '"w" parameter (width) is required' }
+    } else if (Array.isArray(w)) {
+      return { errorMessage: '"w" parameter (width) cannot be an array' }
     }
 
-    if (!domains.includes(hrefParsed.hostname)) {
-      res.statusCode = 400
-      res.end('"url" parameter is not allowed')
-      return { finished: true }
+    if (!q) {
+      return { errorMessage: '"q" parameter (quality) is required' }
+    } else if (Array.isArray(q)) {
+      return { errorMessage: '"q" parameter (quality) cannot be an array' }
     }
-  }
 
-  if (!w) {
-    res.statusCode = 400
-    res.end('"w" parameter (width) is required')
-    return { finished: true }
-  } else if (Array.isArray(w)) {
-    res.statusCode = 400
-    res.end('"w" parameter (width) cannot be an array')
-    return { finished: true }
-  }
+    const width = parseInt(w, 10)
 
-  if (!q) {
-    res.statusCode = 400
-    res.end('"q" parameter (quality) is required')
-    return { finished: true }
-  } else if (Array.isArray(q)) {
-    res.statusCode = 400
-    res.end('"q" parameter (quality) cannot be an array')
-    return { finished: true }
-  }
+    if (!width || isNaN(width)) {
+      return {
+        errorMessage: '"w" parameter (width) must be a number greater than 0',
+      }
+    }
 
-  // Should match output from next-image-loader
-  const isStatic = url.startsWith(
-    `${nextConfig.basePath || ''}/_next/static/media`
-  )
+    const sizes = [...(deviceSizes || []), ...(imageSizes || [])]
 
-  const width = parseInt(w, 10)
+    if (isDev) {
+      sizes.push(BLUR_IMG_SIZE)
+    }
 
-  if (!width || isNaN(width)) {
-    res.statusCode = 400
-    res.end('"w" parameter (width) must be a number greater than 0')
-    return { finished: true }
-  }
+    if (!sizes.includes(width)) {
+      return {
+        errorMessage: `"w" parameter (width) of ${width} is not allowed`,
+      }
+    }
 
-  const sizes = [...deviceSizes, ...imageSizes]
+    const quality = parseInt(q)
 
-  if (isDev) {
-    sizes.push(BLUR_IMG_SIZE)
-  }
+    if (isNaN(quality) || quality < 1 || quality > 100) {
+      return {
+        errorMessage:
+          '"q" parameter (quality) must be a number between 1 and 100',
+      }
+    }
 
-  if (!sizes.includes(width)) {
-    res.statusCode = 400
-    res.end(`"w" parameter (width) of ${width} is not allowed`)
-    return { finished: true }
-  }
+    const mimeType = getSupportedMimeType(formats || [], req.headers['accept'])
 
-  const quality = parseInt(q)
+    const isStatic = url.startsWith(
+      `${nextConfig.basePath || ''}/_next/static/media`
+    )
 
-  if (isNaN(quality) || quality < 1 || quality > 100) {
-    res.statusCode = 400
-    res.end('"q" parameter (quality) must be a number between 1 and 100')
-    return { finished: true }
+    return {
+      href,
+      sizes,
+      isAbsolute,
+      isStatic,
+      width,
+      quality,
+      mimeType,
+      minimumCacheTTL,
+    }
   }
 
-  const hash = getHash([CACHE_VERSION, href, width, quality, mimeType])
-  const imagesDir = join(distDir, 'cache', 'images')
-  const hashDir = join(imagesDir, hash)
-  const now = Date.now()
-  let xCache: XCacheHeader = 'MISS'
+  static getCacheKey({
+    href,
+    width,
+    quality,
+    mimeType,
+  }: {
+    href: string
+    width: number
+    quality: number
+    mimeType: string
+  }): string {
+    return getHash([CACHE_VERSION, href, width, quality, mimeType])
+  }
 
-  // If there're concurrent requests hitting the same resource and it's still
-  // being optimized, wait before accessing the cache.
-  if (inflightRequests.has(hash)) {
-    await inflightRequests.get(hash)
+  constructor({
+    distDir,
+    nextConfig,
+  }: {
+    distDir: string
+    nextConfig: NextConfigComplete
+  }) {
+    this.cacheDir = join(distDir, 'cache', 'images')
+    this.nextConfig = nextConfig
   }
-  const dedupe = new Deferred<void>()
-  inflightRequests.set(hash, dedupe.promise)
 
-  try {
-    if (await fileExists(hashDir, 'directory')) {
-      const files = await promises.readdir(hashDir)
-      for (let file of files) {
-        const [maxAgeStr, expireAtSt, etag, extension] = file.split('.')
-        const maxAge = Number(maxAgeStr)
+  async get(cacheKey: string): Promise<IncrementalCacheEntry | null> {
+    try {
+      const cacheDir = join(this.cacheDir, cacheKey)
+      const files = await promises.readdir(cacheDir)
+      const now = Date.now()
+
+      for (const file of files) {
+        const [maxAgeSt, expireAtSt, etag, extension] = file.split('.')
+        const buffer = await promises.readFile(join(cacheDir, file))
         const expireAt = Number(expireAtSt)
-        const contentType = getContentType(extension)
-        const fsPath = join(hashDir, file)
-        xCache = now < expireAt ? 'HIT' : 'STALE'
-        const result = setResponseHeaders(
-          req,
-          res,
-          url,
-          etag,
-          maxAge,
-          contentType,
-          isStatic,
-          isDev,
-          xCache
-        )
-        if (!result.finished) {
-          await new Promise<void>((resolve, reject) => {
-            createReadStream(fsPath)
-              .on('end', resolve)
-              .on('error', reject)
-              .pipe(res)
-          })
-        }
-        if (xCache === 'HIT') {
-          return { finished: true }
-        } else {
-          await promises.unlink(fsPath)
+        const maxAge = Number(maxAgeSt)
+
+        return {
+          value: {
+            kind: 'IMAGE',
+            etag,
+            buffer,
+            extension,
+          },
+          revalidateAfter:
+            Math.max(maxAge, this.nextConfig.images.minimumCacheTTL) * 1000 +
+            Date.now(),
+          curRevalidate: maxAge,
+          isStale: now > expireAt,
         }
       }
+    } catch (_) {
+      // failed to read from cache dir, treat as cache miss
+    }
+    return null
+  }
+  async set(
+    cacheKey: string,
+    value: IncrementalCacheValue | null,
+    revalidate?: number | false
+  ) {
+    if (value?.kind !== 'IMAGE') {
+      throw new Error('invariant attempted to set non-image to image-cache')
     }
 
-    let upstreamBuffer: Buffer
-    let upstreamType: string | null
-    let maxAge: number
-
-    if (isAbsolute) {
-      const upstreamRes = await fetch(href)
+    if (typeof revalidate !== 'number') {
+      throw new Error('invariant revalidate must be a number for image-cache')
+    }
+    const expireAt =
+      Math.max(revalidate, this.nextConfig.images.minimumCacheTTL) * 1000 +
+      Date.now()
+
+    await writeToCacheDir(
+      join(this.cacheDir, cacheKey),
+      value.extension,
+      revalidate,
+      expireAt,
+      value.buffer,
+      value.etag
+    )
+  }
+}
+export class ImageError extends Error {
+  statusCode: number
 
-      if (!upstreamRes.ok) {
-        res.statusCode = upstreamRes.status
-        res.end('"url" parameter is valid but upstream response is invalid')
-        return { finished: true }
-      }
+  constructor(statusCode: number, message: string) {
+    super(message)
+    this.statusCode = statusCode
+  }
+}
 
-      res.statusCode = upstreamRes.status
-      upstreamBuffer = Buffer.from(await upstreamRes.arrayBuffer())
-      upstreamType =
-        detectContentType(upstreamBuffer) ||
-        upstreamRes.headers.get('Content-Type')
-      maxAge = getMaxAge(upstreamRes.headers.get('Cache-Control'))
-    } else {
-      try {
-        const resBuffers: Buffer[] = []
-        const mockRes: any = new Stream.Writable()
+export async function imageOptimizer(
+  _req: IncomingMessage,
+  _res: ServerResponse,
+  paramsResult: ImageParamsResult,
+  nextConfig: NextConfigComplete,
+  handleRequest: (
+    newReq: IncomingMessage,
+    newRes: ServerResponse,
+    newParsedUrl?: NextUrlWithParsedQuery
+  ) => Promise<void>
+): Promise<{ buffer: Buffer; contentType: string; maxAge: number }> {
+  let upstreamBuffer: Buffer
+  let upstreamType: string | null
+  let maxAge: number
+  const { isAbsolute, href, width, mimeType, quality } = paramsResult
+
+  if (isAbsolute) {
+    const upstreamRes = await fetch(href)
+
+    if (!upstreamRes.ok) {
+      console.error(
+        'upstream image response failed for',
+        href,
+        upstreamRes.status
+      )
+      throw new ImageError(
+        upstreamRes.status,
+        '"url" parameter is valid but upstream response is invalid'
+      )
+    }
 
-        const isStreamFinished = new Promise(function (resolve, reject) {
-          mockRes.on('finish', () => resolve(true))
-          mockRes.on('end', () => resolve(true))
-          mockRes.on('error', () => reject())
-        })
+    upstreamBuffer = Buffer.from(await upstreamRes.arrayBuffer())
+    upstreamType =
+      detectContentType(upstreamBuffer) ||
+      upstreamRes.headers.get('Content-Type')
+    maxAge = getMaxAge(upstreamRes.headers.get('Cache-Control'))
+  } else {
+    try {
+      const resBuffers: Buffer[] = []
+      const mockRes: any = new Stream.Writable()
 
-        mockRes.write = (chunk: Buffer | string) => {
-          resBuffers.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk))
-        }
-        mockRes._write = (
-          chunk: Buffer | string,
-          _encoding: string,
-          callback: () => void
-        ) => {
-          mockRes.write(chunk)
-          // According to Node.js documentation, the callback MUST be invoked to signal that
-          // the write completed successfully. If this callback is not invoked, the 'finish' event
-          // will not be emitted.
-          // https://nodejs.org/docs/latest-v16.x/api/stream.html#writable_writechunk-encoding-callback
-          callback()
-        }
+      const isStreamFinished = new Promise(function (resolve, reject) {
+        mockRes.on('finish', () => resolve(true))
+        mockRes.on('end', () => resolve(true))
+        mockRes.on('error', (err: any) => reject(err))
+      })
 
-        const mockHeaders: Record<string, string | string[]> = {}
-
-        mockRes.writeHead = (_status: any, _headers: any) =>
-          Object.assign(mockHeaders, _headers)
-        mockRes.getHeader = (name: string) => mockHeaders[name.toLowerCase()]
-        mockRes.getHeaders = () => mockHeaders
-        mockRes.getHeaderNames = () => Object.keys(mockHeaders)
-        mockRes.setHeader = (name: string, value: string | string[]) =>
-          (mockHeaders[name.toLowerCase()] = value)
-        mockRes.removeHeader = (name: string) => {
-          delete mockHeaders[name.toLowerCase()]
-        }
-        mockRes._implicitHeader = () => {}
-        mockRes.connection = res.connection
-        mockRes.finished = false
-        mockRes.statusCode = 200
+      mockRes.write = (chunk: Buffer | string) => {
+        resBuffers.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk))
+      }
+      mockRes._write = (
+        chunk: Buffer | string,
+        _encoding: string,
+        callback: () => void
+      ) => {
+        mockRes.write(chunk)
+        // According to Node.js documentation, the callback MUST be invoked to signal that
+        // the write completed successfully. If this callback is not invoked, the 'finish' event
+        // will not be emitted.
+        // https://nodejs.org/docs/latest-v16.x/api/stream.html#writable_writechunk-encoding-callback
+        callback()
+      }
 
-        const mockReq: any = new Stream.Readable()
+      const mockHeaders: Record<string, string | string[]> = {}
+
+      mockRes.writeHead = (_status: any, _headers: any) =>
+        Object.assign(mockHeaders, _headers)
+      mockRes.getHeader = (name: string) => mockHeaders[name.toLowerCase()]
+      mockRes.getHeaders = () => mockHeaders
+      mockRes.getHeaderNames = () => Object.keys(mockHeaders)
+      mockRes.setHeader = (name: string, value: string | string[]) =>
+        (mockHeaders[name.toLowerCase()] = value)
+      mockRes.removeHeader = (name: string) => {
+        delete mockHeaders[name.toLowerCase()]
+      }
+      mockRes._implicitHeader = () => {}
+      mockRes.connection = _res.connection
+      mockRes.finished = false
+      mockRes.statusCode = 200
 
-        mockReq._read = () => {
-          mockReq.emit('end')
-          mockReq.emit('close')
-          return Buffer.from('')
-        }
+      const mockReq: any = new Stream.Readable()
 
-        mockReq.headers = req.headers
-        mockReq.method = req.method
-        mockReq.url = href
-        mockReq.connection = req.connection
-
-        await handleRequest(mockReq, mockRes, nodeUrl.parse(href, true))
-        await isStreamFinished
-        res.statusCode = mockRes.statusCode
-        upstreamBuffer = Buffer.concat(resBuffers)
-        upstreamType =
-          detectContentType(upstreamBuffer) || mockRes.getHeader('Content-Type')
-        maxAge = getMaxAge(mockRes.getHeader('Cache-Control'))
-      } catch (err) {
-        res.statusCode = 500
-        res.end('"url" parameter is valid but upstream response is invalid')
-        return { finished: true }
+      mockReq._read = () => {
+        mockReq.emit('end')
+        mockReq.emit('close')
+        return Buffer.from('')
       }
-    }
 
-    const expireAt = Math.max(maxAge, minimumCacheTTL) * 1000 + now
-
-    if (upstreamType) {
-      const vector = VECTOR_TYPES.includes(upstreamType)
-      const animate =
-        ANIMATABLE_TYPES.includes(upstreamType) && isAnimated(upstreamBuffer)
-      if (vector || animate) {
-        await writeToCacheDir(
-          hashDir,
-          upstreamType,
-          maxAge,
-          expireAt,
-          upstreamBuffer
-        )
-        sendResponse(
-          req,
-          res,
-          url,
-          maxAge,
-          upstreamType,
-          upstreamBuffer,
-          isStatic,
-          isDev,
-          xCache
+      mockReq.headers = _req.headers
+      mockReq.method = _req.method
+      mockReq.url = href
+      mockReq.connection = _req.connection
+
+      await handleRequest(mockReq, mockRes, nodeUrl.parse(href, true))
+      await isStreamFinished
+
+      if (!mockRes.statusCode) {
+        console.error('image response failed for', href, mockRes.statusCode)
+        throw new ImageError(
+          mockRes.statusCode,
+          '"url" parameter is valid but internal response is invalid'
         )
-        return { finished: true }
-      }
-      if (!upstreamType.startsWith('image/')) {
-        res.statusCode = 400
-        res.end("The requested resource isn't a valid image.")
-        return { finished: true }
       }
+
+      upstreamBuffer = Buffer.concat(resBuffers)
+      upstreamType =
+        detectContentType(upstreamBuffer) || mockRes.getHeader('Content-Type')
+      maxAge = getMaxAge(mockRes.getHeader('Cache-Control'))
+    } catch (err) {
+      console.error('upstream image response failed for', href, err)
+      throw new ImageError(
+        500,
+        '"url" parameter is valid but upstream response is invalid'
+      )
     }
+  }
 
-    let contentType: string
+  if (upstreamType) {
+    const vector = VECTOR_TYPES.includes(upstreamType)
+    const animate =
+      ANIMATABLE_TYPES.includes(upstreamType) && isAnimated(upstreamBuffer)
 
-    if (mimeType) {
-      contentType = mimeType
-    } else if (
-      upstreamType?.startsWith('image/') &&
-      getExtension(upstreamType)
-    ) {
-      contentType = upstreamType
-    } else {
-      contentType = JPEG
+    if (vector || animate) {
+      return { buffer: upstreamBuffer, contentType: upstreamType, maxAge }
     }
-    try {
-      let optimizedBuffer: Buffer | undefined
-      if (sharp) {
-        // Begin sharp transformation logic
-        const transformer = sharp(upstreamBuffer)
+    if (!upstreamType.startsWith('image/')) {
+      console.error(
+        "The requested resource isn't a valid image for",
+        href,
+        'received',
+        upstreamType
+      )
+      throw new ImageError(400, "The requested resource isn't a valid image.")
+    }
+  }
 
-        transformer.rotate()
+  let contentType: string
 
-        const { width: metaWidth } = await transformer.metadata()
+  if (mimeType) {
+    contentType = mimeType
+  } else if (upstreamType?.startsWith('image/') && getExtension(upstreamType)) {
+    contentType = upstreamType
+  } else {
+    contentType = JPEG
+  }
+  try {
+    let optimizedBuffer: Buffer | undefined
+    if (sharp) {
+      // Begin sharp transformation logic
+      const transformer = sharp(upstreamBuffer)
 
-        if (metaWidth && metaWidth > width) {
-          transformer.resize(width)
-        }
+      transformer.rotate()
 
-        if (contentType === AVIF) {
-          if (transformer.avif) {
-            const avifQuality = quality - 15
-            transformer.avif({
-              quality: Math.max(avifQuality, 0),
-              chromaSubsampling: '4:2:0', // same as webp
-            })
-          } else {
-            console.warn(
-              chalk.yellow.bold('Warning: ') +
-                `Your installed version of the 'sharp' package does not support AVIF images. Run 'yarn add sharp@latest' to upgrade to the latest version.\n` +
-                'Read more: https://nextjs.org/docs/messages/sharp-version-avif'
-            )
-            transformer.webp({ quality })
-          }
-        } else if (contentType === WEBP) {
-          transformer.webp({ quality })
-        } else if (contentType === PNG) {
-          transformer.png({ quality })
-        } else if (contentType === JPEG) {
-          transformer.jpeg({ quality })
-        }
+      const { width: metaWidth } = await transformer.metadata()
 
-        optimizedBuffer = await transformer.toBuffer()
-        // End sharp transformation logic
-      } else {
-        if (
-          showSharpMissingWarning &&
-          nextConfig.experimental?.outputStandalone
-        ) {
-          // TODO: should we ensure squoosh also works even though we don't
-          // recommend it be used in production and this is a production feature
-          console.error(
-            `Error: 'sharp' is required to be installed in standalone mode for the image optimization to function correctly`
-          )
-          req.statusCode = 500
-          res.end('internal server error')
-          return { finished: true }
-        }
-        // Show sharp warning in production once
-        if (showSharpMissingWarning) {
+      if (metaWidth && metaWidth > width) {
+        transformer.resize(width)
+      }
+
+      if (contentType === AVIF) {
+        if (transformer.avif) {
+          const avifQuality = quality - 15
+          transformer.avif({
+            quality: Math.max(avifQuality, 0),
+            chromaSubsampling: '4:2:0', // same as webp
+          })
+        } else {
           console.warn(
             chalk.yellow.bold('Warning: ') +
-              `For production Image Optimization with Next.js, the optional 'sharp' package is strongly recommended. Run 'yarn add sharp', and Next.js will use it automatically for Image Optimization.\n` +
-              'Read more: https://nextjs.org/docs/messages/sharp-missing-in-production'
+              `Your installed version of the 'sharp' package does not support AVIF images. Run 'yarn add sharp@latest' to upgrade to the latest version.\n` +
+              'Read more: https://nextjs.org/docs/messages/sharp-version-avif'
           )
-          showSharpMissingWarning = false
+          transformer.webp({ quality })
         }
+      } else if (contentType === WEBP) {
+        transformer.webp({ quality })
+      } else if (contentType === PNG) {
+        transformer.png({ quality })
+      } else if (contentType === JPEG) {
+        transformer.jpeg({ quality })
+      }
 
-        // Begin Squoosh transformation logic
-        const orientation = await getOrientation(upstreamBuffer)
+      optimizedBuffer = await transformer.toBuffer()
+      // End sharp transformation logic
+    } else {
+      if (
+        showSharpMissingWarning &&
+        nextConfig.experimental?.outputStandalone
+      ) {
+        // TODO: should we ensure squoosh also works even though we don't
+        // recommend it be used in production and this is a production feature
+        console.error(
+          `Error: 'sharp' is required to be installed in standalone mode for the image optimization to function correctly`
+        )
+        throw new ImageError(500, 'internal server error')
+      }
+      // Show sharp warning in production once
+      if (showSharpMissingWarning) {
+        console.warn(
+          chalk.yellow.bold('Warning: ') +
+            `For production Image Optimization with Next.js, the optional 'sharp' package is strongly recommended. Run 'yarn add sharp', and Next.js will use it automatically for Image Optimization.\n` +
+            'Read more: https://nextjs.org/docs/messages/sharp-missing-in-production'
+        )
+        showSharpMissingWarning = false
+      }
 
-        const operations: Operation[] = []
+      // Begin Squoosh transformation logic
+      const orientation = await getOrientation(upstreamBuffer)
 
-        if (orientation === Orientation.RIGHT_TOP) {
-          operations.push({ type: 'rotate', numRotations: 1 })
-        } else if (orientation === Orientation.BOTTOM_RIGHT) {
-          operations.push({ type: 'rotate', numRotations: 2 })
-        } else if (orientation === Orientation.LEFT_BOTTOM) {
-          operations.push({ type: 'rotate', numRotations: 3 })
-        } else {
-          // TODO: support more orientations
-          // eslint-disable-next-line @typescript-eslint/no-unused-vars
-          // const _: never = orientation
-        }
+      const operations: Operation[] = []
 
-        operations.push({ type: 'resize', width })
+      if (orientation === Orientation.RIGHT_TOP) {
+        operations.push({ type: 'rotate', numRotations: 1 })
+      } else if (orientation === Orientation.BOTTOM_RIGHT) {
+        operations.push({ type: 'rotate', numRotations: 2 })
+      } else if (orientation === Orientation.LEFT_BOTTOM) {
+        operations.push({ type: 'rotate', numRotations: 3 })
+      } else {
+        // TODO: support more orientations
+        // eslint-disable-next-line @typescript-eslint/no-unused-vars
+        // const _: never = orientation
+      }
 
-        if (contentType === AVIF) {
-          optimizedBuffer = await processBuffer(
-            upstreamBuffer,
-            operations,
-            'avif',
-            quality
-          )
-        } else if (contentType === WEBP) {
-          optimizedBuffer = await processBuffer(
-            upstreamBuffer,
-            operations,
-            'webp',
-            quality
-          )
-        } else if (contentType === PNG) {
-          optimizedBuffer = await processBuffer(
-            upstreamBuffer,
-            operations,
-            'png',
-            quality
-          )
-        } else if (contentType === JPEG) {
-          optimizedBuffer = await processBuffer(
-            upstreamBuffer,
-            operations,
-            'jpeg',
-            quality
-          )
-        }
+      operations.push({ type: 'resize', width })
 
-        // End Squoosh transformation logic
-      }
-      if (optimizedBuffer) {
-        await writeToCacheDir(
-          hashDir,
-          contentType,
-          maxAge,
-          expireAt,
-          optimizedBuffer
+      if (contentType === AVIF) {
+        optimizedBuffer = await processBuffer(
+          upstreamBuffer,
+          operations,
+          'avif',
+          quality
         )
-        sendResponse(
-          req,
-          res,
-          url,
-          maxAge,
-          contentType,
-          optimizedBuffer,
-          isStatic,
-          isDev,
-          xCache
+      } else if (contentType === WEBP) {
+        optimizedBuffer = await processBuffer(
+          upstreamBuffer,
+          operations,
+          'webp',
+          quality
+        )
+      } else if (contentType === PNG) {
+        optimizedBuffer = await processBuffer(
+          upstreamBuffer,
+          operations,
+          'png',
+          quality
+        )
+      } else if (contentType === JPEG) {
+        optimizedBuffer = await processBuffer(
+          upstreamBuffer,
+          operations,
+          'jpeg',
+          quality
         )
-      } else {
-        throw new Error('Unable to optimize buffer')
       }
-    } catch (error) {
-      sendResponse(
-        req,
-        res,
-        url,
-        maxAge,
-        upstreamType,
-        upstreamBuffer,
-        isStatic,
-        isDev,
-        xCache
-      )
-    }
 
-    return { finished: true }
-  } finally {
-    dedupe.resolve()
-    inflightRequests.delete(hash)
+      // End Squoosh transformation logic
+    }
+    if (optimizedBuffer) {
+      return {
+        buffer: optimizedBuffer,
+        contentType,
+        maxAge: Math.max(maxAge, nextConfig.images.minimumCacheTTL),
+      }
+    } else {
+      throw new ImageError(500, 'Unable to optimize buffer')
+    }
+  } catch (error) {
+    return {
+      buffer: upstreamBuffer,
+      contentType: upstreamType!,
+      maxAge,
+    }
   }
 }
 
 async function writeToCacheDir(
   dir: string,
-  contentType: string,
+  extension: string,
   maxAge: number,
   expireAt: number,
-  buffer: Buffer
+  buffer: Buffer,
+  etag: string
 ) {
-  await promises.mkdir(dir, { recursive: true })
-  const extension = getExtension(contentType)
-  const etag = getHash([buffer])
   const filename = join(dir, `${maxAge}.${expireAt}.${etag}.${extension}`)
+  await promises.rmdir(dir, { recursive: true })
+  await promises.mkdir(dir, { recursive: true })
   await promises.writeFile(filename, buffer)
 }
 
@@ -549,23 +563,21 @@ function getFileNameWithExtension(
   return `${fileName}.${extension}`
 }
 
-function setResponseHeaders(
+export function setResponseHeaders(
   req: IncomingMessage,
   res: ServerResponse,
   url: string,
   etag: string,
-  maxAge: number,
   contentType: string | null,
   isStatic: boolean,
-  isDev: boolean,
   xCache: XCacheHeader
 ) {
   res.setHeader('Vary', 'Accept')
   res.setHeader(
     'Cache-Control',
     isStatic
       ? 'public, max-age=315360000, immutable'
-      : `public, max-age=${isDev ? 0 : maxAge}, must-revalidate`
+      : `public, max-age=0, must-revalidate`
   )
   if (sendEtagResponse(req, res, etag)) {
     // already called res.end() so we're finished
@@ -589,30 +601,24 @@ function setResponseHeaders(
   return { finished: false }
 }
 
-function sendResponse(
+export function sendResponse(
   req: IncomingMessage,
   res: ServerResponse,
   url: string,
-  maxAge: number,
-  contentType: string | null,
+  extension: string,
   buffer: Buffer,
   isStatic: boolean,
-  isDev: boolean,
   xCache: XCacheHeader
 ) {
-  if (xCache === 'STALE') {
-    return
-  }
+  const contentType = getContentType(extension)
   const etag = getHash([buffer])
   const result = setResponseHeaders(
     req,
     res,
     url,
     etag,
-    maxAge,
     contentType,
     isStatic,
-    isDev,
     xCache
   )
   if (!result.finished) {
@@ -625,7 +631,7 @@ function getSupportedMimeType(options: string[], accept = ''): string {
   return accept.includes(mimeType) ? mimeType : ''
 }
 
-function getHash(items: (string | number | Buffer)[]) {
+export function getHash(items: (string | number | Buffer)[]) {
   const hash = createHash('sha256')
   for (let item of items) {
     if (typeof item === 'number') hash.update(String(item))