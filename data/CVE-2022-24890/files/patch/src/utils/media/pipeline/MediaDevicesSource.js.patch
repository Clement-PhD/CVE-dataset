@@ -30,12 +30,17 @@ import TrackSource from './TrackSource'
  *
  * Two output tracks with "audio" and "video" as ids are provided.
  *
- * The source is started by calling "start(constraints)". Whether the audio
- * track, video track or both start depends on the given constraints and the
+ * The source is started by calling "start(retryNoVideoCallback)". Whether the
+ * audio track, video track or both start depends on the allowed media and the
  * current devices. Even if no track is started at first the node will listen to
  * changes in the audioInputId and videoInputId attributes from the
  * MediaDevicesManager and start, stop and replace the tracks are needed.
  *
+ * The allowed media can be set with "setAudioAllowed(bool)" and
+ * "setVideoAllowed(bool)". If the audioInputId or videoInputId changed but that
+ * media is currently not allowed the change will be ignored. Allowing or
+ * disallowing media will automatically start or stop the tracks as needed.
+ *
  * Once the source is started "stop()" needs to be called to stop listening to
  * changes in the devices. Stopping the source also stops any track currently
  * active.
@@ -56,9 +61,70 @@ export default class MediaDevicesSource extends TrackSource {
 
 		this._handleAudioInputIdChangedBound = this._handleAudioInputIdChanged.bind(this)
 		this._handleVideoInputIdChangedBound = this._handleVideoInputIdChanged.bind(this)
+
+		this._audioAllowed = true
+		this._videoAllowed = true
+
+		this._active = false
+	}
+
+	isAudioAllowed() {
+		return this._audioAllowed
+	}
+
+	isVideoAllowed() {
+		return this._videoAllowed
 	}
 
-	async start(constraints, retryNoVideoCallback) {
+	setAudioAllowed(audioAllowed) {
+		if (this._audioAllowed === audioAllowed) {
+			return
+		}
+
+		this._audioAllowed = audioAllowed
+
+		if (!this._active) {
+			return
+		}
+
+		if (audioAllowed) {
+			this._handleAudioInputIdChangedBound(mediaDevicesManager, mediaDevicesManager.get('audioInputId'))
+
+			return
+		}
+
+		if (this.getOutputTrack('audio')) {
+			this.getOutputTrack('audio').stop()
+		}
+		this._setOutputTrack('audio', null)
+	}
+
+	setVideoAllowed(videoAllowed) {
+		if (this._videoAllowed === videoAllowed) {
+			return
+		}
+
+		this._videoAllowed = videoAllowed
+
+		if (!this._active) {
+			return
+		}
+
+		if (videoAllowed) {
+			this._handleVideoInputIdChangedBound(mediaDevicesManager, mediaDevicesManager.get('videoInputId'))
+
+			return
+		}
+
+		if (this.getOutputTrack('video')) {
+			this.getOutputTrack('video').stop()
+		}
+		this._setOutputTrack('video', null)
+	}
+
+	async start(retryNoVideoCallback) {
+		this._active = true
+
 		// Try to get the devices list before getting user media.
 		mediaDevicesManager.enableDeviceEvents()
 		mediaDevicesManager.disableDeviceEvents()
@@ -67,6 +133,11 @@ export default class MediaDevicesSource extends TrackSource {
 		// events expect the initial "getUserMedia" call to have been completed
 		// before being used, so they must be set once the media has started.
 
+		const constraints = {
+			audio: this._audioAllowed,
+			video: this._videoAllowed,
+		}
+
 		let stream
 		let error
 
@@ -75,7 +146,7 @@ export default class MediaDevicesSource extends TrackSource {
 		// Fallback for users without a camera or with a camera that can not be
 		// accessed, but only if audio is meant to be used.
 		if (error && constraints.audio !== false && constraints.video !== false) {
-			retryNoVideoCallback(constraints, error);
+			retryNoVideoCallback(error);
 
 			[stream, error] = await this._startAudioOnly(constraints)
 		}
@@ -156,6 +227,8 @@ export default class MediaDevicesSource extends TrackSource {
 
 		mediaDevicesManager.off('change:audioInputId', this._handleAudioInputIdChangedBound)
 		mediaDevicesManager.off('change:videoInputId', this._handleVideoInputIdChangedBound)
+
+		this._active = false
 	}
 
 	/**
@@ -204,6 +277,10 @@ export default class MediaDevicesSource extends TrackSource {
 	}
 
 	_handleAudioInputIdChanged(mediaDevicesManager, audioInputId) {
+		if (!this._audioAllowed) {
+			return
+		}
+
 		if (this._pendingAudioInputIdChangedCount) {
 			this._pendingAudioInputIdChangedCount++
 
@@ -267,6 +344,10 @@ export default class MediaDevicesSource extends TrackSource {
 	}
 
 	_handleVideoInputIdChanged(mediaDevicesManager, videoInputId) {
+		if (!this._videoAllowed) {
+			return
+		}
+
 		if (this._pendingVideoInputIdChangedCount) {
 			this._pendingVideoInputIdChangedCount++
 