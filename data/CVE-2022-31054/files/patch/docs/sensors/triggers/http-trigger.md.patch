@@ -13,6 +13,7 @@ Argo Events offers HTTP trigger which can easily invoke serverless functions lik
 <br/>
 
 ## Specification
+
 The HTTP trigger specification is available [here](https://github.com/argoproj/argo-events/blob/master/api/sensor.md#httptrigger).
 
 ## REST API Calls
@@ -21,21 +22,20 @@ Consider a scenario where your REST API server needs to consume events from even
 the integration yourself in the server code, although server logic has nothing to do any of the event-sources. This is where Argo Events HTTP trigger
 can help. The HTTP trigger takes the task of consuming events from event-sources away from API server and seamlessly integrates these events via REST API calls.
 
-
 We will set up a basic go http server and connect it with the Minio events.
 
-1. The HTTP server simply prints the request body as follows.
+1.  The HTTP server simply prints the request body as follows.
 
         package main
 
         import (
         	"fmt"
-        	"io/ioutil"
+        	"io"
         	"net/http"
         )
 
         func hello(w http.ResponseWriter, req *http.Request) {
-        	body, err := ioutil.ReadAll(req.Body)
+        	body, err := io.ReadAll(req.Body)
         	if err != nil {
         		fmt.Printf("%+v\n", err)
         		return
@@ -50,35 +50,34 @@ We will set up a basic go http server and connect it with the Minio events.
         	http.ListenAndServe(":8090", nil)
         }
 
-2. Deploy the HTTP server.
+2.  Deploy the HTTP server.
 
         kubectl -n argo-events apply -f https://raw.githubusercontent.com/argoproj/argo-events/stable/examples/tutorials/09-http-trigger/http-server.yaml
 
-3. Create a service to expose the http server.
+3.  Create a service to expose the http server.
 
         kubectl -n argo-events apply -f https://raw.githubusercontent.com/argoproj/argo-events/stable/examples/tutorials/09-http-trigger/http-server-svc.yaml
 
-4. Either use Ingress, OpenShift Route or port-forwarding to expose the http server.
+4.  Either use Ingress, OpenShift Route or port-forwarding to expose the http server.
 
         kubectl -n argo-events port-forward <http-server-pod-name> 8090:8090
 
-5. Our goals is to seamlessly integrate Minio S3 bucket notifications with REST API server created in previous step. So,
-   lets set up the Minio event-source available [here](https://argoproj.github.io/argo-events/setup/minio/).
-   Don't create the sensor as we will be deploying it in next step.
+5.  Our goals is to seamlessly integrate Minio S3 bucket notifications with REST API server created in previous step. So,
+    lets set up the Minio event-source available [here](https://argoproj.github.io/argo-events/setup/minio/).
+    Don't create the sensor as we will be deploying it in next step.
 
-6. Create a sensor as follows.
+6.  Create a sensor as follows.
 
         kubectl apply -n argo-events -f https://raw.githubusercontent.com/argoproj/argo-events/stable/examples/sensors/http-trigger.yaml
 
-7. Now, drop a file onto `input` bucket in Minio server.
-
+7.  Now, drop a file onto `input` bucket in Minio server.
 
-8. The sensor has triggered a http request to the http server. Take a look at the logs.
+8.  The sensor has triggered a http request to the http server. Take a look at the logs.
 
         server is listening on 8090
         {"type":"minio","bucket":"input"}
 
-9. Great!!!
+9.  Great!!!
 
 ### Request Payload
 
@@ -122,6 +121,7 @@ you want to define a generic trigger template in the sensor and populate values
 You can learn more about trigger parameterization [here](https://argoproj.github.io/argo-events/tutorials/02-parameterization/).
 
 ### Policy
+
 Trigger policy helps you determine the status of the HTTP request and decide whether to stop or continue sensor.
 
 To determine whether the HTTP request was successful or not, the HTTP trigger provides a `Status` policy.
@@ -155,32 +155,30 @@ The above HTTP trigger will be treated successful only if the HTTP request retur
 OpenFaaS offers a simple way to spin up serverless functions. Lets see how we can leverage Argo Events HTTP trigger
 to invoke OpenFaaS function.
 
-1. If you don't have OpenFaaS installed, follow the [instructions](https://docs.openfaas.com/deployment/kubernetes/).
-
-2. Let's create a basic function. You can follow the [steps](https://blog.alexellis.io/serverless-golang-with-openfaas/).
-   to set up the function.
+1.  If you don't have OpenFaaS installed, follow the [instructions](https://docs.openfaas.com/deployment/kubernetes/).
 
+2.  Let's create a basic function. You can follow the [steps](https://blog.alexellis.io/serverless-golang-with-openfaas/).
+    to set up the function.
 
-        package function
+         package function
 
-        import (
-        	"fmt"
-        )
-
-        // Handle a serverless request
-        func Handle(req []byte) string {
-        	return fmt.Sprintf("Hello, Go. You said: %s", string(req))
-        }
+         import (
+         	"fmt"
+         )
 
+         // Handle a serverless request
+         func Handle(req []byte) string {
+         	return fmt.Sprintf("Hello, Go. You said: %s", string(req))
+         }
 
-3. Make sure the function pod is up and running.
+3.  Make sure the function pod is up and running.
 
-4. We are going to invoke OpenFaaS function on a message on Redis Subscriber.
+4.  We are going to invoke OpenFaaS function on a message on Redis Subscriber.
 
-5. Let's set up the Redis Database, Redis PubSub event-source as specified [here](https://argoproj.github.io/argo-events/setup/redis/).
-   Do not create the Redis sensor, we are going to create it in next step.
+5.  Let's set up the Redis Database, Redis PubSub event-source as specified [here](https://argoproj.github.io/argo-events/setup/redis/).
+    Do not create the Redis sensor, we are going to create it in next step.
 
-6. Let's create the sensor with OpenFaaS trigger.
+6.  Let's create the sensor with OpenFaaS trigger.
 
         apiVersion: argoproj.io/v1alpha1
         kind: Sensor
@@ -202,32 +200,32 @@ to invoke OpenFaaS function.
                       dest: bucket
                   method: POST
 
-7. Publish a message on `FOO` channel using `redis-cli`.
+7.  Publish a message on `FOO` channel using `redis-cli`.
 
         PUBLISH FOO hello
 
-8. As soon as you publish the message, the sensor will invoke the OpenFaaS function `gohash`.
+8.  As soon as you publish the message, the sensor will invoke the OpenFaaS function `gohash`.
 
 ## Kubeless
 
 Similar to REST API calls, you can easily invoke Kubeless functions using HTTP trigger.
 
-1. If you don't have Kubeless installed, follow the [installation](https://kubeless.io/docs/quick-start/).
+1.  If you don't have Kubeless installed, follow the [installation](https://kubeless.io/docs/quick-start/).
 
-2. Lets create a basic function.
+2.  Lets create a basic function.
 
         def hello(event, context):
           print event
           return event['data']
 
-3. Make sure the function pod and service is created.
+3.  Make sure the function pod and service is created.
 
-4. Now, we are going to invoke the Kubeless function when a message is placed on a NATS queue.
+4.  Now, we are going to invoke the Kubeless function when a message is placed on a NATS queue.
 
-5. Let's set up the NATS event-source. Follow [instructions](https://argoproj.github.io/argo-events/setup/nats/#setup) for details.
-   Do not create the NATS sensor, we are going to create it in next step.
+5.  Let's set up the NATS event-source. Follow [instructions](https://argoproj.github.io/argo-events/setup/nats/#setup) for details.
+    Do not create the NATS sensor, we are going to create it in next step.
 
-6. Let's create NATS sensor with HTTP trigger.
+6.  Let's create NATS sensor with HTTP trigger.
 
         apiVersion: argoproj.io/v1alpha1
         kind: Sensor
@@ -254,11 +252,11 @@ Similar to REST API calls, you can easily invoke Kubeless functions using HTTP t
                       dest: last_name
                   method: POST
 
-7. Once event-source and sensor pod are up and running, dispatch a message on `foo` subject using nats client.
+7.  Once event-source and sensor pod are up and running, dispatch a message on `foo` subject using nats client.
 
         go run main.go -s localhost foo '{"first_name": "foo", "last_name": "bar"}'
 
-8. It will invoke Kubeless function `hello`.
+8.  It will invoke Kubeless function `hello`.
 
         {'event-time': None, 'extensions': {'request': <LocalRequest: POST http://hello.kubeless.svc.cluster.local:8080/> }, 'event-type': None, 'event-namespace': None, 'data': '{"first_name":"foo","last_name":"bar"}', 'event-id': None}
 