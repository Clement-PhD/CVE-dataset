@@ -6,10 +6,9 @@ package freechips.rocketchip.rocket
 import chisel3._
 import chisel3.util.{Cat, log2Up, log2Ceil, log2Floor, Log2, Decoupled, Enum, Fill, Valid, Pipe}
 import freechips.rocketchip.util._
-import ALU._
 
-class MultiplierReq(dataBits: Int, tagBits: Int) extends Bundle {
-  val fn = Bits(SZ_ALU_FN.W)
+class MultiplierReq(dataBits: Int, tagBits: Int, aluFn: ALUFN = new ALUFN) extends Bundle {
+  val fn = Bits(aluFn.SZ_ALU_FN.W)
   val dw = Bits(SZ_DW.W)
   val in1 = Bits(dataBits.W)
   val in2 = Bits(dataBits.W)
@@ -21,8 +20,8 @@ class MultiplierResp(dataBits: Int, tagBits: Int) extends Bundle {
   val tag = UInt(tagBits.W)
 }
 
-class MultiplierIO(val dataBits: Int, val tagBits: Int) extends Bundle {
-  val req = Flipped(Decoupled(new MultiplierReq(dataBits, tagBits)))
+class MultiplierIO(val dataBits: Int, val tagBits: Int, aluFn: ALUFN = new ALUFN) extends Bundle {
+  val req = Flipped(Decoupled(new MultiplierReq(dataBits, tagBits, aluFn)))
   val kill = Input(Bool())
   val resp = Decoupled(new MultiplierResp(dataBits, tagBits))
 }
@@ -35,12 +34,12 @@ case class MulDivParams(
   divEarlyOutGranularity: Int = 1
 )
 
-class MulDiv(cfg: MulDivParams, width: Int, nXpr: Int = 32) extends Module {
+class MulDiv(cfg: MulDivParams, width: Int, nXpr: Int = 32, aluFn: ALUFN = new ALUFN) extends Module {
   private def minDivLatency = (cfg.divUnroll > 0).option(if (cfg.divEarlyOut) 3 else 1 + w/cfg.divUnroll)
   private def minMulLatency = (cfg.mulUnroll > 0).option(if (cfg.mulEarlyOut) 2 else w/cfg.mulUnroll)
   def minLatency: Int = (minDivLatency ++ minMulLatency).min
 
-  val io = IO(new MultiplierIO(width, log2Up(nXpr)))
+  val io = IO(new MultiplierIO(width, log2Up(nXpr), aluFn))
   val w = io.req.bits.in1.getWidth
   val mulw = if (cfg.mulUnroll == 0) w else (w + cfg.mulUnroll - 1) / cfg.mulUnroll * cfg.mulUnroll
   val fastMulW = if (cfg.mulUnroll == 0) false else w/2 > cfg.mulUnroll && w % (2*cfg.mulUnroll) == 0
@@ -59,15 +58,15 @@ class MulDiv(cfg: MulDivParams, width: Int, nXpr: Int = 32) extends Module {
   val remainder = Reg(Bits((2*mulw+2).W)) // div only needs 2*w+1 bits
 
   val mulDecode = List(
-    FN_MUL    -> List(Y, N, X, X),
-    FN_MULH   -> List(Y, Y, Y, Y),
-    FN_MULHU  -> List(Y, Y, N, N),
-    FN_MULHSU -> List(Y, Y, Y, N))
+    aluFn.FN_MUL    -> List(Y, N, X, X),
+    aluFn.FN_MULH   -> List(Y, Y, Y, Y),
+    aluFn.FN_MULHU  -> List(Y, Y, N, N),
+    aluFn.FN_MULHSU -> List(Y, Y, Y, N))
   val divDecode = List(
-    FN_DIV    -> List(N, N, Y, Y),
-    FN_REM    -> List(N, Y, Y, Y),
-    FN_DIVU   -> List(N, N, N, N),
-    FN_REMU   -> List(N, Y, N, N))
+    aluFn.FN_DIV    -> List(N, N, Y, Y),
+    aluFn.FN_REM    -> List(N, Y, Y, Y),
+    aluFn.FN_DIVU   -> List(N, N, N, N),
+    aluFn.FN_REMU   -> List(N, Y, N, N))
   val cmdMul :: cmdHi :: lhsSigned :: rhsSigned :: Nil =
     DecodeLogic(io.req.bits.fn, List(X, X, X, X),
       (if (cfg.divUnroll != 0) divDecode else Nil) ++ (if (cfg.mulUnroll != 0) mulDecode else Nil)).map(_.asBool)
@@ -180,19 +179,19 @@ class MulDiv(cfg: MulDivParams, width: Int, nXpr: Int = 32) extends Module {
   io.req.ready := state === s_ready
 }
 
-class PipelinedMultiplier(width: Int, latency: Int, nXpr: Int = 32) extends Module with ShouldBeRetimed {
+class PipelinedMultiplier(width: Int, latency: Int, nXpr: Int = 32, aluFn: ALUFN = new ALUFN) extends Module with ShouldBeRetimed {
   val io = IO(new Bundle {
-    val req = Flipped(Valid(new MultiplierReq(width, log2Ceil(nXpr))))
+    val req = Flipped(Valid(new MultiplierReq(width, log2Ceil(nXpr), aluFn)))
     val resp = Valid(new MultiplierResp(width, log2Ceil(nXpr)))
   })
 
   val in = Pipe(io.req)
 
   val decode = List(
-    FN_MUL    -> List(N, X, X),
-    FN_MULH   -> List(Y, Y, Y),
-    FN_MULHU  -> List(Y, N, N),
-    FN_MULHSU -> List(Y, Y, N))
+    aluFn.FN_MUL    -> List(N, X, X),
+    aluFn.FN_MULH   -> List(Y, Y, Y),
+    aluFn.FN_MULHU  -> List(Y, N, N),
+    aluFn.FN_MULHSU -> List(Y, Y, N))
   val cmdHi :: lhsSigned :: rhsSigned :: Nil =
     DecodeLogic(in.bits.fn, List(X, X, X), decode).map(_.asBool)
   val cmdHalf = (width > 32).B && in.bits.dw === DW_32