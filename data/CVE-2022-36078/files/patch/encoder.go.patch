@@ -87,11 +87,9 @@ func (e *Encoder) Encode(v interface{}) (err error) {
 
 func (e *Encoder) toWriter(bytes []byte) (err error) {
 	e.count += len(bytes)
-
 	if traceEnabled {
 		zlog.Debug("	> encode: appending", zap.Stringer("hex", HexBytes(bytes)), zap.Int("pos", e.count))
 	}
-
 	_, err = e.output.Write(bytes)
 	return
 }
@@ -257,7 +255,7 @@ func (e *Encoder) WriteFloat32(f float32, order binary.ByteOrder) (err error) {
 	}
 
 	if e.IsBorsh() {
-		if float64(f) == math.NaN() {
+		if math.IsNaN(float64(f)) {
 			return errors.New("NaN float value")
 		}
 	}
@@ -268,13 +266,14 @@ func (e *Encoder) WriteFloat32(f float32, order binary.ByteOrder) (err error) {
 
 	return e.toWriter(buf)
 }
+
 func (e *Encoder) WriteFloat64(f float64, order binary.ByteOrder) (err error) {
 	if traceEnabled {
 		zlog.Debug("encode: write float64", zap.Float64("val", f))
 	}
 
 	if e.IsBorsh() {
-		if float64(f) == math.NaN() {
+		if math.IsNaN(float64(f)) {
 			return errors.New("NaN float value")
 		}
 	}
@@ -312,14 +311,56 @@ func (e *Encoder) WriteCompactU16Length(ln int) (err error) {
 	return e.toWriter(buf)
 }
 
-// TODO: add rust string.
-// https://github.com/bmresearch/Solnet/blob/7826cc93ec6c997fc997a7a3c6be0f3511ca0c63/src/Solnet.Programs/Utilities/Serialization.cs#L219
-// public static byte[] EncodeRustString(string data)
-// {
-//     byte[] stringBytes = Encoding.ASCII.GetBytes(data);
-//     byte[] encoded = new byte[stringBytes.Length + sizeof(uint)];
+func reflect_writeArrayOfBytes(e *Encoder, l int, rv reflect.Value) error {
+	arr := make([]byte, l)
+	for i := 0; i < l; i++ {
+		arr[i] = byte(rv.Index(i).Uint())
+	}
+	return e.WriteBytes(arr, false)
+}
 
-//     encoded.WriteU32((uint) stringBytes.Length, 0);
-//     encoded.WriteSpan(stringBytes, sizeof(uint));
-//     return encoded;
-// }
+func reflect_writeArrayOfUint16(e *Encoder, l int, rv reflect.Value, order binary.ByteOrder) error {
+	arr := make([]byte, l*2)
+	for i := 0; i < l; i++ {
+		order.PutUint16(arr[i*2:], uint16(rv.Index(i).Uint()))
+	}
+	return e.WriteBytes(arr, false)
+}
+
+func reflect_writeArrayOfUint32(e *Encoder, l int, rv reflect.Value, order binary.ByteOrder) error {
+	arr := make([]byte, l*4)
+	for i := 0; i < l; i++ {
+		order.PutUint32(arr[i*4:], uint32(rv.Index(i).Uint()))
+	}
+	return e.WriteBytes(arr, false)
+}
+
+func reflect_writeArrayOfUint64(e *Encoder, l int, rv reflect.Value, order binary.ByteOrder) error {
+	arr := make([]byte, l*8)
+	for i := 0; i < l; i++ {
+		order.PutUint64(arr[i*8:], uint64(rv.Index(i).Uint()))
+	}
+	return e.WriteBytes(arr, false)
+}
+
+// reflect_writeArrayOfUint_ is used for writing arrays/slices of uints of any size.
+func reflect_writeArrayOfUint_(e *Encoder, l int, k reflect.Kind, rv reflect.Value, order binary.ByteOrder) error {
+	switch k {
+	// case reflect.Uint:
+	// 	// switch on system architecture (32 or 64 bit)
+	// 	if unsafe.Sizeof(uintptr(0)) == 4 {
+	// 		return reflect_writeArrayOfUint32(e, l, rv, order)
+	// 	}
+	// 	return reflect_writeArrayOfUint64(e, l, rv, order)
+	case reflect.Uint8:
+		return reflect_writeArrayOfBytes(e, l, rv)
+	case reflect.Uint16:
+		return reflect_writeArrayOfUint16(e, l, rv, order)
+	case reflect.Uint32:
+		return reflect_writeArrayOfUint32(e, l, rv, order)
+	case reflect.Uint64:
+		return reflect_writeArrayOfUint64(e, l, rv, order)
+	default:
+		return fmt.Errorf("unsupported kind: %v", k)
+	}
+}
