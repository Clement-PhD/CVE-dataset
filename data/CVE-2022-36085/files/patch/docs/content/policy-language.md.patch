@@ -1222,19 +1222,21 @@ Modules use the same syntax to declare dependencies on [Base and Virtual Documen
 
 ```live:import_data:module:read_only
 package opa.examples
+import future.keywords.in
 
 import data.servers
 
 http_servers[server] {
-    server := servers[_]
-    server.protocols[_] == "http"
+    some server in servers
+    "http" in server.protocols
 }
 ```
 
 Similarly, modules can declare dependencies on query arguments by specifying an import path that starts with `input`.
 
 ```live:import_input:module:read_only
 package opa.examples
+import future.keywords.in
 
 import input.user
 import input.method
@@ -1251,20 +1253,28 @@ allow {
 # allows users assigned a "dev" role to perform read-only operations.
 allow {
     method == "GET"
-    data.roles["dev"][_] == input.user
+    input.user in data.roles["dev"]
+}
+
+# allows user catherine access on Saturday and Sunday
+allow {
+    user == "catherine"
+    day := time.weekday(time.now_ns())
+    day in ["Saturday", "Sunday"]
 }
 ```
 
 Imports can include an optional `as` keyword to handle namespacing issues:
 
 ```live:import_namespacing:module:read_only
 package opa.examples
+import future.keywords.in
 
 import data.servers as my_servers
 
 http_servers[server] {
-    server := my_servers[_]
-    server.protocols[_] == "http"
+    some server in my_servers
+    "http" in server.protocols
 }
 ```
 
@@ -1423,7 +1433,9 @@ please use `some x in xs; not p(x)` instead.
 ## With Keyword
 
 The `with` keyword allows queries to programmatically specify values nested
-under the [input Document](../philosophy/#the-opa-document-model) and the [data Document](../philosophy/#the-opa-document-model).
+under the [input Document](../philosophy/#the-opa-document-model) or the
+[data Document](../philosophy/#the-opa-document-model), or built-in functions.
+
 For example, given the simple authorization policy in the [Imports](#imports)
 section, we can write a query that checks whether a particular request would be
 allowed:
@@ -1458,6 +1470,14 @@ not allow with input as {"user": "charlie", "method": "GET"} with data.roles as
 ```live:import_input/5:output
 ```
 
+```live:import_input/6:query:merge_down
+allow with input as {"user": "catherine", "method": "GET"}
+      with data.roles as {"dev": ["bob"]}
+      with time.weekday as "Sunday"
+```
+```live:import_input/6:output
+```
+
 The `with` keyword acts as a modifier on expressions. A single expression is
 allowed to have zero or more `with` modifiers. The `with` keyword has the
 following syntax:
@@ -1467,12 +1487,14 @@ following syntax:
 ```
 
 The `<target>`s must be references to values in the input document (or the input
-document itself) or data document.
+document itself) or data document, or references to built-in functions.
 
-> When applied to the `data` document, the `<target>` must not attempt to
-> partially define virtual documents. For example, given a virtual document at
-> path `data.foo.bar`, the compiler will generate an error if the policy
-> attempts to replace `data.foo.bar.baz`.
+{{< info >}}
+When applied to the `data` document, the `<target>` must not attempt to
+partially define virtual documents. For example, given a virtual document at
+path `data.foo.bar`, the compiler will generate an error if the policy
+attempts to replace `data.foo.bar.baz`.
+{{< /info >}}
 
 The `with` keyword only affects the attached expression. Subsequent expressions
 will see the unmodified value. The exception to this rule is when multiple
@@ -1494,6 +1516,81 @@ outer := result {
 }
 ```
 
+When `<target>` is a reference to a built-in function, like `http.send`, then
+its `<value>` can be any of the following:
+1. a value: `with http.send as {"body": {"success": true }}`
+2. a reference to another function: `with http.send as mock_http_send`
+3. a reference to another (possibly custom) built-in function: `with custom_builtin as less_strict_custom_builtin`.
+
+When the replacement value is a function, its arity needs to match the replaced
+function's arity; and the types must be compatible.
+
+Replacement functions can call the function they're replacing **without causing
+recursion**.
+See the following example:
+
+```live:with_builtins:module:read_only
+package opa.examples
+import future.keywords.in
+
+f(x) = count(x)
+
+mock_count(x) = 0 { "x" in x }
+mock_count(x) = count(x) { not "x" in x }
+```
+
+```live:with_builtins/1:query:merge_down
+f([1, 2, 3]) with count as mock_count
+```
+```live:with_builtins/1:output
+```
+
+```live:with_builtins/2:query:merge_down
+f(["x", "y", "z"]) with count as mock_count
+```
+```live:with_builtins/2:output
+```
+
+Each replacement function evaluation will start a new scope: it's valid to use
+`with <builtin1> as ...` in the body of the replacement function -- for example:
+
+```live:with_builtins_nested:module:read_only
+package opa.examples
+import future.keywords.in
+
+f(x) = count(x) {
+    rule_using_concat with concat as "foo,bar"
+}
+
+mock_count(x) = 0 { "x" in x }
+mock_count(x) = count(x) { not "x" in x }
+
+rule_using_concat {
+    concat(",", input.x) == "foo,bar"
+}
+```
+```live:with_builtins_nested/1:query:merge_down
+f(["x", "y", "z"]) with count as mock_count with input.x as ["baz"]
+```
+```live:with_builtins_nested/1:output
+```
+
+Note that function replacement via `with` does not affect the evaluation of
+the function arguments: if `input.x` is undefined, the replacement of `concat`
+does not change the result of the evaluation:
+
+```live:with_builtins_nested/2:query:merge_down
+count(input.x) with count as 3 with input.x as ["x"]
+```
+```live:with_builtins_nested/2:output
+```
+
+```live:with_builtins_nested/3:query:merge_down
+count(input.x) with count as 3 with input as {}
+```
+```live:with_builtins_nested/3:output:expect_undefined
+```
+
 ## Default Keyword
 
 The `default` keyword allows policies to define a default value for documents