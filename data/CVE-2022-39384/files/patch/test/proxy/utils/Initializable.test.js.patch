@@ -1,8 +1,8 @@
 const { expectRevert } = require('@openzeppelin/test-helpers');
-
 const { assert } = require('chai');
 
 const InitializableMock = artifacts.require('InitializableMock');
+const ConstructorInitializableMock = artifacts.require('ConstructorInitializableMock');
 const SampleChild = artifacts.require('SampleChild');
 
 contract('Initializable', function (accounts) {
@@ -31,15 +31,26 @@ contract('Initializable', function (accounts) {
       });
     });
 
-    context('after nested initialize', function () {
-      beforeEach('initializing', async function () {
-        await this.contract.initializeNested();
+    context('nested under an initializer', function () {
+      it('initializer modifier reverts', async function () {
+        await expectRevert(this.contract.initializerNested(), 'Initializable: contract is already initialized');
       });
 
-      it('initializer has run', async function () {
-        assert.isTrue(await this.contract.initializerRan());
+      it('onlyInitializing modifier succeeds', async function () {
+        await this.contract.onlyInitializingNested();
+        assert.isTrue(await this.contract.onlyInitializingRan());
       });
     });
+
+    it('cannot call onlyInitializable function outside the scope of an initializable function', async function () {
+      await expectRevert(this.contract.initializeOnlyInitializing(), 'Initializable: contract is not initializing');
+    });
+  });
+
+  it('nested initializer can run during construction', async function () {
+    const contract2 = await ConstructorInitializableMock.new();
+    assert.isTrue(await contract2.initializerRan());
+    assert.isTrue(await contract2.onlyInitializingRan());
   });
 
   describe('complex testing with inheritance', function () {