@@ -16,13 +16,15 @@
 
 import io.netty.handler.codec.CharSequenceValueConverter;
 import io.netty.handler.codec.DefaultHeaders;
+import io.netty.handler.codec.http.HttpHeaderValidationUtil;
 import io.netty.util.AsciiString;
 import io.netty.util.ByteProcessor;
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.UnstableApi;
 
 import static io.netty.handler.codec.http2.Http2Error.PROTOCOL_ERROR;
 import static io.netty.handler.codec.http2.Http2Exception.connectionError;
+import static io.netty.handler.codec.http2.Http2Headers.PseudoHeaderName.getPseudoHeader;
 import static io.netty.handler.codec.http2.Http2Headers.PseudoHeaderName.hasPseudoHeaderFormat;
 import static io.netty.util.AsciiString.CASE_INSENSITIVE_HASHER;
 import static io.netty.util.AsciiString.CASE_SENSITIVE_HASHER;
@@ -44,6 +46,7 @@ public void validateName(CharSequence name) {
                 PlatformDependent.throwException(connectionError(PROTOCOL_ERROR,
                         "empty headers are not allowed [%s]", name));
             }
+
             if (name instanceof AsciiString) {
                 final int index;
                 try {
@@ -69,6 +72,28 @@ public void validateName(CharSequence name) {
                     }
                 }
             }
+
+            if (hasPseudoHeaderFormat(name)) {
+                final Http2Headers.PseudoHeaderName pseudoHeader = getPseudoHeader(name);
+                if (pseudoHeader == null) {
+                    PlatformDependent.throwException(connectionError(
+                            PROTOCOL_ERROR, "Invalid HTTP/2 pseudo-header '%s' encountered.", name));
+                }
+            } else if (HttpHeaderValidationUtil.isConnectionHeader(name, true)) {
+                PlatformDependent.throwException(connectionError(
+                        PROTOCOL_ERROR, "Illegal connection-specific header '%s' encountered.", name));
+            }
+        }
+    };
+
+    private static final ValueValidator<CharSequence> VALUE_VALIDATOR = new ValueValidator<CharSequence>() {
+        @Override
+        public void validate(CharSequence value) {
+            int index = HttpHeaderValidationUtil.validateValidHeaderValue(value);
+            if (index != -1) {
+                throw new IllegalArgumentException("a header value contains prohibited character 0x" +
+                        Integer.toHexString(value.charAt(index)) + " at index " + index + '.');
+            }
         }
     };
 
@@ -104,6 +129,7 @@ public DefaultHttp2Headers(boolean validate) {
      * <a href="https://tools.ietf.org/html/rfc7540">rfc7540</a>. {@code false} to not validate header names.
      * @param arraySizeHint A hint as to how large the hash data structure should be.
      * The next positive power of two will be used. An upper bound may be enforced.
+     * @see DefaultHttp2Headers#DefaultHttp2Headers(boolean, boolean, int)
      */
     @SuppressWarnings("unchecked")
     public DefaultHttp2Headers(boolean validate, int arraySizeHint) {
@@ -115,6 +141,50 @@ public DefaultHttp2Headers(boolean validate, int arraySizeHint) {
               arraySizeHint);
     }
 
+    /**
+     * Create a new instance.
+     * @param validate {@code true} to validate header names according to
+     * <a href="https://tools.ietf.org/html/rfc7540">rfc7540</a>. {@code false} to not validate header names.
+     * @param validateValues {@code true} to validate header values according to
+     * <a href="https://datatracker.ietf.org/doc/html/rfc7230#section-3.2">rfc7230</a> and
+     * <a href="https://datatracker.ietf.org/doc/html/rfc5234#appendix-B.1">rfc5234</a>. Otherwise, {@code false}
+     * (the default) to not validate values.
+     * @param arraySizeHint A hint as to how large the hash data structure should be.
+     * The next positive power of two will be used. An upper bound may be enforced.
+     */
+    @SuppressWarnings("unchecked")
+    public DefaultHttp2Headers(boolean validate, boolean validateValues, int arraySizeHint) {
+        // Case sensitive compare is used because it is cheaper, and header validation can be used to catch invalid
+        // headers.
+        super(CASE_SENSITIVE_HASHER,
+                CharSequenceValueConverter.INSTANCE,
+                validate ? HTTP2_NAME_VALIDATOR : NameValidator.NOT_NULL,
+                arraySizeHint,
+                validateValues ? VALUE_VALIDATOR : (ValueValidator<CharSequence>) ValueValidator.NO_VALIDATION);
+    }
+
+    @Override
+    protected void validateName(NameValidator<CharSequence> validator, boolean forAdd, CharSequence name) {
+        super.validateName(validator, forAdd, name);
+        if (nameValidator() == HTTP2_NAME_VALIDATOR && forAdd && hasPseudoHeaderFormat(name)) {
+            if (contains(name)) {
+                PlatformDependent.throwException(connectionError(
+                        PROTOCOL_ERROR, "Duplicate HTTP/2 pseudo-header '%s' encountered.", name));
+            }
+        }
+    }
+
+    @Override
+    protected void validateValue(ValueValidator<CharSequence> validator, CharSequence name, CharSequence value) {
+        if (nameValidator() == HTTP2_NAME_VALIDATOR) {
+            if (HttpHeaderValidationUtil.isTeNotTrailers(name, value)) {
+                PlatformDependent.throwException(connectionError(PROTOCOL_ERROR,
+                        "Illegal value specified for the 'TE' header (only 'trailers' is allowed)."));
+            }
+        }
+        super.validateValue(validator, name, value);
+    }
+
     @Override
     public Http2Headers clear() {
         firstNonPseudo = head;