@@ -150,9 +150,9 @@ impl Compress {
             return Ok(Status::RunOk);
         }
         self.inner.raw.next_in = input.as_ptr() as *mut _;
-        self.inner.raw.avail_in = input.len() as c_uint;
+        self.inner.raw.avail_in = input.len().min(c_uint::MAX as usize) as c_uint;
         self.inner.raw.next_out = output.as_mut_ptr() as *mut _;
-        self.inner.raw.avail_out = output.len() as c_uint;
+        self.inner.raw.avail_out = output.len().min(c_uint::MAX as usize) as c_uint;
         unsafe {
             match ffi::BZ2_bzCompress(&mut *self.inner.raw, action as c_int) {
                 ffi::BZ_RUN_OK => Ok(Status::RunOk),
@@ -225,9 +225,9 @@ impl Decompress {
     /// Decompress a block of input into a block of output.
     pub fn decompress(&mut self, input: &[u8], output: &mut [u8]) -> Result<Status, Error> {
         self.inner.raw.next_in = input.as_ptr() as *mut _;
-        self.inner.raw.avail_in = input.len() as c_uint;
+        self.inner.raw.avail_in = input.len().min(c_uint::MAX as usize) as c_uint;
         self.inner.raw.next_out = output.as_mut_ptr() as *mut _;
-        self.inner.raw.avail_out = output.len() as c_uint;
+        self.inner.raw.avail_out = output.len().min(c_uint::MAX as usize) as c_uint;
         unsafe {
             match ffi::BZ2_bzDecompress(&mut *self.inner.raw) {
                 ffi::BZ_OK => Ok(Status::Ok),