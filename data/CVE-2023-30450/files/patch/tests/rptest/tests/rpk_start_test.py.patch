@@ -9,10 +9,12 @@
 
 from rptest.services.cluster import cluster
 from rptest.tests.redpanda_test import RedpandaTest
-from rptest.clients.rpk import RpkTool
+from rptest.clients.rpk import RpkTool, RpkException
 from rptest.clients.rpk_remote import RpkRemoteTool
 from rptest.services.redpanda import RedpandaService
+from rptest.services import tls
 
+import json
 import os
 import yaml
 import tempfile
@@ -28,6 +30,38 @@ def setUp(self):
         # Skip starting redpanda, so that test can explicitly start it
         pass
 
+    def write_tls_cert(self, node, tls_manager):
+        cert = tls_manager.create_cert(node.name)
+
+        self.logger.info(
+            f"Writing Redpanda node tls key file: {RedpandaService.TLS_SERVER_KEY_FILE}"
+        )
+        node.account.mkdirs(
+            os.path.dirname(RedpandaService.TLS_SERVER_KEY_FILE))
+        node.account.copy_to(cert.key, RedpandaService.TLS_SERVER_KEY_FILE)
+
+        self.logger.info(
+            f"Writing Redpanda node tls cert file: {RedpandaService.TLS_SERVER_CRT_FILE}"
+        )
+        node.account.mkdirs(
+            os.path.dirname(RedpandaService.TLS_SERVER_CRT_FILE))
+        node.account.copy_to(cert.crt, RedpandaService.TLS_SERVER_CRT_FILE)
+
+        self.logger.info(
+            f"Writing Redpanda node tls ca cert file: {RedpandaService.TLS_CA_CRT_FILE}"
+        )
+        node.account.mkdirs(os.path.dirname(RedpandaService.TLS_CA_CRT_FILE))
+        node.account.copy_to(tls_manager.ca.crt,
+                             RedpandaService.TLS_CA_CRT_FILE)
+
+    def rpc_server_tls(self):
+        return json.dumps({
+            "cert_file": RedpandaService.TLS_SERVER_CRT_FILE,
+            "enabled": True,
+            "key_file": RedpandaService.TLS_SERVER_KEY_FILE,
+            "truststore_file": RedpandaService.TLS_CA_CRT_FILE
+        })
+
     @cluster(num_nodes=1)
     def test_simple_start(self):
         """
@@ -203,3 +237,195 @@ def test_seastar_flag(self):
         # This was the original issue:
         assert not self.redpanda.search_log_any(
             f"\-\-abort-on-seastar-bad-alloc=true")
+
+    @cluster(num_nodes=3)
+    def test_rpc_tls_start(self):
+        """
+        Starts redpanda via rpk with rpc_server_tls and verify
+        that rpk treat the config file properly and we can produce
+        and consume from the cluster.
+        """
+
+        tls_manager = tls.TLSCertManager(self.logger)
+
+        # clean the node and write the redpanda.yaml with the
+        # rpc_server_tls configuration _before_ starting rp.
+        def setup_cluster(node):
+            self.redpanda.clean_node(node)
+            node.account.mkdirs(
+                os.path.dirname(RedpandaService.NODE_CONFIG_FILE))
+
+            rpk = RpkRemoteTool(self.redpanda, node)
+            rpk.mode_set("production")
+            rpk.config_set("redpanda.rpc_server_tls", self.rpc_server_tls())
+            self.write_tls_cert(node, tls_manager)
+
+            # We need to increase the upper limit of instances to avoid hitting
+            # the limits when TLS is enabled.
+            node.account.ssh("sysctl fs.inotify.max_user_instances=512")
+
+        self.redpanda._for_nodes(self.redpanda.nodes,
+                                 setup_cluster,
+                                 parallel=True)
+
+        seeds_str = ",".join(
+            [f"{n.account.hostname}" for n in self.redpanda.nodes])
+
+        # We start a 3 nodes cluster using the flags for rpk redpanda start.
+        def start_cluster(node):
+            base_args = f"--rpc-addr={node.account.hostname} --kafka-addr=dnslistener://{node.account.hostname}"
+            seeds_arg = f"--seeds={seeds_str}"
+            if self.redpanda.idx(node) == 1:
+                seeds_arg = ""
+            args = f"{base_args} {seeds_arg}"
+            self.redpanda.start_node_with_rpk(node, args, clean_node=False)
+
+            # We check that rpc_server_tls is enabled on start:
+            assert self.redpanda.search_log_node(
+                node, "redpanda.rpc_server_tls:{ enabled: 1")
+
+        self.redpanda._for_nodes(self.redpanda.nodes,
+                                 start_cluster,
+                                 parallel=True)
+
+        # To validate that everything works fine we check that
+        # formed a cluster and we can produce and consume from it
+        # even after restarting.
+        try:
+            nodes = self.rpk.cluster_info()
+            assert len(nodes) == 3
+
+            topic = "test-rpc"
+            self.rpk.create_topic(topic)
+
+            for i in range(50):
+                self.rpk.produce(topic, f"k-{i}", f"v-test-{i}", timeout=5)
+        except RpkException:
+            pass
+
+        self.redpanda.stop()
+        self.redpanda._for_nodes(self.redpanda.nodes,
+                                 start_cluster,
+                                 parallel=True)
+        try:
+            for i in range(50, 100):
+                self.rpk.produce(topic, f"k-{i}", f"v-test-{i}", timeout=5)
+
+            out = self.rpk.consume(topic, n=100)
+            assert "k-99" in out
+        except RpkException:
+            pass
+
+    @cluster(num_nodes=3)
+    def test_rpc_tls_list(self):
+        """
+        Starts redpanda via rpk with rpc_server_tls as a list
+        and check if rpk prints the warning in the logs
+        """
+        def setup_and_start(node):
+            self.redpanda.clean_node(node)
+            node.account.mkdirs(
+                os.path.dirname(RedpandaService.NODE_CONFIG_FILE))
+
+            rpk = RpkRemoteTool(self.redpanda, node)
+            rpk.mode_set("production")
+            # We add [] so rpk picks it up as a list.
+            rpk.config_set("redpanda.rpc_server_tls",
+                           f"[{self.rpc_server_tls()}]")
+
+            self.redpanda.start_node_with_rpk(node, clean_node=False)
+
+        self.redpanda._for_nodes(self.redpanda.nodes,
+                                 setup_and_start,
+                                 parallel=True)
+
+        # Check that we don't enable rpc and print a warning
+        assert self.redpanda.search_log_all(
+            "redpanda.rpc_server_tls:{ enabled: 0", self.redpanda.nodes)
+        assert self.redpanda.search_log_all(
+            "WARNING: Due to an old rpk bug, your redpanda.yaml's redpanda.rpc_server_tls property is an array",
+            self.redpanda.nodes)
+
+    @cluster(num_nodes=3)
+    def test_rpc_tls_enable(self):
+        """
+        Starts redpanda via rpk with rpc_server_tls as a list
+        (i.e no TLS) and test the process of enabling TLS and
+        restarting the cluster
+        """
+
+        # First we setup the cluster with rpc_server_tls as a list.
+        def setup_cluster(node):
+            self.redpanda.clean_node(node)
+            node.account.mkdirs(
+                os.path.dirname(RedpandaService.NODE_CONFIG_FILE))
+
+            rpk = RpkRemoteTool(self.redpanda, node)
+            rpk.mode_set("production")
+            rpk.config_set("redpanda.rpc_server_tls",
+                           f"[{self.rpc_server_tls()}]")
+            node.account.ssh("sysctl fs.inotify.max_user_instances=512")
+
+        self.redpanda._for_nodes(self.redpanda.nodes,
+                                 setup_cluster,
+                                 parallel=True)
+
+        seeds_str = ",".join(
+            [f"{n.account.hostname}" for n in self.redpanda.nodes])
+
+        def start_cluster(node):
+            base_args = f"--rpc-addr={node.account.hostname} --kafka-addr=dnslistener://{node.account.hostname}"
+            seeds_arg = f"--seeds={seeds_str}"
+            if self.redpanda.idx(node) == 1:
+                seeds_arg = ""
+            args = f"{base_args} {seeds_arg}"
+            self.redpanda.start_node_with_rpk(node, args, clean_node=False)
+
+        # On first start we validate that TLS is disabled and produce
+        # to a topic.
+        self.redpanda._for_nodes(self.redpanda.nodes,
+                                 start_cluster,
+                                 parallel=True)
+        assert self.redpanda.search_log_all(
+            "redpanda.rpc_server_tls:{ enabled: 0", self.redpanda.nodes)
+
+        try:
+            nodes = self.rpk.cluster_info()
+            assert len(nodes) == 3
+
+            topic = "test-rpc"
+            self.rpk.create_topic(topic)
+
+            for i in range(50):
+                self.rpk.produce(topic, f"k-{i}", f"v-test-{i}", timeout=5)
+        except RpkException:
+            pass
+
+        # Now we create the certs + write the correct config.
+        tls_manager = tls.TLSCertManager(self.logger)
+
+        for node in self.redpanda.nodes:
+            rpk = RpkRemoteTool(self.redpanda, node)
+            rpk.config_set("redpanda.rpc_server_tls", self.rpc_server_tls())
+            self.write_tls_cert(node, tls_manager)
+
+        # Restart and validate rpc_server_tls is enabled.
+        self.redpanda.stop()
+        self.redpanda._for_nodes(self.redpanda.nodes,
+                                 start_cluster,
+                                 parallel=True)
+        assert self.redpanda.search_log_all(
+            "redpanda.rpc_server_tls:{ enabled: 1", self.redpanda.nodes)
+
+        try:
+            nodes = self.rpk.cluster_info()
+            assert len(nodes) == 3
+
+            for i in range(50, 100):
+                self.rpk.produce(topic, f"k-{i}", f"v-test-{i}", timeout=5)
+
+            out = self.rpk.consume(topic, n=100)
+            assert "k-10" in out
+            assert "k-99" in out
+        except RpkException:
+            pass
