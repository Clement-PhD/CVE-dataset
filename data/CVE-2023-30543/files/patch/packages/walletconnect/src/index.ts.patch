@@ -125,15 +125,13 @@ export class WalletConnect extends Connector {
       await this.isomorphicInitialize()
       if (!this.provider?.connected) throw Error('No existing connection')
 
-      // for walletconnect, we always use sequential instead of parallel fetches because otherwise
-      // chainId defaults to 1 even if the connecting wallet isn't on mainnet
-      const accounts = await this.provider?.request<string[]>({ method: 'eth_accounts' })
+      // Wallets may resolve eth_chainId and hang on eth_accounts pending user interaction, which may include changing
+      // chains; they should be requested serially, with accounts first, so that the chainId can settle.
+      const accounts = await this.provider.request<string[]>({ method: 'eth_accounts' })
       if (!accounts.length) throw new Error('No accounts returned')
-      const chainId = await this.provider
-        .request<string | number>({ method: 'eth_chainId' })
-        .then((chainId) => parseChainId(chainId))
+      const chainId = await this.provider.request<string>({ method: 'eth_chainId' })
 
-      this.actions.update({ chainId, accounts })
+      this.actions.update({ chainId: parseChainId(chainId), accounts })
     } catch (error) {
       cancelActivation()
       throw error
@@ -147,7 +145,7 @@ export class WalletConnect extends Connector {
     // this early return clause catches some common cases if activate is called after connection has been established
     if (this.provider?.connected) {
       if (!desiredChainId || desiredChainId === this.provider.chainId) return
-      // beacuse the provider is already connected, we can ignore the suppressUserPrompts
+      // because the provider is already connected, we can ignore the suppressUserPrompts
       return this.provider.request<void>({
         method: 'wallet_switchEthereumChain',
         params: [{ chainId: `0x${desiredChainId.toString(16)}` }],
@@ -161,22 +159,21 @@ export class WalletConnect extends Connector {
 
     try {
       await this.isomorphicInitialize(desiredChainId)
+      if (!this.provider) throw new Error('No provider')
 
+      // Wallets may resolve eth_chainId and hang on eth_accounts pending user interaction, which may include changing
+      // chains; they should be requested serially, with accounts first, so that the chainId can settle.
       const accounts = await this.provider
-        ?.request<string[]>({ method: 'eth_requestAccounts' })
+        .request<string[]>({ method: 'eth_requestAccounts' })
         // if a user triggers the walletconnect modal, closes it, and then tries to connect again,
         // the modal will not trigger. by deactivating when this happens, we prevent the bug.
         .catch(async (error: Error) => {
           if (error?.message === 'User closed modal') await this.deactivate()
           throw error
         })
+      const chainId = await this.provider.request<string>({ method: 'eth_chainId' })
 
-      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
-      const chainId = await this.provider!.request<string | number>({ method: 'eth_chainId' }).then((chainId) =>
-        parseChainId(chainId)
-      )
-
-      this.actions.update({ chainId, accounts })
+      this.actions.update({ chainId: parseChainId(chainId), accounts })
     } catch (error) {
       cancelActivation()
       throw error