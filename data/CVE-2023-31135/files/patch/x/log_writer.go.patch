@@ -19,12 +19,10 @@ package x
 import (
 	"bufio"
 	"compress/gzip"
-	"crypto/aes"
-	"crypto/cipher"
+	"crypto/rand"
 	"encoding/binary"
 	"fmt"
 	"io"
-	"math/rand"
 	"os"
 	"path/filepath"
 	"strings"
@@ -41,7 +39,9 @@ const (
 	backupTimeFormat = "2006-01-02T15-04-05.000"
 	bufferSize       = 256 * 1024
 	flushInterval    = 10 * time.Second
-	VerificationText = "Hello World"
+	//  old logs before https://github.com/dgraph-io/dgraph/pull/8323 contain deprecated verification text in header
+	VerificationTextDeprecated = "Hello World"
+	VerificationText           = "dlroW olloH"
 )
 
 // This is done to ensure LogWriter always implement io.WriterCloser
@@ -54,7 +54,6 @@ type LogWriter struct {
 	Compress      bool
 	EncryptionKey []byte
 
-	baseIv      [12]byte
 	mu          sync.Mutex
 	size        int64
 	file        *os.File
@@ -108,12 +107,26 @@ func (l *LogWriter) Write(p []byte) (int, error) {
 	}
 
 	// if encryption is enabled store the data in encrypted way
+	// encrypted writes will be preceded by the following header
+	// #################################################################
+	// #####   [16]byte iv + [4]byte uint32(len(p)) + [:]byte p    #####
+	// #################################################################
 	if l.EncryptionKey != nil {
-		bytes, err := encrypt(l.EncryptionKey, l.baseIv, p)
+		iv := make([]byte, 16)
+		if _, err := rand.Read(iv); err != nil {
+			return 0, err
+		}
+
+		lengthHeader := make([]byte, 4)
+		binary.BigEndian.PutUint32(lengthHeader, uint32(len(p)))
+
+		cipherText, err := encrypt(l.EncryptionKey, iv, p)
 		if err != nil {
 			return 0, err
 		}
-		n, err := l.writer.Write(bytes)
+
+		allocation := append(append(iv, lengthHeader...), cipherText...)
+		n, err := l.writer.Write(allocation)
 		l.size = l.size + int64(n)
 		return n, err
 	}
@@ -172,29 +185,26 @@ func (l *LogWriter) flush() {
 	_ = l.file.Sync()
 }
 
-func encrypt(key []byte, baseIv [12]byte, src []byte) ([]byte, error) {
-	iv := make([]byte, 16)
-	copy(iv, baseIv[:])
-	binary.BigEndian.PutUint32(iv[12:], uint32(len(src)))
-	allocate, err := y.XORBlockAllocate(src, key, iv)
+func encrypt(key, iv, src []byte) ([]byte, error) {
+	ivCopy := make([]byte, 16)
+	copy(ivCopy, iv[:])
+	cipher, err := y.XORBlockAllocate(src, key, ivCopy)
 	if err != nil {
 		return nil, err
 	}
-	allocate = append(iv[12:], allocate...)
-	return allocate, nil
+	return cipher, nil
 }
 
-func decrypt(key []byte, baseIv [12]byte, src []byte) ([]byte, error) {
-	iv := make([]byte, 16)
-	copy(iv, baseIv[:])
-	binary.BigEndian.PutUint32(iv[12:], uint32(len(src)))
-	block, err := aes.NewCipher(key)
+// used to verify client has correct key and can decrypt audit log header
+func decrypt(key, iv, src []byte) ([]byte, error) {
+	ivCopy := make([]byte, 16)
+	copy(ivCopy, iv[:]) // todo: do we need to copy here?
+
+	plainText, err := y.XORBlockAllocate(src, key, ivCopy)
 	if err != nil {
 		return nil, err
 	}
-	stream := cipher.NewCTR(block, iv[:])
-	stream.XORKeyStream(src, src)
-	return src, nil
+	return plainText, nil
 }
 
 func (l *LogWriter) rotate() error {
@@ -245,12 +255,19 @@ func (l *LogWriter) open() error {
 		l.writer = bufio.NewWriterSize(l.file, bufferSize)
 
 		if l.EncryptionKey != nil {
-			_, _ = rand.Read(l.baseIv[:])
-			bytes, err := encrypt(l.EncryptionKey, l.baseIv, []byte(VerificationText))
+			iv := make([]byte, 16)
+			if _, err := rand.Read(iv); err != nil { // cve fix is here
+				return err
+			}
+			lengthInput := make([]byte, 4)
+			binary.BigEndian.PutUint32(lengthInput, uint32(len(VerificationText))) // header has 16+4 bytes now
+
+			bytes, err := encrypt(l.EncryptionKey, iv, []byte(VerificationText))
 			if err != nil {
 				return err
 			}
-			if _, err = l.writer.Write(append(l.baseIv[:], bytes[:]...)); err != nil {
+			cipher := append(append(iv, lengthInput...), bytes...)
+			if _, err = l.writer.Write(cipher); err != nil {
 				return err
 			}
 		}
@@ -275,19 +292,22 @@ func (l *LogWriter) open() error {
 
 	l.file = f
 	if l.EncryptionKey != nil {
-		// If not able to read the baseIv, then this file might be corrupted.
+		// initialize byte slice for iv
+		iv := make([]byte, 16)
+		// If not able to read the iv, then this file might be corrupted.
 		// open the new file in that case
-		if _, err = l.file.ReadAt(l.baseIv[:], 0); err != nil {
+		if _, err = l.file.ReadAt(iv, 0); err != nil {
 			_ = l.file.Close()
 			return openNew()
 		}
-		text := make([]byte, 11)
-		if _, err := f.ReadAt(text, 16); err != nil {
+		ct := make([]byte, len(VerificationText)) // size=11
+		// veritification text starts at offset 20
+		if _, err := f.ReadAt(ct, 20); err != nil {
 			_ = f.Close()
 			return openNew()
 		}
-		if t, err := decrypt(l.EncryptionKey, l.baseIv, text); err != nil ||
-			string(t) != VerificationText {
+		t, err := decrypt(l.EncryptionKey, iv, ct)
+		if err != nil || string(t) != VerificationText {
 			// different encryption key. Better to open new file here
 			_ = f.Close()
 			return openNew()