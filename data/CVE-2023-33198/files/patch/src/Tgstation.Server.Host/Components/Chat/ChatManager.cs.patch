@@ -232,7 +232,6 @@ public async Task ChangeChannels(long connectionId, IEnumerable<Models.ChatChann
 					channelIdCounter += (ulong)results.Count;
 				}
 
-				Task trackingContextUpdateTask;
 				lock (mappedChannels)
 				{
 					lock (providers)
@@ -245,16 +244,13 @@ public async Task ChangeChannels(long connectionId, IEnumerable<Models.ChatChann
 						mappedChannels.Add(newId, newMapping);
 						newMapping.Channel.RealId = newId;
 					}
-
-					lock (trackingContexts)
-						trackingContextUpdateTask = Task.WhenAll(
-							trackingContexts.Select(
-								x => x.UpdateChannels(
-									mappedChannels.Select(y => y.Value.Channel).ToList(),
-									cancellationToken)));
 				}
 
-				await trackingContextUpdateTask;
+				// we only want to update contexts if everything at startup has connected once already
+				// otherwise we could send an incomplete channel set to the DMAPI, which will then spout all its queued messages into it instead of all relevant chatbots
+				// The watchdog can call this if it needs to after starting up
+				if (initialProviderConnectionsTask.IsCompleted)
+					await UpdateTrackingContexts(cancellationToken);
 			}
 			finally
 			{
@@ -333,35 +329,33 @@ public void QueueMessage(MessageContent message, IEnumerable<ulong> channelIds)
 			if (channelIds == null)
 				throw new ArgumentNullException(nameof(channelIds));
 
-			var task = SendMessage(
-				channelIds,
-				null,
-				message,
-				handlerCts.Token);
-			AddMessageTask(task);
+			QueueMessageInternal(message, () => channelIds, false);
 		}
 
 		/// <inheritdoc />
-		public async Task QueueWatchdogMessage(string message, CancellationToken cancellationToken)
+		public void QueueWatchdogMessage(string message)
 		{
-			List<ulong> wdChannels = null;
+			if (message == null)
+				throw new ArgumentNullException(nameof(message));
+
 			message = String.Format(CultureInfo.InvariantCulture, "WD: {0}", message);
 
 			if (!initialProviderConnectionsTask.IsCompleted)
 				logger.LogTrace("Waiting for initial provider connections before sending watchdog message...");
 
-			await initialProviderConnectionsTask.WithToken(cancellationToken);
-
-			// so it doesn't change while we're using it
-			lock (mappedChannels)
-				wdChannels = mappedChannels.Where(x => x.Value.IsWatchdogChannel).Select(x => x.Key).ToList();
-
-			QueueMessage(
+			// Reimplementing QueueMessage
+			QueueMessageInternal(
 				new MessageContent
 				{
 					Text = message,
 				},
-				wdChannels);
+				() =>
+				{
+					// so it doesn't change while we're using it
+					lock (mappedChannels)
+						return mappedChannels.Where(x => x.Value.IsWatchdogChannel).Select(x => x.Key).ToList();
+				},
+				true);
 		}
 
 		/// <inheritdoc />
@@ -403,10 +397,10 @@ public async Task QueueWatchdogMessage(string message, CancellationToken cancell
 								gitHubRepo,
 								channelMapping.ProviderChannelId,
 								localCommitPushed,
-								handlerCts.Token)
-								;
+								handlerCts.Token);
 
-							callbacks.Add(callback);
+							lock (callbacks)
+								callbacks.Add(callback);
 						}
 						catch (Exception ex)
 						{
@@ -419,12 +413,17 @@ public async Task QueueWatchdogMessage(string message, CancellationToken cancell
 
 			AddMessageTask(task);
 
-			return (errorMessage, dreamMakerOutput) => AddMessageTask(
-				Task.WhenAll(
+			async Task CollateTasks(string errorMessage, string dreamMakerOutput)
+			{
+				await task;
+				await Task.WhenAll(
 					callbacks.Select(
 						x => x(
 							errorMessage,
-							dreamMakerOutput))));
+							dreamMakerOutput)));
+			}
+
+			return (errorMessage, dreamMakerOutput) => AddMessageTask(CollateTasks(errorMessage, dreamMakerOutput));
 		}
 
 		/// <inheritdoc />
@@ -472,6 +471,38 @@ public IChatTrackingContext CreateTrackingContext()
 			return context;
 		}
 
+		/// <inheritdoc />
+		public async Task UpdateTrackingContexts(CancellationToken cancellationToken)
+		{
+			var logMessageSent = 0;
+			async Task UpdateTrackingContext(IChatTrackingContext channelSink, IEnumerable<ChannelRepresentation> channels)
+			{
+				if (Interlocked.Exchange(ref logMessageSent, 1) == 0)
+
+				await channelSink.UpdateChannels(channels, cancellationToken);
+			}
+
+			var waitingForInitialConnection = !initialProviderConnectionsTask.IsCompleted;
+			if (waitingForInitialConnection)
+			{
+				logger.LogTrace("Waiting for initial chat bot connections before updating tracking contexts...");
+				await initialProviderConnectionsTask.WithToken(cancellationToken);
+			}
+
+			List<Task> tasks;
+			lock (mappedChannels)
+				lock (trackingContexts)
+					tasks = trackingContexts.Select(x => UpdateTrackingContext(x, mappedChannels.Select(y => y.Value.Channel))).ToList();
+
+			if (waitingForInitialConnection)
+				if (tasks.Count > 0)
+					logger.LogTrace("Updating chat tracking contexts...");
+				else
+					logger.LogTrace("No chat tracking contexts to update");
+
+			await Task.WhenAll(tasks);
+		}
+
 		/// <inheritdoc />
 		public void RegisterCommandHandler(ICustomCommandHandler customCommandHandler)
 		{
@@ -492,13 +523,15 @@ public async Task DeleteConnection(long connectionId, CancellationToken cancella
 				{
 					await provider.Disconnect(cancellationToken);
 				}
-				finally
+				catch (Exception ex)
 				{
-					await provider.DisposeAsync();
-					var duration = DateTimeOffset.UtcNow - startTime;
-					if (duration.TotalSeconds > 3)
-						logger.LogWarning("Disconnecting a {providerType} took {totalSeconds}s!", provider.GetType().Name, duration.TotalSeconds);
+					logger.LogError(ex, "Error disconnecting connection {connectionId}!", connectionId);
 				}
+
+				await provider.DisposeAsync();
+				var duration = DateTimeOffset.UtcNow - startTime;
+				if (duration.TotalSeconds > 3)
+					logger.LogWarning("Disconnecting a {providerType} took {totalSeconds}s!", provider.GetType().Name, duration.TotalSeconds);
 			}
 			else
 				logger.LogTrace("DeleteConnection: ID {connectionId} doesn't exist!", connectionId);
@@ -906,6 +939,12 @@ async Task MonitorMessages(CancellationToken cancellationToken)
 					// process completed ones
 					foreach (var completedMessageTaskKvp in messageTasks.Where(x => x.Value.IsCompleted).ToList())
 					{
+						var provider = completedMessageTaskKvp.Key;
+						messageTasks.Remove(provider);
+
+						if (provider.Disposed) // valid to receive one, but don't process it
+							continue;
+
 						var message = await completedMessageTaskKvp.Value;
 						var messageNumber = Interlocked.Increment(ref messagesProcessed);
 
@@ -915,7 +954,7 @@ async Task WrapProcessMessage()
 							using (LogContext.PushProperty(SerilogContextHelper.ChatMessageIterationContextProperty, messageNumber))
 								try
 								{
-									await ProcessMessage(completedMessageTaskKvp.Key, message, false, cancellationToken);
+									await ProcessMessage(provider, message, false, cancellationToken);
 								}
 								catch (Exception ex)
 								{
@@ -926,8 +965,6 @@ async Task WrapProcessMessage()
 						}
 
 						activeProcessingTask = WrapProcessMessage();
-
-						messageTasks.Remove(completedMessageTaskKvp.Key);
 					}
 				}
 			}
@@ -957,12 +994,17 @@ async Task WrapProcessMessage()
 		/// <returns>A <see cref="Task"/> representing the running operation.</returns>
 		Task SendMessage(IEnumerable<ulong> channelIds, Message replyTo, MessageContent message, CancellationToken cancellationToken)
 		{
+			channelIds = channelIds.ToList();
+
 			logger.LogTrace(
-				"Chat send \"{message}\"{embed} to channels: {channelIdsCommaSeperated}",
+				"Chat send \"{message}\"{embed} to channels: [{channelIdsCommaSeperated}]",
 				message.Text,
 				message.Embed != null ? " (with embed)" : String.Empty,
 				String.Join(", ", channelIds));
 
+			if (!channelIds.Any())
+				return Task.CompletedTask;
+
 			return Task.WhenAll(
 				channelIds.Select(x =>
 				{
@@ -1001,14 +1043,42 @@ async Task Wrap(Task originalTask)
 				{
 					await task;
 				}
+				catch (OperationCanceledException ex)
+				{
+					logger.LogDebug(ex, "Async chat message cancelled!");
+				}
 				catch (Exception ex)
 				{
-					logger.LogWarning(ex, "Error in asynchronous chat message!");
+					logger.LogError(ex, "Error in asynchronous chat message!");
 				}
 			}
 
 			lock (handlerCts)
 				messageSendTask = Wrap(messageSendTask);
 		}
+
+		/// <summary>
+		/// Adds a given <paramref name="message"/> to the send queue.
+		/// </summary>
+		/// <param name="message">The <see cref="MessageContent"/> being sent.</param>
+		/// <param name="channelIdsFactory">A <see cref="Func{TResult}"/> to retrieve he <see cref="Models.ChatChannel.Id"/>s of the <see cref="Models.ChatChannel"/>s to send to.</param>
+		/// <param name="waitForConnections">If <see langword="true"/>, the message send will wait for <see cref="initialProviderConnectionsTask"/> to complete before running.</param>
+		void QueueMessageInternal(MessageContent message, Func<IEnumerable<ulong>> channelIdsFactory, bool waitForConnections)
+		{
+			async Task SendMessageTask()
+			{
+				var cancellationToken = handlerCts.Token;
+				if (waitForConnections)
+					await initialProviderConnectionsTask.WithToken(cancellationToken);
+
+				await SendMessage(
+					channelIdsFactory(),
+					null,
+					message,
+					cancellationToken);
+			}
+
+			AddMessageTask(SendMessageTask());
+		}
 	}
 }