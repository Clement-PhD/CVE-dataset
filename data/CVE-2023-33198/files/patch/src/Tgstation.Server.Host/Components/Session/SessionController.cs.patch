@@ -180,6 +180,7 @@ public ApiValidationStatus ApiValidationStatus
 		/// <param name="chat">The value of <see cref="chat"/>.</param>
 		/// <param name="chatTrackingContext">The value of <see cref="chatTrackingContext"/>.</param>
 		/// <param name="assemblyInformationProvider">The <see cref="IAssemblyInformationProvider"/> for the <see cref="SessionController"/>.</param>
+		/// <param name="asyncDelayer">The <see cref="IAsyncDelayer"/> for the <see cref="SessionController"/>.</param>
 		/// <param name="logger">The value of <see cref="Chunker.Logger"/>.</param>
 		/// <param name="postLifetimeCallback">The <see cref="Func{TResult}"/> returning a <see cref="Task"/> to be run after the <paramref name="process"/> ends.</param>
 		/// <param name="startupTimeout">The optional time to wait before failing the <see cref="LaunchResult"/>.</param>
@@ -195,6 +196,7 @@ public ApiValidationStatus ApiValidationStatus
 			IBridgeRegistrar bridgeRegistrar,
 			IChatManager chat,
 			IAssemblyInformationProvider assemblyInformationProvider,
+			IAsyncDelayer asyncDelayer,
 			ILogger<SessionController> logger,
 			Func<Task> postLifetimeCallback,
 			uint? startupTimeout,
@@ -219,7 +221,11 @@ public ApiValidationStatus ApiValidationStatus
 
 			rebootTcs = new TaskCompletionSource();
 			primeTcs = new TaskCompletionSource();
-			initialBridgeRequestTcs = new TaskCompletionSource();
+
+			// Run this asynchronously because we want to try to avoid any effects sending topics to the server while the initial bridge request is processing
+			// It MAY be the source of a DD crash. See this gist https://gist.github.com/Cyberboss/7776bbeff3a957d76affe0eae95c9f14
+			// Worth further investigation as to if that sequence of events is a reliable crash vector and opening a BYOND bug if it is
+			initialBridgeRequestTcs = new TaskCompletionSource(TaskCreationOptions.RunContinuationsAsynchronously);
 			reattachTopicCts = new CancellationTokenSource();
 			synchronizationLock = new object();
 
@@ -246,6 +252,7 @@ async Task<int> WrapLifetime()
 
 			LaunchResult = GetLaunchResult(
 				assemblyInformationProvider,
+				asyncDelayer,
 				startupTimeout,
 				reattached,
 				apiValidate);
@@ -508,12 +515,14 @@ public Task UpdateChannels(IEnumerable<ChannelRepresentation> newChannels, Cance
 		/// The <see cref="Task{TResult}"/> for <see cref="LaunchResult"/>.
 		/// </summary>
 		/// <param name="assemblyInformationProvider">The <see cref="IAssemblyInformationProvider"/>.</param>
+		/// <param name="asyncDelayer">The <see cref="IAsyncDelayer"/>.</param>
 		/// <param name="startupTimeout">The, optional, startup timeout in seconds.</param>
 		/// <param name="reattached">If DreamDaemon was reattached.</param>
 		/// <param name="apiValidate">If this is a DMAPI validation session.</param>
 		/// <returns>A <see cref="Task{TResult}"/> resulting in the <see cref="Session.LaunchResult"/> for the operation.</returns>
 		async Task<LaunchResult> GetLaunchResult(
 			IAssemblyInformationProvider assemblyInformationProvider,
+			IAsyncDelayer asyncDelayer,
 			uint? startupTimeout,
 			bool reattached,
 			bool apiValidate)
@@ -526,7 +535,7 @@ public Task UpdateChannels(IEnumerable<ChannelRepresentation> newChannels, Cance
 			var toAwait = Task.WhenAny(startupTask, process.Lifetime);
 
 			if (startupTimeout.HasValue)
-				toAwait = Task.WhenAny(toAwait, Task.Delay(TimeSpan.FromSeconds(startupTimeout.Value)));
+				toAwait = Task.WhenAny(toAwait, asyncDelayer.Delay(TimeSpan.FromSeconds(startupTimeout.Value), default)); // DCT: None available, task will clean up after delay
 
 			Logger.LogTrace(
 				"Waiting for LaunchResult based on {launchResultCompletionCause}{possibleTimeout}...",