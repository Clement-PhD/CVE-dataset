@@ -657,7 +657,6 @@ dao_input_storing(void)
   uint8_t subopt_type;
   uip_ipaddr_t prefix;
   uip_ds6_route_t *rep;
-  uint8_t buffer_length;
   int pos;
   int len;
   int i;
@@ -673,13 +672,18 @@ dao_input_storing(void)
   uip_ipaddr_copy(&dao_sender_addr, &UIP_IP_BUF->srcipaddr);
 
   buffer = UIP_ICMP_PAYLOAD;
-  buffer_length = uip_len - uip_l3_icmp_hdr_len;
+  uint16_t buffer_length = uip_len - uip_l3_icmp_hdr_len;
+  if(buffer_length < 4) {
+    LOG_WARN("Dropping incomplete DAO (%"PRIu16" < %d)\n",
+	     buffer_length, 4);
+    return;
+  }
+
+  uint16_t last_valid_pos = buffer_length - 1;
 
   pos = 0;
   instance_id = buffer[pos++];
-
   instance = rpl_get_instance(instance_id);
-
   lifetime = instance->default_lifetime;
 
   flags = buffer[pos++];
@@ -692,6 +696,12 @@ dao_input_storing(void)
 
   /* Is the DAG ID present? */
   if(flags & RPL_DAO_D_FLAG) {
+      if(last_valid_pos < pos + 16) {
+	LOG_WARN("Dropping incomplete DAO (%"PRIu16" < %d)\n",
+		 last_valid_pos, pos + 16);
+	return;
+      }
+
     if(memcmp(&dag->dag_id, &buffer[pos], sizeof(dag->dag_id))) {
       LOG_INFO("Ignoring a DAO for a DAG different from ours\n");
       return;
@@ -739,12 +749,22 @@ dao_input_storing(void)
       len = 1;
     } else {
       /* The option consists of a two-byte header and a payload. */
+      if(last_valid_pos < i + 1) {
+	LOG_WARN("Dropping incomplete DAO (%"PRIu16" < %d)\n",
+		 last_valid_pos, i + 1);
+	return;
+      }
       len = 2 + buffer[i + 1];
     }
 
     switch(subopt_type) {
     case RPL_OPTION_TARGET:
       /* Handle the target option. */
+      if(last_valid_pos < i + 3) {
+	LOG_WARN("Dropping incomplete DAO (%"PRIu16" < %d)\n",
+		 last_valid_pos, i + 3);
+	return;
+      }
       prefixlen = buffer[i + 3];
       if(prefixlen == 0) {
         /* Ignore option targets with a prefix length of 0. */
@@ -755,7 +775,7 @@ dao_input_storing(void)
         return;
       }
       if(i + 4 + ((prefixlen + 7) / CHAR_BIT) > buffer_length) {
-        LOG_ERR("Insufficient space to copy RPL Target of %d bits\n",
+        LOG_ERR("Incomplete DAO target option with prefix length of %d bits\n",
                 prefixlen);
         return;
       }
@@ -766,6 +786,11 @@ dao_input_storing(void)
       /* The path sequence and control are ignored. */
       /*      pathcontrol = buffer[i + 3];
               pathsequence = buffer[i + 4];*/
+      if(last_valid_pos < i + 5) {
+	LOG_WARN("Dropping incomplete DAO (%"PRIu16" < %d)\n",
+		 last_valid_pos, i + 5);
+	return;
+      }
       lifetime = buffer[i + 5];
       /* The parent address is also ignored. */
       break;
@@ -948,7 +973,6 @@ dao_input_nonstoring(void)
   uint8_t flags;
   uint8_t subopt_type;
   uip_ipaddr_t prefix;
-  uint8_t buffer_length;
   int pos;
   int len;
   int i;
@@ -964,7 +988,14 @@ dao_input_nonstoring(void)
   memset(&dao_parent_addr, 0, 16);
 
   buffer = UIP_ICMP_PAYLOAD;
-  buffer_length = uip_len - uip_l3_icmp_hdr_len;
+  uint16_t buffer_length = uip_len - uip_l3_icmp_hdr_len;
+  if(buffer_length < 4) {
+    LOG_WARN("Dropping incomplete DAO (%"PRIu16" < %d)\n",
+	     buffer_length, 4);
+    return;
+  }
+
+  uint16_t last_valid_pos = buffer_length - 1;
 
   pos = 0;
   instance_id = buffer[pos++];
@@ -979,6 +1010,10 @@ dao_input_nonstoring(void)
   dag = instance->current_dag;
   /* Is the DAG ID present? */
   if(flags & RPL_DAO_D_FLAG) {
+    if(pos + sizeof(dag->dag_id) > buffer_length) {
+      LOG_WARN("Insufficient data to read DAG ID from DAO\n");
+      return;
+    }
     if(memcmp(&dag->dag_id, &buffer[pos], sizeof(dag->dag_id))) {
       LOG_INFO("Ignoring a DAO for a DAG different from ours\n");
       return;
@@ -993,12 +1028,22 @@ dao_input_nonstoring(void)
       len = 1;
     } else {
       /* The option consists of a two-byte header and a payload. */
+      if(last_valid_pos < i + 1) {
+	LOG_WARN("Dropping incomplete DAO (%"PRIu16" < %d)\n",
+		 last_valid_pos, i + 1);
+	return;
+      }
       len = 2 + buffer[i + 1];
     }
 
     switch(subopt_type) {
     case RPL_OPTION_TARGET:
       /* Handle the target option. */
+      if(last_valid_pos < i + 3) {
+	LOG_WARN("Dropping incomplete DAO (%"PRIu16" < %d)\n",
+		 last_valid_pos, i + 3);
+	return;
+      }
       prefixlen = buffer[i + 3];
       if(prefixlen == 0) {
         /* Ignore option targets with a prefix length of 0. */
@@ -1009,17 +1054,23 @@ dao_input_nonstoring(void)
         return;
       }
       if(i + 4 + ((prefixlen + 7) / CHAR_BIT) > buffer_length) {
-        LOG_ERR("Insufficient space to copy RPL Target of %d bits\n",
+        LOG_ERR("Incomplete DAO target option with prefix length of %d bits\n",
                 prefixlen);
         return;
       }
+
       memset(&prefix, 0, sizeof(prefix));
       memcpy(&prefix, buffer + i + 4, (prefixlen + 7) / CHAR_BIT);
       break;
     case RPL_OPTION_TRANSIT:
       /* The path sequence and control are ignored. */
       /*      pathcontrol = buffer[i + 3];
               pathsequence = buffer[i + 4];*/
+      if(i + 6 + 16 > buffer_length) {
+	LOG_WARN("Incomplete DAO transit option (%d > %"PRIu16")\n",
+		 i + 6 + 16, buffer_length);
+	return;
+      }
       lifetime = buffer[i + 5];
       if(len >= 20) {
         memcpy(&dao_parent_addr, buffer + i + 6, 16);
@@ -1070,6 +1121,11 @@ dao_input(void)
   LOG_INFO_6ADDR(&UIP_IP_BUF->srcipaddr);
   LOG_INFO_("\n");
 
+  if(uip_len <= uip_l3_icmp_hdr_len) {
+    LOG_WARN("Ignoring DAO ICMPv6 message without DAO header\n");
+    goto discard;
+  }
+
   instance_id = UIP_ICMP_PAYLOAD[0];
   instance = rpl_get_instance(instance_id);
   if(instance == NULL) {