// SPDX-FileCopyrightText: 2022 Carl Schwan <carl@carlschwan.eu>
// SPDX-License-Identifier: AGPL-3.0-or-later

import { generateOcsUrl } from '@nextcloud/router'
import axios from '@nextcloud/axios'
import { EncryptedFile, encryptStringAsymmetric } from './crypto.js'

/**
 * @typedef {object} EncryptedFileKey
 * @property {string} key - Encryption key of the file (ex: "jtboLmgGR1OQf2uneqCVHpklQLlIwWL5TXAQ0keK")
 * @property {string} filename - Unencrypted file name (ex: "/foo/test.txt")
 * @property {string} mimetype - Mimetype, if unknown use "application/octet-stream" (ex: "plain/text")
 * @property {object} version - Which encryption method version was used? For updating in the future. (ex: 1)
 */

/**
 * @typedef {object} EncryptedFileMetadata
 * @property {string} encrypted - Encrypted JSON payload to the currently used metadata key. Encryption algorithm: AES/GCM/NoPadding (128 bit key size) with metadata key (symmetric)
 * @property {string} initializationVector - Initialization vector (ex: "+mHu52HyZq+pAAIN")
 * @property {string} authenticationTag - Authentication tag of the file (ex: "LYRaJghbZUzBiNWb51ypWw==")
 * @property {number} metadataKey - Which metadata key to use (ex: 1)
 */

/**
 * @typedef {object} EncryptedFolderMetadata
 * @property {Object<string, EncryptedFileMetadata>} files - A JSON blob referencing all files
 * @property {Object<string, EncryptedFileMetadata>} [filedrop] - A JSON blob referencing dropped files
 * @property {object} metadata - Metadata about the share
 * @property {Object<string, string>} metadata.metadataKeys - Following, each metadata key is encrypted to all public keys that have access to the share. It is generated by client on first upload. A blob of keys useful for key rotation. If a recipient has been removed of a share a new metadata key will be generated and the client always uses the newest one. Encrypted files refer to which metadata key to use. In case of updating a file the client should update it with the new metadata encryption key. Encryption algorithm: RSA/ECB/OAEPWithSHA-256AndMGF1Padding, encrypted via private/public key (asymmetric)
 * @property {Object<string, object>} metadata.sharing - The following blob contains the reference to all keys that have access to the share. Encrypted payload to the currently used metadata key Encryption algorithm: AES/GCM/NoPadding (128 bit key size)  with metadata key from above (symmetric)
 * @property {Object<string, string>} metadata.sharing.recipient - Name of recipients as well as public keys of the recipients
 * @property {number} metadata.version - The version of the metadata file (ex: 1)
 */

export default class FolderMetaData {

	/** @type {EncryptedFolderMetadata?} */
	metadata

	/**
	 * @param {number} folderId
	 */
	constructor(folderId) {
		this.folderId = folderId
		this.metadata = null
		this.ocsUrl = generateOcsUrl(
			'apps/end_to_end_encryption/api/v1/meta-data/{folderId}',
			{
				folderId: this.folderId,
			}
		)
	}

	/**
	 * @param {?string} shareToken - The optional share token if this is a file drop.
	 */
	async retrieveMetadata(shareToken) {
		const { data: { ocs: { meta, data } } } = await axios.get(
			this.ocsUrl,
			{
				headers: {
					'x-e2ee-supported': true,
				},
				params: {
					shareToken,
				},
			},
		)

		if (meta.statuscode !== 200) {
			throw new Error(`Failed to retrieve metadata: ${meta.message}`)
		}

		this.metadata = JSON.parse(data['meta-data'])
	}

	/**
	 * @param {string} lockToken - The optional lock token if the folder was already locked.
	 * @param {?string} shareToken - The optional share token if this is a file drop.
	 */
	async uploadMetadata(lockToken, shareToken) {
		const { data: { ocs: { meta } } } = await axios.put(
			`${this.ocsUrl}/filedrop`,
			{
				fileDrop: JSON.stringify(this.metadata?.filedrop ?? {}),
			},
			{
				headers: {
					'x-e2ee-supported': true,
				},
				params: {
					'e2e-token': lockToken,
					shareToken,
				},
			},
		)

		if (meta.statuscode !== 200) {
			throw new Error(`Failed to upload metadata: ${meta.message}`)
		}
	}

	/**
	 * @param {EncryptedFile} file
	 * @param {Uint8Array} tag
	 * @param {string} publicKey
	 * @return {Promise<void>}
	 */
	async addFileDrop(file, tag, publicKey) {
		if (this.metadata === null) {
			throw new Error('metadata is null. Please call retrieveMetadata first.')
		}

		if (!this.metadata.filedrop) {
			this.metadata.filedrop = {}
		}

		const rawFileEncryptionKey = await window.crypto.subtle.exportKey('raw', await file.getEncryptionKey())

		/** @type {EncryptedFileKey} */
		const encryptedPayload = {
			key: btoa(String.fromCharCode(...new Uint8Array(rawFileEncryptionKey))),
			filename: file.originalFileName,
			mimetype: file.mimetype,
			version: 1,
		}

		const encrypted = await encryptStringAsymmetric(
			publicKey,
			new TextEncoder().encode(btoa(JSON.stringify(encryptedPayload)))
		)

		this.metadata.filedrop[file.encryptedFileName] = {
			encrypted: btoa(String.fromCharCode(...new Uint8Array(encrypted))),
			initializationVector: btoa(String.fromCharCode(...file.initializationVector)),
			authenticationTag: btoa(String.fromCharCode(...new Uint8Array(tag))),
			metadataKey: Object.keys(this.metadata.metadata.metadataKeys).length - 1,
		}
	}

}
