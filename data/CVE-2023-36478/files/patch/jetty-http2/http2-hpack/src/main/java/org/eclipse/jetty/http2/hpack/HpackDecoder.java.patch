@@ -19,8 +19,12 @@
 import org.eclipse.jetty.http.HttpHeader;
 import org.eclipse.jetty.http.HttpTokens;
 import org.eclipse.jetty.http.MetaData;
+import org.eclipse.jetty.http.compression.EncodingException;
+import org.eclipse.jetty.http.compression.HuffmanDecoder;
+import org.eclipse.jetty.http.compression.NBitIntegerDecoder;
 import org.eclipse.jetty.http2.hpack.HpackContext.Entry;
 import org.eclipse.jetty.util.BufferUtil;
+import org.eclipse.jetty.util.CharsetStringBuilder;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -36,6 +40,8 @@ public class HpackDecoder
 
     private final HpackContext _context;
     private final MetaDataBuilder _builder;
+    private final HuffmanDecoder _huffmanDecoder;
+    private final NBitIntegerDecoder _integerDecoder;
     private int _localMaxDynamicTableSize;
 
     /**
@@ -47,6 +53,8 @@ public HpackDecoder(int localMaxDynamicTableSize, int maxHeaderSize)
         _context = new HpackContext(localMaxDynamicTableSize);
         _localMaxDynamicTableSize = localMaxDynamicTableSize;
         _builder = new MetaDataBuilder(maxHeaderSize);
+        _huffmanDecoder = new HuffmanDecoder();
+        _integerDecoder = new NBitIntegerDecoder();
     }
 
     public HpackContext getHpackContext()
@@ -64,7 +72,8 @@ public MetaData decode(ByteBuffer buffer) throws HpackException.SessionException
         if (LOG.isDebugEnabled())
             LOG.debug(String.format("CtxTbl[%x] decoding %d octets", _context.hashCode(), buffer.remaining()));
 
-        // If the buffer is big, don't even think about decoding it
+        // If the buffer is big, don't even think about decoding it.
+        // Huffman may double the size, but it will only be a temporary allocation until detected in MetaDataBuilder.emit().
         if (buffer.remaining() > _builder.getMaxSize())
             throw new HpackException.SessionException("431 Request Header Fields too large");
 
@@ -79,7 +88,7 @@ public MetaData decode(ByteBuffer buffer) throws HpackException.SessionException
             if (b < 0)
             {
                 // 7.1 indexed if the high bit is set
-                int index = NBitInteger.decode(buffer, 7);
+                int index = integerDecode(buffer, 7);
                 Entry entry = _context.get(index);
                 if (entry == null)
                     throw new HpackException.SessionException("Unknown index %d", index);
@@ -120,7 +129,7 @@ public MetaData decode(ByteBuffer buffer) throws HpackException.SessionException
                     case 2: // 7.3
                     case 3: // 7.3
                         // change table size
-                        int size = NBitInteger.decode(buffer, 5);
+                        int size = integerDecode(buffer, 5);
                         if (LOG.isDebugEnabled())
                             LOG.debug("decode resize={}", size);
                         if (size > _localMaxDynamicTableSize)
@@ -133,15 +142,15 @@ public MetaData decode(ByteBuffer buffer) throws HpackException.SessionException
                     case 0: // 7.2.2
                     case 1: // 7.2.3
                         indexed = false;
-                        nameIndex = NBitInteger.decode(buffer, 4);
+                        nameIndex = integerDecode(buffer, 4);
                         break;
 
                     case 4: // 7.2.1
                     case 5: // 7.2.1
                     case 6: // 7.2.1
                     case 7: // 7.2.1
                         indexed = true;
-                        nameIndex = NBitInteger.decode(buffer, 6);
+                        nameIndex = integerDecode(buffer, 6);
                         break;
 
                     default:
@@ -160,12 +169,11 @@ public MetaData decode(ByteBuffer buffer) throws HpackException.SessionException
                 else
                 {
                     huffmanName = (buffer.get() & 0x80) == 0x80;
-                    int length = NBitInteger.decode(buffer, 7);
-                    _builder.checkSize(length, huffmanName);
+                    int length = integerDecode(buffer, 7);
                     if (huffmanName)
-                        name = Huffman.decode(buffer, length);
+                        name = huffmanDecode(buffer, length);
                     else
-                        name = toASCIIString(buffer, length);
+                        name = toISO88591String(buffer, length);
                     check:
                     for (int i = name.length(); i-- > 0; )
                     {
@@ -201,12 +209,11 @@ public MetaData decode(ByteBuffer buffer) throws HpackException.SessionException
 
                 // decode the value
                 boolean huffmanValue = (buffer.get() & 0x80) == 0x80;
-                int length = NBitInteger.decode(buffer, 7);
-                _builder.checkSize(length, huffmanValue);
+                int length = integerDecode(buffer, 7);
                 if (huffmanValue)
-                    value = Huffman.decode(buffer, length);
+                    value = huffmanDecode(buffer, length);
                 else
-                    value = toASCIIString(buffer, length);
+                    value = toISO88591String(buffer, length);
 
                 // Make the new field
                 HttpField field;
@@ -267,14 +274,61 @@ public MetaData decode(ByteBuffer buffer) throws HpackException.SessionException
         return _builder.build();
     }
 
-    public static String toASCIIString(ByteBuffer buffer, int length)
+    private int integerDecode(ByteBuffer buffer, int prefix) throws HpackException.CompressionException
     {
-        StringBuilder builder = new StringBuilder(length);
+        try
+        {
+            if (prefix != 8)
+                buffer.position(buffer.position() - 1);
+
+            _integerDecoder.setPrefix(prefix);
+            int decodedInt = _integerDecoder.decodeInt(buffer);
+            if (decodedInt < 0)
+                throw new EncodingException("invalid integer encoding");
+            return decodedInt;
+        }
+        catch (EncodingException e)
+        {
+            HpackException.CompressionException compressionException = new HpackException.CompressionException(e.getMessage());
+            compressionException.initCause(e);
+            throw compressionException;
+        }
+        finally
+        {
+            _integerDecoder.reset();
+        }
+    }
+
+    private String huffmanDecode(ByteBuffer buffer, int length) throws HpackException.CompressionException
+    {
+        try
+        {
+            _huffmanDecoder.setLength(length);
+            String decoded = _huffmanDecoder.decode(buffer);
+            if (decoded == null)
+                throw new HpackException.CompressionException("invalid string encoding");
+            return decoded;
+        }
+        catch (EncodingException e)
+        {
+            HpackException.CompressionException compressionException = new HpackException.CompressionException(e.getMessage());
+            compressionException.initCause(e);
+            throw compressionException;
+        }
+        finally
+        {
+            _huffmanDecoder.reset();
+        }
+    }
+
+    public static String toISO88591String(ByteBuffer buffer, int length)
+    {
+        CharsetStringBuilder.Iso88591StringBuilder builder = new CharsetStringBuilder.Iso88591StringBuilder();
         for (int i = 0; i < length; ++i)
         {
-            builder.append((char)(0x7F & buffer.get()));
+            builder.append(HttpTokens.sanitizeFieldVchar((char)buffer.get()));
         }
-        return builder.toString();
+        return builder.build();
     }
 
     @Override