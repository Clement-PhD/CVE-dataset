--- /dev/null
+++ /dev/null
@@ -887,21 +884,4 @@ mod tests {
         query.padding = vec![1, 2].into();
         assert_eq!(Error::InvalidPadding, compose(&query).unwrap_err());
     }
-
-    #[test]
-    fn parse_encapsulated_key() {
-        // Use a seed to initialize a RNG. *Note* you should rely on some
-        // random source.
-        let mut rng = StdRng::from_seed([0; 32]);
-        let key_pair = ObliviousDoHKeyPair::new(&mut rng);
-
-        // Construct a malformed payload. Parsing the encrypted message should fail because it is
-        // too short to include the encapsulated key.
-        let query_enc = ObliviousDoHMessage {
-            msg_type: ObliviousDoHMessageType::Query,
-            key_id: key_pair.public().identifier().unwrap().to_vec().into(),
-            encrypted_msg: b"too short".to_vec().into(),
-        };
-        assert!(decrypt_query(&query_enc, &key_pair).is_err());
-    }
 
