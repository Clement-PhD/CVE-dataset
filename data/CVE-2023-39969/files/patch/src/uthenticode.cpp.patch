@@ -470,12 +470,19 @@ std::vector<Checksum> get_checksums(peparse::parsed_pe *pe) {
   return checksums;
 }
 
-std::string calculate_checksum(peparse::parsed_pe *pe, checksum_kind kind) {
+std::optional<std::string> calculate_checksum(peparse::parsed_pe *pe, checksum_kind kind) {
   auto nid = checksum_type_to_nid(kind);
   if (nid == NID_undef) {
     return {};
   }
 
+  /* We'll stash the bits of the PE that we need to hash in this buffer.
+   * Reserve the original PE's size upfront, since we expect the hashed data
+   * to be only slightly smaller.
+   */
+  std::vector<std::uint8_t> pe_bits;
+  pe_bits.reserve(pe->fileBuffer->bufLen);
+
   /* In both PEs and PE32+s, the PE checksum is 64 bytes into the optional header,
    * which itself is 24 bytes after the PE magic and COFF header from the offset
    * specified in the DOS header.
@@ -502,6 +509,14 @@ std::string calculate_checksum(peparse::parsed_pe *pe, checksum_kind kind) {
     return {};
   }
 
+  /* We explicitly don't support hashing files that don't contain a security
+   * directory; not because we *can't*, but because doing so isn't well defined
+   * in the Authenticode specification.
+   */
+  if (security_dir.VirtualAddress == 0) {
+    return {};
+  }
+
   /* "VirtualAddress" here is really an offset; an invalid one indicates a tampered input.
    * Similarly, a cert_table_offset beyond size_of_headers indicates a tampered input
    * (we get the pe_checksum_offset check for free, since it's always smaller).
@@ -519,11 +534,6 @@ std::string calculate_checksum(peparse::parsed_pe *pe, checksum_kind kind) {
     return {};
   }
 
-  /* We'll stash the bits of the PE that we need to hash in this buffer.
-   */
-  std::vector<std::uint8_t> pe_bits;
-  pe_bits.reserve(size_of_headers);
-
   pe_bits.insert(pe_bits.begin(), header_buf->buf, header_buf->buf + header_buf->bufLen);
   delete header_buf;
 
@@ -541,36 +551,68 @@ std::string calculate_checksum(peparse::parsed_pe *pe, checksum_kind kind) {
   pe_bits.erase(pe_bits.begin() + cert_table_offset, pe_bits.begin() + cert_table_offset + 8);
   pe_bits.erase(pe_bits.begin() + pe_checksum_offset, pe_bits.begin() + pe_checksum_offset + 4);
 
-  /* Hash pe_bits, which contains the rest of the header.
-   */
-  const auto *md = EVP_get_digestbynid(nid);
-  auto *md_ctx = EVP_MD_CTX_new();
-  EVP_DigestInit(md_ctx, md);
-  EVP_DigestUpdate(md_ctx, pe_bits.data(), pe_bits.size());
+  struct iter_sec_ctx {
+    impl::SectionList sections;
+    uint32_t total_bytes_hashed;
+  };
 
-  if (security_dir.VirtualAddress > 0) {
-    /* If a certificate table exists, hash everything before and after it.
-     */
-    EVP_DigestUpdate(md_ctx,
-                     pe->fileBuffer->buf + size_of_headers,
-                     security_dir.VirtualAddress - size_of_headers);
+  impl::SectionList sections;
+  uint32_t total_bytes_hashed = size_of_headers;
+  iter_sec_ctx ctx = {sections, total_bytes_hashed};
 
-    /* Most PEs won't have any trailing data but the Authenticode specification is explicit about
-     * hashing any if it exists.
-     */
-    EVP_DigestUpdate(md_ctx,
-                     pe->fileBuffer->buf + security_dir.VirtualAddress + security_dir.Size,
-                     pe->fileBuffer->bufLen - (security_dir.VirtualAddress + security_dir.Size));
-  } else {
-    /* If there's no certificate table, just hash the rest of the file.
-     */
-    EVP_DigestUpdate(
-        md_ctx, pe->fileBuffer->buf + size_of_headers, pe->fileBuffer->bufLen - size_of_headers);
+  /* Build up the list of sections in the PE, in ascending order by PointerToRawData
+   * (i.e., by file offset).
+   *
+   * NOTE(ww): Ideally we'd use a capture with the C++ lambda here, but C++ lambdas can't be
+   * used within C callbacks unless they're captureless.
+   */
+  peparse::IterSec(
+      pe,
+      [](void *cbd,
+         [[maybe_unused]] const peparse::VA &secBase,
+         [[maybe_unused]] const std::string &sectionName,
+         [[maybe_unused]] const peparse::image_section_header &sec,
+         const peparse::bounded_buffer *b) -> int {
+        auto &ctx = *static_cast<iter_sec_ctx *>(cbd);
+        ctx.sections.emplace_back(b);
+        ctx.total_bytes_hashed += sec.SizeOfRawData;
+        return 0;
+      },
+      &ctx);
+
+  /* Copy each section's data into pe_bits, in ascending order.
+   */
+  for (const auto &section : sections) {
+    pe_bits.insert(pe_bits.end(), section->buf, section->buf + section->bufLen);
   }
 
-  /* Finally, finish hashing the damn thing.
+  /* Also copy any data that happens to be trailing the certificate table into pe_bits.
+   * Most PEs won't have any trailing data but the Authenticode specification is explicit about
+   * hashing any if it exists.
+   */
+  auto file_size = pe->fileBuffer->bufLen;
+  auto extra_data_size = file_size - (security_dir.Size + total_bytes_hashed);
+  auto *trailer_buf = peparse::splitBuffer(
+      pe->fileBuffer, total_bytes_hashed, total_bytes_hashed + extra_data_size);
+  if (trailer_buf == nullptr) {
+    return {};
+  }
+  pe_bits.insert(pe_bits.end(), trailer_buf->buf, trailer_buf->buf + trailer_buf->bufLen);
+  delete trailer_buf;
+
+  /* Finally, hash the damn thing.
+   *
+   * NOTE(ww): Instead of building up pe_bits and hashing it in one pass, we
+   * could hash it incrementally with each section. This would also solve
+   * the capture problem with the C++ callback above and would reduce
+   * the number of needed allocations.
    */
   std::array<std::uint8_t, EVP_MAX_MD_SIZE> md_buf;
+  const auto *md = EVP_get_digestbynid(nid);
+  auto *md_ctx = EVP_MD_CTX_new();
+
+  EVP_DigestInit(md_ctx, md);
+  EVP_DigestUpdate(md_ctx, pe_bits.data(), pe_bits.size());
   EVP_DigestFinal(md_ctx, md_buf.data(), nullptr);
   EVP_MD_CTX_free(md_ctx);
 