@@ -25,9 +25,9 @@
     eval_once_check,
     eval_seq,
     get_bytearray_length,
-    get_element_ptr,
     get_type_for_exact_size,
     ir_tuple_from_args,
+    make_setter,
     needs_external_call_wrap,
     promote_signed_int,
     sar,
@@ -782,39 +782,29 @@ def build_IR(self, expr, args, kwargs, context):
         )
 
 
-def _getelem(arg, ind):
-    return unwrap_location(get_element_ptr(arg, IRnode.from_list(ind, typ=INT128_T)))
-
-
 class ECAdd(BuiltinFunction):
     _id = "ecadd"
     _inputs = [("a", SArrayT(UINT256_T, 2)), ("b", SArrayT(UINT256_T, 2))]
     _return_type = SArrayT(UINT256_T, 2)
 
     @process_inputs
     def build_IR(self, expr, args, kwargs, context):
-        placeholder_node = IRnode.from_list(
-            context.new_internal_variable(BytesT(128)), typ=BytesT(128), location=MEMORY
-        )
+        buf_t = get_type_for_exact_size(128)
 
-        with args[0].cache_when_complex("a") as (b1, a), args[1].cache_when_complex("b") as (b2, b):
-            o = IRnode.from_list(
-                [
-                    "seq",
-                    ["mstore", placeholder_node, _getelem(a, 0)],
-                    ["mstore", ["add", placeholder_node, 32], _getelem(a, 1)],
-                    ["mstore", ["add", placeholder_node, 64], _getelem(b, 0)],
-                    ["mstore", ["add", placeholder_node, 96], _getelem(b, 1)],
-                    [
-                        "assert",
-                        ["staticcall", ["gas"], 6, placeholder_node, 128, placeholder_node, 64],
-                    ],
-                    placeholder_node,
-                ],
-                typ=SArrayT(UINT256_T, 2),
-                location=MEMORY,
-            )
-            return b2.resolve(b1.resolve(o))
+        buf = context.new_internal_variable(buf_t)
+
+        ret = ["seq"]
+
+        dst0 = IRnode.from_list(buf, typ=SArrayT(UINT256_T, 2), location=MEMORY)
+        ret.append(make_setter(dst0, args[0]))
+
+        dst1 = IRnode.from_list(buf + 64, typ=SArrayT(UINT256_T, 2), location=MEMORY)
+        ret.append(make_setter(dst1, args[1]))
+
+        ret.append(["assert", ["staticcall", ["gas"], 6, buf, 128, buf, 64]])
+        ret.append(buf)
+
+        return IRnode.from_list(ret, typ=SArrayT(UINT256_T, 2), location=MEMORY)
 
 
 class ECMul(BuiltinFunction):
@@ -824,27 +814,22 @@ class ECMul(BuiltinFunction):
 
     @process_inputs
     def build_IR(self, expr, args, kwargs, context):
-        placeholder_node = IRnode.from_list(
-            context.new_internal_variable(BytesT(128)), typ=BytesT(128), location=MEMORY
-        )
+        buf_t = get_type_for_exact_size(96)
 
-        with args[0].cache_when_complex("a") as (b1, a), args[1].cache_when_complex("b") as (b2, b):
-            o = IRnode.from_list(
-                [
-                    "seq",
-                    ["mstore", placeholder_node, _getelem(a, 0)],
-                    ["mstore", ["add", placeholder_node, 32], _getelem(a, 1)],
-                    ["mstore", ["add", placeholder_node, 64], b],
-                    [
-                        "assert",
-                        ["staticcall", ["gas"], 7, placeholder_node, 96, placeholder_node, 64],
-                    ],
-                    placeholder_node,
-                ],
-                typ=SArrayT(UINT256_T, 2),
-                location=MEMORY,
-            )
-            return b2.resolve(b1.resolve(o))
+        buf = context.new_internal_variable(buf_t)
+
+        ret = ["seq"]
+
+        dst0 = IRnode.from_list(buf, typ=SArrayT(UINT256_T, 2), location=MEMORY)
+        ret.append(make_setter(dst0, args[0]))
+
+        dst1 = IRnode.from_list(buf + 64, typ=UINT256_T, location=MEMORY)
+        ret.append(make_setter(dst1, args[1]))
+
+        ret.append(["assert", ["staticcall", ["gas"], 7, buf, 96, buf, 64]])
+        ret.append(buf)
+
+        return IRnode.from_list(ret, typ=SArrayT(UINT256_T, 2), location=MEMORY)
 
 
 def _generic_element_getter(op):
@@ -1525,13 +1510,14 @@ def evaluate(self, node):
 
     @process_inputs
     def build_IR(self, expr, args, kwargs, context):
-        c = args[2]
-
-        with c.cache_when_complex("c") as (b1, c):
-            ret = IRnode.from_list(
-                ["seq", ["assert", c], [self._opcode, args[0], args[1], c]], typ=UINT256_T
-            )
-            return b1.resolve(ret)
+        x, y, z = args
+        with x.cache_when_complex("x") as (b1, x):
+            with y.cache_when_complex("y") as (b2, y):
+                with z.cache_when_complex("z") as (b3, z):
+                    ret = IRnode.from_list(
+                        ["seq", ["assert", z], [self._opcode, x, y, z]], typ=UINT256_T
+                    )
+                    return b1.resolve(b2.resolve(b3.resolve(ret)))
 
 
 class AddMod(_AddMulMod):