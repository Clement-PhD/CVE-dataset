@@ -1016,6 +1016,12 @@ var _ = Describe("With an in-process Server with short grace period", func() {
 			log.SetLevel(log.InfoLevel)
 			logStats("Start of test")
 			h.SendInitialSnapshotConfigs(initialSnapshotSize)
+
+			// Make sure we don't start a client until the initial snapshot
+			// flows through to the cache.
+			Eventually(func() int {
+				return h.FelixCache.CurrentBreadcrumb().KVs.Len()
+			}).Should(Equal(initialSnapshotSize))
 		})
 
 		AfterEach(func() {
@@ -1125,23 +1131,31 @@ var _ = Describe("With an in-process Server with short grace period", func() {
 			// Wait until the snapshot is read.
 			Eventually(recorder.Len, time.Second).Should(BeNumerically("==", initialSnapshotSize))
 
-			log.SetLevel(log.DebugLevel)
-			// Make a breadcrumb.
+			// Send a lot of updates.
+
+			log.Info("Sleeping 1s")
 			time.Sleep(time.Second)
+			log.Info("Send many updates...")
 			h.SendConfigUpdates(initialSnapshotSize)
 
 			// Client should read the first update from the above and then block.
 
 			// Make a breadcrumb 1s later.
+			log.Info("Sleeping 1s")
 			time.Sleep(time.Second)
+			log.SetLevel(log.DebugLevel)
+			log.Info("Sending one update")
 			h.SendConfigUpdates(1)
 
 			// Make a breadcrumb 1s later.
+			log.Info("Sleeping 1s")
 			time.Sleep(time.Second)
+			log.Info("Sending one update")
 			h.SendConfigUpdates(1)
 
 			// Client should wake up around now but be too far behind and get disconnected.
 
+			log.Info("Waiting for client to be killed...")
 			finishedC := make(chan struct{})
 			go func() {
 				client.Finished.Wait()
@@ -1612,19 +1626,6 @@ var _ = Describe("with server requiring TLS", func() {
 		}
 	}
 
-	testTcpHalfOpen := func() {
-		deadline := time.Now().Add(9 * time.Second)
-		serverAddr := fmt.Sprintf("127.0.0.1:%d", server.Port())
-		tcpConn, err := net.Dial("tcp", serverAddr)
-		Expect(err).NotTo(HaveOccurred())
-		err = tcpConn.SetDeadline(time.Now().Add(30 * time.Second))
-		Expect(err).NotTo(HaveOccurred())
-		received := make([]byte, 1024)
-		_, err = tcpConn.Read(received)
-		Expect(err).Should(Equal(io.EOF))
-		Expect(time.Now().Unix()).Should(BeNumerically(">=", deadline.Unix()))
-	}
-
 	Describe("and CN or URI SAN", func() {
 		BeforeEach(func() {
 			requiredClientCN = clientCN
@@ -1708,6 +1709,63 @@ var _ = Describe("with server requiring TLS", func() {
 			serverCertName = "server"
 		})
 
-		It("should timeout after 10 seconds for TCP half open connections", testTcpHalfOpen)
+		It("should timeout after 10 seconds for TCP half open connections", func() {
+			serverAddr := fmt.Sprintf("127.0.0.1:%d", server.Port())
+			expectedDisconnectTime := time.Now().Add(10 * time.Second)
+			tcpConn, err := net.Dial("tcp", serverAddr)
+			Expect(err).NotTo(HaveOccurred())
+			defer func() {
+				_ = tcpConn.Close()
+			}()
+			err = tcpConn.SetDeadline(time.Now().Add(15 * time.Second))
+			Expect(err).NotTo(HaveOccurred())
+
+			// Client sends a few valid bytes of a Client hello but then stops...
+			_, err = tcpConn.Write([]byte{16, 3, 01})
+			Expect(err).NotTo(HaveOccurred())
+
+			// Start a read that we don't expect to complete.
+			received := make([]byte, 1024)
+			_, err = tcpConn.Read(received)
+
+			// io.EOF means the server closed the connection (we'd get
+			// a timeout error if the deadline we set was reached.
+			Expect(err).Should(Equal(io.EOF))
+			// Should get disconnected at approximately the right time.
+			Expect(time.Now()).Should(
+				BeTemporally("~", expectedDisconnectTime, 2*time.Second),
+				"Expected to be disconnected at approx 10s")
+		})
+
+		It("should allow connections while another connection is half-open", func() {
+			// Set up a raw connection that just blocks at the handshake.
+			log.Info("Sending blocking connection")
+			serverAddr := fmt.Sprintf("127.0.0.1:%d", server.Port())
+			conn, err := net.Dial("tcp", serverAddr)
+			Expect(err).NotTo(HaveOccurred())
+			tcpConn := conn.(*net.TCPConn)
+			defer func() {
+				_ = tcpConn.Close()
+			}()
+			log.Info("Blocking connection source:", tcpConn.LocalAddr())
+			_, err = tcpConn.Write([]byte{16, 3, 01})
+			Expect(err).NotTo(HaveOccurred())
+			Eventually(server.NumActiveConnections).Should(Equal(1))
+
+			// Set up a normal, valid connection.
+			log.Info("Sending valid connection")
+			startTime := time.Now()
+			testConnection("gooduri", true)
+			Expect(time.Now()).To(BeTemporally("<", startTime.Add(time.Second)))
+			log.Info("Done")
+
+			// The normal client closes its own connection.
+			Eventually(server.NumActiveConnections).Should(Equal(1))
+
+			// Closing the blocked one should get through to the server.
+			_ = tcpConn.Close()
+			Eventually(server.NumActiveConnections).Should(Equal(0))
+		})
 	})
+
 })
