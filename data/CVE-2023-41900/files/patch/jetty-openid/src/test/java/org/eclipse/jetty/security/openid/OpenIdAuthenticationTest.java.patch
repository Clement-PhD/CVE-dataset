@@ -16,33 +16,43 @@
 import java.io.File;
 import java.io.IOException;
 import java.security.Principal;
+import java.util.List;
 import java.util.Map;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.function.Consumer;
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServlet;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 
 import org.eclipse.jetty.client.HttpClient;
 import org.eclipse.jetty.client.api.ContentResponse;
+import org.eclipse.jetty.http.HttpHeader;
 import org.eclipse.jetty.http.HttpStatus;
+import org.eclipse.jetty.security.AbstractLoginService;
 import org.eclipse.jetty.security.ConstraintMapping;
 import org.eclipse.jetty.security.ConstraintSecurityHandler;
+import org.eclipse.jetty.security.LoginService;
+import org.eclipse.jetty.security.RolePrincipal;
+import org.eclipse.jetty.security.UserPrincipal;
 import org.eclipse.jetty.server.Server;
 import org.eclipse.jetty.server.ServerConnector;
+import org.eclipse.jetty.server.UserIdentity;
 import org.eclipse.jetty.server.session.FileSessionDataStoreFactory;
 import org.eclipse.jetty.servlet.ServletContextHandler;
 import org.eclipse.jetty.toolchain.test.MavenTestingUtils;
 import org.eclipse.jetty.util.IO;
 import org.eclipse.jetty.util.security.Constraint;
+import org.eclipse.jetty.util.security.Password;
 import org.junit.jupiter.api.AfterEach;
-import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.containsString;
 import static org.hamcrest.Matchers.equalTo;
 import static org.hamcrest.Matchers.greaterThanOrEqualTo;
 import static org.hamcrest.Matchers.is;
+import static org.hamcrest.Matchers.startsWith;
 
 @SuppressWarnings("unchecked")
 public class OpenIdAuthenticationTest
@@ -55,8 +65,12 @@ public class OpenIdAuthenticationTest
     private ServerConnector connector;
     private HttpClient client;
 
-    @BeforeEach
-    public void setup() throws Exception
+    public void setup(LoginService loginService) throws Exception
+    {
+        setup(loginService, null);
+    }
+
+    public void setup(LoginService loginService, Consumer<OpenIdConfiguration> configure) throws Exception
     {
         openIdProvider = new OpenIdProvider(CLIENT_ID, CLIENT_SECRET);
         openIdProvider.start();
@@ -100,12 +114,16 @@ public void setup() throws Exception
 
         securityHandler.setAuthMethod(Constraint.__OPENID_AUTH);
         securityHandler.setRealmName(openIdProvider.getProvider());
+        securityHandler.setLoginService(loginService);
         securityHandler.addConstraintMapping(profileMapping);
         securityHandler.addConstraintMapping(loginMapping);
         securityHandler.addConstraintMapping(adminMapping);
 
         // Authentication using local OIDC Provider
-        server.addBean(new OpenIdConfiguration(openIdProvider.getProvider(), CLIENT_ID, CLIENT_SECRET));
+        OpenIdConfiguration openIdConfiguration = new OpenIdConfiguration(openIdProvider.getProvider(), CLIENT_ID, CLIENT_SECRET);
+        if (configure != null)
+            configure.accept(openIdConfiguration);
+        server.addBean(openIdConfiguration);
         securityHandler.setInitParameter(OpenIdAuthenticator.REDIRECT_PATH, "/redirect_path");
         securityHandler.setInitParameter(OpenIdAuthenticator.ERROR_PAGE, "/error");
         securityHandler.setInitParameter(OpenIdAuthenticator.LOGOUT_REDIRECT_PATH, "/");
@@ -135,6 +153,7 @@ public void stop() throws Exception
     @Test
     public void testLoginLogout() throws Exception
     {
+        setup(null);
         openIdProvider.setUser(new OpenIdProvider.User("123456789", "Alice"));
 
         String appUriString = "http://localhost:" + connector.getLocalPort();
@@ -188,6 +207,163 @@ public void testLoginLogout() throws Exception
         assertThat(openIdProvider.getLoggedInUsers().getTotal(), equalTo(1L));
     }
 
+    @Test
+    public void testNestedLoginService() throws Exception
+    {
+        AtomicBoolean loggedIn = new AtomicBoolean(true);
+        setup(new AbstractLoginService()
+        {
+
+            @Override
+            protected List<RolePrincipal> loadRoleInfo(UserPrincipal user)
+            {
+                return List.of(new RolePrincipal("admin"));
+            }
+
+            @Override
+            protected UserPrincipal loadUserInfo(String username)
+            {
+                return new UserPrincipal(username, new Password(""));
+            }
+
+            @Override
+            public boolean validate(UserIdentity user)
+            {
+                if (!loggedIn.get())
+                    return false;
+                return super.validate(user);
+            }
+        });
+
+        openIdProvider.setUser(new OpenIdProvider.User("123456789", "Alice"));
+
+        String appUriString = "http://localhost:" + connector.getLocalPort();
+
+        // Initially not authenticated
+        ContentResponse response = client.GET(appUriString + "/");
+        assertThat(response.getStatus(), is(HttpStatus.OK_200));
+        String content = response.getContentAsString();
+        assertThat(content, containsString("not authenticated"));
+
+        // Request to login is success
+        response = client.GET(appUriString + "/login");
+        assertThat(response.getStatus(), is(HttpStatus.OK_200));
+        content = response.getContentAsString();
+        assertThat(content, containsString("success"));
+
+        // Now authenticated we can get info
+        response = client.GET(appUriString + "/");
+        assertThat(response.getStatus(), is(HttpStatus.OK_200));
+        content = response.getContentAsString();
+        assertThat(content, containsString("userId: 123456789"));
+        assertThat(content, containsString("name: Alice"));
+        assertThat(content, containsString("email: Alice@example.com"));
+
+        // The nested login service has supplied the admin role.
+        response = client.GET(appUriString + "/admin");
+        assertThat(response.getStatus(), is(HttpStatus.OK_200));
+
+        // This causes any validation of UserIdentity in the LoginService to fail
+        // causing subsequent requests to be redirected to the auth endpoint for login again.
+        loggedIn.set(false);
+        client.setFollowRedirects(false);
+        response = client.GET(appUriString + "/admin");
+        assertThat(response.getStatus(), is(HttpStatus.SEE_OTHER_303));
+        String location = response.getHeaders().get(HttpHeader.LOCATION);
+        assertThat(location, containsString(openIdProvider.getProvider() + "/auth"));
+
+        // Note that we couldn't follow "OpenID Connect RP-Initiated Logout 1.0" because we redirect straight to auth endpoint.
+        assertThat(openIdProvider.getLoggedInUsers().getCurrent(), equalTo(1L));
+        assertThat(openIdProvider.getLoggedInUsers().getMax(), equalTo(1L));
+        assertThat(openIdProvider.getLoggedInUsers().getTotal(), equalTo(1L));
+    }
+
+    @Test
+    public void testExpiredIdToken() throws Exception
+    {
+        setup(null, config -> config.setLogoutWhenIdTokenIsExpired(true));
+        long idTokenExpiryTime = 2000;
+        openIdProvider.setIdTokenDuration(idTokenExpiryTime);
+        openIdProvider.setUser(new OpenIdProvider.User("123456789", "Alice"));
+
+        String appUriString = "http://localhost:" + connector.getLocalPort();
+
+        // Initially not authenticated
+        ContentResponse response = client.GET(appUriString + "/");
+        assertThat(response.getStatus(), is(HttpStatus.OK_200));
+        String content = response.getContentAsString();
+        assertThat(content, containsString("not authenticated"));
+
+        // Request to login is success
+        response = client.GET(appUriString + "/login");
+        assertThat(response.getStatus(), is(HttpStatus.OK_200));
+        content = response.getContentAsString();
+        assertThat(content, containsString("success"));
+
+        // Now authenticated we can get info
+        client.setFollowRedirects(false);
+        response = client.GET(appUriString + "/");
+        assertThat(response.getStatus(), is(HttpStatus.OK_200));
+        content = response.getContentAsString();
+        assertThat(content, containsString("userId: 123456789"));
+        assertThat(content, containsString("name: Alice"));
+        assertThat(content, containsString("email: Alice@example.com"));
+
+        // After waiting past ID_Token expiry time we are no longer authenticated.
+        // Even though this page is non-mandatory authentication the OpenId attributes should be cleared.
+        // This then attempts re-authorization the first time even though it is non-mandatory page.
+        Thread.sleep(idTokenExpiryTime * 2);
+        response = client.GET(appUriString + "/");
+        assertThat(response.getStatus(), is(HttpStatus.SEE_OTHER_303));
+        assertThat(response.getHeaders().get(HttpHeader.LOCATION), startsWith(openIdProvider.getProvider() + "/auth"));
+
+        // User was never redirected to logout page.
+        assertThat(openIdProvider.getLoggedInUsers().getCurrent(), equalTo(1L));
+        assertThat(openIdProvider.getLoggedInUsers().getMax(), equalTo(1L));
+        assertThat(openIdProvider.getLoggedInUsers().getTotal(), equalTo(1L));
+    }
+
+    @Test
+    public void testExpiredIdTokenDisabled() throws Exception
+    {
+        setup(null);
+        long idTokenExpiryTime = 2000;
+        openIdProvider.setIdTokenDuration(idTokenExpiryTime);
+        openIdProvider.setUser(new OpenIdProvider.User("123456789", "Alice"));
+
+        String appUriString = "http://localhost:" + connector.getLocalPort();
+
+        // Initially not authenticated
+        ContentResponse response = client.GET(appUriString + "/");
+        assertThat(response.getStatus(), is(HttpStatus.OK_200));
+        String content = response.getContentAsString();
+        assertThat(content, containsString("not authenticated"));
+
+        // Request to login is success
+        response = client.GET(appUriString + "/login");
+        assertThat(response.getStatus(), is(HttpStatus.OK_200));
+        content = response.getContentAsString();
+        assertThat(content, containsString("success"));
+
+        // Now authenticated we can get info
+        client.setFollowRedirects(false);
+        response = client.GET(appUriString + "/");
+        assertThat(response.getStatus(), is(HttpStatus.OK_200));
+        content = response.getContentAsString();
+        assertThat(content, containsString("userId: 123456789"));
+        assertThat(content, containsString("name: Alice"));
+        assertThat(content, containsString("email: Alice@example.com"));
+
+        // After waiting past ID_Token expiry time we are still authenticated because logoutWhenIdTokenIsExpired is false by default.
+        Thread.sleep(idTokenExpiryTime * 2);
+        response = client.GET(appUriString + "/");
+        assertThat(response.getStatus(), is(HttpStatus.OK_200));
+        content = response.getContentAsString();
+        assertThat(content, containsString("userId: 123456789"));
+        assertThat(content, containsString("name: Alice"));
+        assertThat(content, containsString("email: Alice@example.com"));
+    }
+
     public static class LoginPage extends HttpServlet
     {
         @Override