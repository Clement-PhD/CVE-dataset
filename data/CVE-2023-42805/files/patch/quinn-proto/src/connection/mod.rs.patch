@@ -2192,7 +2192,15 @@ impl Connection {
                 return Ok(());
             }
             State::Closed(_) => {
-                for frame in frame::Iter::new(packet.payload.freeze()) {
+                for result in frame::Iter::new(packet.payload.freeze()) {
+                    let frame = match result {
+                        Ok(frame) => frame,
+                        Err(err) => {
+                            debug!("frame decoding error: {err:?}");
+                            continue;
+                        }
+                    };
+
                     if let Frame::Padding = frame {
                         continue;
                     };
@@ -2433,7 +2441,8 @@ impl Connection {
         debug_assert_ne!(packet.header.space(), SpaceId::Data);
         let payload_len = packet.payload.len();
         let mut ack_eliciting = false;
-        for frame in frame::Iter::new(packet.payload.freeze()) {
+        for result in frame::Iter::new(packet.payload.freeze()) {
+            let frame = result?;
             let span = match frame {
                 Frame::Padding => continue,
                 _ => Some(trace_span!("frame", ty = %frame.ty())),
@@ -2458,11 +2467,6 @@ impl Connection {
                     self.state = State::Draining;
                     return Ok(());
                 }
-                Frame::Invalid { ty, reason } => {
-                    let mut err = TransportError::FRAME_ENCODING_ERROR(reason);
-                    err.frame = Some(ty);
-                    return Err(err);
-                }
                 _ => {
                     let mut err =
                         TransportError::PROTOCOL_VIOLATION("illegal frame type in handshake");
@@ -2495,7 +2499,8 @@ impl Connection {
         let mut close = None;
         let payload_len = payload.len();
         let mut ack_eliciting = false;
-        for frame in frame::Iter::new(payload) {
+        for result in frame::Iter::new(payload) {
+            let frame = result?;
             let span = match frame {
                 Frame::Padding => continue,
                 _ => Some(trace_span!("frame", ty = %frame.ty())),
@@ -2543,11 +2548,6 @@ impl Connection {
                 }
             }
             match frame {
-                Frame::Invalid { ty, reason } => {
-                    let mut err = TransportError::FRAME_ENCODING_ERROR(reason);
-                    err.frame = Some(ty);
-                    return Err(err);
-                }
                 Frame::Crypto(frame) => {
                     self.read_crypto(SpaceId::Data, &frame, payload_len)?;
                 }