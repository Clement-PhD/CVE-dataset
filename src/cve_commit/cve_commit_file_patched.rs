use std::fs::File;
use std::io::Read;
use std::path::Path;


use zip::ZipArchive;

use crate::language::Language;
use crate::patch::Patch;


/// A file patched in a commit of a cve
#[derive(Debug, Clone)]
pub struct CveCommitFilePatched {
    pub cve_id: String,
    pub file_basename: String,
    pub original_file_content: String,
    pub fixed_file_content: String,
    /// patch of the file
    pub patch: Patch,
    /// The path relatif to the patch (or original or fixed) folder (inside the files folder, inside the cve folder) to the file
    /// without the .patch extension
    /// Example: "first/second/third/fourth.php"
    pub inside_file_path: String,
    /// The language of the file (if it is a known one)
    pub language: Option<Language>,
}


impl CveCommitFilePatched {
    /// Create a CveCommitFilePatched from a zip file
    /// if the file is not a patch file (a folder for example), return None
    pub fn from_zip(file_patch_path : &str, zip : &mut ZipArchive<File>) -> Option<CveCommitFilePatched> {
        let cve_id = {
            let cve_id = file_patch_path.split("/").next().unwrap();
            cve_id.to_string()
        };
        let file_path = Path::new(file_patch_path);
        let file_basename = file_path.file_stem().unwrap().to_str().unwrap().to_string();

        let inside_patch_path = file_patch_path.split("/patch/").last().unwrap();
        // extract the inside file path from the inside patch path
        let inside_file_path = {
            let patch_parent = Path::new(inside_patch_path).parent();
            if patch_parent.is_none() {
                return None;
            }

            patch_parent.unwrap().join(file_basename.as_str()).to_str().unwrap().to_string()
        };

        let mut original_file_name = String::new();
        let mut fixed_file_name = String::new();

        let mut original_file_content = String::new();
        let mut fixed_file_content = String::new();
        let mut patch_content = String::new();

        for file_name in zip.file_names() {


            if file_name.contains("original") && file_name.ends_with(inside_file_path.as_str()) {
                original_file_name = file_name.to_string();
            }

            if file_name.contains("fixed") && file_name.ends_with(inside_file_path.as_str()) {
                fixed_file_name = file_name.to_string();
            }
        }

        // read the content of the patch and test if it is not a directory
        {
            let mut patch_zip_file = zip.by_name(file_patch_path).unwrap();
            if patch_zip_file.is_dir() {
                return None;
            }
            patch_zip_file.read_to_string(&mut patch_content).unwrap();
        }
        
        println!("inside_file_path, inside_patch_path: {}, {}", inside_file_path, inside_patch_path);
        println!("patch_path: {}", file_patch_path);
        println!("original_file_name: {}", original_file_name);
        println!("fixed_file_name: {}", fixed_file_name);

        // original
        {
            let original_file = zip.by_name(original_file_name.as_str());
            if original_file.is_err() {
                original_file_content = String::new();
            }else {
                original_file.unwrap().read_to_string(&mut original_file_content).unwrap();
            }
        }
        // fixed
        {
            let fixed_file = zip.by_name(fixed_file_name.as_str());
            if fixed_file.is_err() {
                fixed_file_content = String::new();
            }else {
                fixed_file.unwrap().read_to_string(&mut fixed_file_content).unwrap();
            }
        }

        let language = Language::new_by_file_name(file_basename.as_str());

        let pull_request = CveCommitFilePatched {
            cve_id,
            file_basename,
            original_file_content,
            fixed_file_content,
            patch: Patch::new_from_content(file_patch_path, patch_content.as_str()),
            inside_file_path: inside_file_path,
            language
        };

        if !pull_request.content_coherent_with_patch() {
            panic!("Error while parsing the pull request file : {}", file_patch_path);
        }

        Some(pull_request)
    }


    fn content_coherent_with_patch(&self) -> bool {
        if self.patch.is_added() {
            self.original_file_content.is_empty()
        }else if self.patch.is_removed() {
            self.fixed_file_content.is_empty()
        }else {
            !self.original_file_content.is_empty() && !self.fixed_file_content.is_empty() && self.patch.is_modified()
        }
    }

    /// get the inside file path of the original file. Example: "<cve_id>/files/original/first/second/third/fourth.php"
    pub fn get_original_file_path(&self) -> String {
        let file_path = Path::new(&self.inside_file_path);
        let file_path_without_extension = file_path.with_extension("");
        let original_file_path = Path::new(self.cve_id.as_str()).join("original").join(file_path_without_extension);
        original_file_path.to_str().unwrap().to_string()
    }

    /// get the inside file path of the fixed file. Example: "<cve_id>/files/fixed/first/second/third/fourth.php"
    pub fn get_fixed_file_path(&self) -> String {
        let file_path = Path::new(&self.inside_file_path);
        let file_path_without_extension = file_path.with_extension("");
        let fixed_file_path = Path::new(self.cve_id.as_str()).join("fixed").join(file_path_without_extension);
        fixed_file_path.to_str().unwrap().to_string()
    }
}


#[cfg(test)]
mod tests {

    use super::*;

    #[test]
    fn test_path_concat() {
        let first = "first/second";
        let second = "third/fourth";
        let expected = "first/second/third/fourth";
        let first_path = Path::new(first);
        let full_path = first_path.join(second);
        let full_path_str = full_path.to_str().unwrap();
        assert_eq!(full_path_str, expected);
    }

    #[test]
    fn test_remove_extension() {
        let path = "first/second/third/fourth.php.patch";
        let expected = "first/second/third/fourth.php";
        let path_path = Path::new(path);
        let path_without_extension = path_path.with_extension("");
        let path_without_extension_str = path_without_extension.to_str().unwrap();
        assert_eq!(path_without_extension_str, expected);
    }
}