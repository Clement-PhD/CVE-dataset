use std::fs;
use std::path::Path;


use crate::language::Language;
use crate::patch::Patch;


/// A file patched in a commit of a cve
#[derive(Debug, Clone)]
pub struct CveCommitFilePatched {
    pub cve_id: String,
    pub file_basename: String,
    /// The path to the original file
    pub original_file_path: String,
    pub original_file_content: String,
    /// The path to the fixed file
    pub fixed_file_path: String,
    pub fixed_file_content: String,
    /// patch of the file
    pub patch: Patch,
    /// The path relatif to the patch folder (inside the files folder, inside the cve folder) to the file
    pub inside_file_path: String,
    /// The language of the file (if it is a known one)
    pub language: Option<Language>,
}


impl CveCommitFilePatched {
    /// Create a new CveCommitFilePatched
    /// cve_id: the id of the cve
    /// patch_file_inside_path: the path inside the cve folder and the patch folder to the file
    /// data_folder: the path to the data folder
    pub fn new<P: AsRef<Path>>(cve_id: &str, patch_file_inside_path: &str, data_folder: P) -> CveCommitFilePatched {
        let data_folder_path = data_folder.as_ref();
        let cve_folder_path = data_folder_path.join(cve_id);
        let files_folder_path = cve_folder_path.join("files");

        let file_inside_path = Path::new(patch_file_inside_path).with_extension("");

        let original_file_path = files_folder_path.join("original").join(file_inside_path.clone());
        let fixed_file_path = files_folder_path.join("fixed").join(file_inside_path.clone());
        let patch_path = files_folder_path.join("patch").join( patch_file_inside_path);

        let file_basename = original_file_path.file_name().unwrap().to_str().unwrap();
        let original_file_content = fs::read_to_string(original_file_path.clone()).unwrap();
        
        let fixed_file_content = fs::read_to_string(fixed_file_path.clone()).unwrap();

        let language = Language::new_by_file_name(file_basename);

        let pull_request = CveCommitFilePatched {
            cve_id: cve_id.to_string(),
            file_basename: file_basename.to_string(),
            original_file_path: original_file_path.to_string_lossy().into_owned(),
            original_file_content,
            fixed_file_content,
            fixed_file_path: fixed_file_path.to_string_lossy().into_owned(),
            patch: Patch::new(patch_path.to_str().unwrap()),
            inside_file_path: patch_file_inside_path.to_string(),
            language
        };

        if !pull_request.content_coherent_with_patch() {
            panic!("Error while parsing the pull request file : {}", patch_file_inside_path);
        }

        pull_request
    }


    fn content_coherent_with_patch(&self) -> bool {
        if self.patch.is_added() {
            self.original_file_content.is_empty()
        }else if self.patch.is_removed() {
            self.fixed_file_content.is_empty()
        }else {
            !self.original_file_content.is_empty() && !self.fixed_file_content.is_empty() && self.patch.is_modified()
        }
    }
}


#[cfg(test)]
mod tests {

    use super::*;

    #[test]
    fn test_path_concat() {
        let first = "first/second";
        let second = "third/fourth";
        let expected = "first/second/third/fourth";
        let first_path = Path::new(first);
        let full_path = first_path.join(second);
        let full_path_str = full_path.to_str().unwrap();
        assert_eq!(full_path_str, expected);
    }

    #[test]
    fn test_remove_extension() {
        let path = "first/second/third/fourth.php.patch";
        let expected = "first/second/third/fourth.php";
        let path_path = Path::new(path);
        let path_without_extension = path_path.with_extension("");
        let path_without_extension_str = path_without_extension.to_str().unwrap();
        assert_eq!(path_without_extension_str, expected);
    }
}