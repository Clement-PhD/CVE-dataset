use std::fs::File;
use std::io::Read;
use std::path::{Path, PathBuf};


use download_dataset::download::file_warnings::{WarningPayload, WarningType};
use zip::ZipArchive;

use crate::language::Language;
use crate::patch::Patch;


/// A file patched in a commit of a cve
#[derive(Debug, Clone)]
pub struct CveCommitFilePatched {
    pub cve_id: String,
    pub file_basename: String,
    pub original_file_content: String,
    pub fixed_file_content: String,
    /// patch of the file
    pub patch: Patch,
    /// The path relatif to the patch (or original or fixed) folder (inside the files folder, inside the cve folder) to the file
    /// without the .patch extension
    /// Example: "first/second/third/fourth.php"
    pub inside_file_path: String,
    /// The language of the file (if it is a known one)
    pub language: Option<Language>,
}


impl CveCommitFilePatched {
    /// Create a CveCommitFilePatched from a zip file
    /// if the file is not a patch file (a folder for example), return None
    pub fn from_zip(file_patch_path : &str, zip : &mut ZipArchive<File>) -> Option<CveCommitFilePatched> {
        if Self::check_cant_apply_patch_warn_in_zip(zip) {
            return None;
        }

        let cve_id = {
            let cve_id = file_patch_path.split("/").next().unwrap();
            cve_id.to_string()
        };
        let file_path = Path::new(file_patch_path);
        let file_basename = file_path.file_stem().unwrap().to_str().unwrap().to_string();

        let inside_patch_path = file_patch_path.splitn(2, "/patch/").last().unwrap();
        if !inside_patch_path.ends_with(".patch") {
            return None;
        }

        // extract the inside file path from the inside patch path
        let inside_file_path = {
            let patch_pathbuf = PathBuf::from(inside_patch_path);
            let file_pathbuf = patch_pathbuf.with_extension("");
            file_pathbuf.to_str().unwrap().to_string()
        };

        let original_file_name = Path::new(cve_id.as_str()).join("original").join(inside_file_path.as_str()).to_str().unwrap().to_string();
        let fixed_file_name = Path::new(cve_id.as_str()).join("fixed").join(inside_file_path.as_str()).to_str().unwrap().to_string();

        let mut original_file_content = String::new();
        let mut fixed_file_content = String::new();
        let mut patch_content = String::new();

        // read the content of the patch and test if it is not a directory
        {
            let mut patch_zip_file = zip.by_name(file_patch_path).unwrap();
            if patch_zip_file.is_dir() {
                return None;
            }
            patch_zip_file.read_to_string(&mut patch_content).unwrap();
        }
        
        //println!("inside_file_path, inside_patch_path: {}, {}", inside_file_path, inside_patch_path);
        //println!("patch_path: {}", file_patch_path);
        //println!("original_file_name: {}", original_file_name);
        //println!("fixed_file_name: {}", fixed_file_name);

        // original
        {
            let original_file = zip.by_name(original_file_name.as_str());
            if original_file.is_err() {
                original_file_content = String::new();
            }else {
                original_file.unwrap().read_to_string(&mut original_file_content).unwrap();
            }
        }
        // fixed
        {
            let fixed_file = zip.by_name(fixed_file_name.as_str());
            if fixed_file.is_err() {
                fixed_file_content = String::new();
            }else {
                fixed_file.unwrap().read_to_string(&mut fixed_file_content).unwrap();
            }
        }

        let language = Language::new_by_file_name(file_basename.as_str());

        let pull_request = CveCommitFilePatched {
            cve_id,
            file_basename,
            original_file_content,
            fixed_file_content,
            patch: Patch::new_from_content(file_patch_path, patch_content.as_str()),
            inside_file_path: inside_file_path,
            language
        };

        if !pull_request.content_coherent_with_patch() {
            panic!("Error while parsing the pull request file : {}", file_patch_path);
        }

        Some(pull_request)
    }

    /// Check if their is a warning in the zip file that the patch cannot be applied
    /// return true if their is a warning, false otherwise
    fn check_cant_apply_patch_warn_in_zip(zip : &mut ZipArchive<File>) -> bool {
        // isolate the error file if it exists
        let mut error_file_content : Option<String> = None;
        for i in 0..zip.len() {
            let mut file = zip.by_index(i).unwrap();
            if file.name().ends_with("warnings.json") {
                let mut writer: Vec<u8> = vec![];
                std::io::copy(&mut file, &mut writer).unwrap();
                let content = String::from_utf8(writer).unwrap();
                error_file_content = Some(content);
                break;
            }
        }

        if error_file_content.is_none() {
            return false;
        }

        let error_file_content = error_file_content.unwrap();
        let errors : Vec<WarningPayload> = serde_json::from_str(&error_file_content).unwrap();

        // check if their is an error which is a CantApplyPatch

        let mut cant_apply_patch = false;
        for error in errors {
            if *error.get_warning_type() == WarningType::CantApplyPatch {
                cant_apply_patch = true;
                break;
            }
        }

        cant_apply_patch
    }


    fn content_coherent_with_patch(&self) -> bool {
        if self.patch.is_added() {
            self.original_file_content.is_empty()
        }else if self.patch.is_removed() {
            self.fixed_file_content.is_empty()
        }else {
            !self.original_file_content.is_empty() && !self.fixed_file_content.is_empty() && self.patch.is_modified()
        }
    }

    /// get the inside file path of the original file. Example: "<cve_id>/files/original/first/second/third/fourth.php"
    pub fn get_original_file_path(&self) -> String {
        let file_path = Path::new(&self.inside_file_path);
        let file_path_without_extension = file_path.with_extension("");
        let original_file_path = Path::new(self.cve_id.as_str()).join("original").join(file_path_without_extension);
        original_file_path.to_str().unwrap().to_string()
    }

    /// get the inside file path of the fixed file. Example: "<cve_id>/files/fixed/first/second/third/fourth.php"
    pub fn get_fixed_file_path(&self) -> String {
        let file_path = Path::new(&self.inside_file_path);
        let file_path_without_extension = file_path.with_extension("");
        let fixed_file_path = Path::new(self.cve_id.as_str()).join("fixed").join(file_path_without_extension);
        fixed_file_path.to_str().unwrap().to_string()
    }
}


#[cfg(test)]
mod tests {

    use super::*;

    #[test]
    fn test_path_concat() {
        let first = "first/second";
        let second = "third/fourth";
        let expected = "first/second/third/fourth";
        let first_path = Path::new(first);
        let full_path = first_path.join(second);
        let full_path_str = full_path.to_str().unwrap();
        assert_eq!(full_path_str, expected);
    }

    #[test]
    fn test_remove_extension() {
        let path = "first/second/third/fourth.php.patch";
        let expected = "first/second/third/fourth.php";
        let path_path = Path::new(path);
        let path_without_extension = path_path.with_extension("");
        let path_without_extension_str = path_without_extension.to_str().unwrap();
        assert_eq!(path_without_extension_str, expected);
    }
}