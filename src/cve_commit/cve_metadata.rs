use std::fmt::Display;
use std::path::Path;

use crate::errors::{CveMeatadataErrors, CveMeatadataWithDataError};
use crate::language::Language;



#[derive(Debug, Clone, PartialEq, Eq)]
pub struct CveMetadata {
    cve_id: String,
    repo_name: String,
    commit_hash: String,
    parent_hash: String,
    language: Language,
}

impl Display for CveMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CveMetadata {{ cve_id: {}, repo_name: {}, commit_hash: {}, parent_hash: {}, language: {} }}", self.cve_id, self.repo_name, self.commit_hash, self.parent_hash, self.language)
    }
}


impl CveMetadata {
    pub fn from_cve_folder<P : AsRef<Path>>(cve_folder: P) -> Result<Self, CveMeatadataErrors> {
        let cve_folder = cve_folder.as_ref();
        let cve_id = cve_folder.file_name().unwrap().to_str().unwrap().to_string();
        
        // get the commit_infos file (return None if it does not exist)
        let commit_infos_path = cve_folder.join("commit_infos.json");
        if !commit_infos_path.exists() {
            return Err(CveMeatadataWithDataError::NoCommitData.into());
        }
        let commit_infos_json: serde_json::Value = serde_json::from_str(&read_to_string_wrapper(commit_infos_path)?).unwrap();

        // read the data.json file
        let data_path = cve_folder.join("data.json");
        let data_json : serde_json::Value = serde_json::from_str(&read_to_string_wrapper(data_path)?).unwrap();

        // verify that the pull request has been merged
        let merged = data_json["merged"].as_bool().unwrap();
        if !merged {
            return Err(CveMeatadataWithDataError::NotMerged.into());
        }

        // get the repo_url, commit_hash, parent_hash and language
        let repo_name = data_json["base"]["repo"]["full_name"].as_str().unwrap().to_string();
        //let commit_hash = commit_infos_json["merged_commit_sha"].as_str().unwrap().to_string();
        /*let commit_hash = data_json["merge_commit_sha"].as_str();
        if commit_hash.is_none() {
            return Err(CveMeatadataWithDataError::NoMergeCommitSha.into());
        }
        let commit_hash = commit_hash.unwrap().to_string();*/
        let commit_hash = data_json["head"]["sha"].as_str().unwrap().to_string();
        //let parent_hash = commit_infos_json["parents_commit_sha"][0].as_str().unwrap().to_string();
        let parent_hash = data_json["base"]["sha"].as_str().unwrap().to_string();

        // test if the language is null
        let language_value = &data_json["base"]["repo"]["language"];
        if language_value.is_null() {
            return Err(CveMeatadataWithDataError::NoLanguage.into());
        }

        let language_github = data_json["base"]["repo"]["language"].as_str().unwrap();
        let language = Language::new_from_github_language(language_github);
        if language.is_none() {
            return Err(CveMeatadataWithDataError::UnsupportedLanguage.into());
        }
        Ok(
            CveMetadata {
                cve_id,
                repo_name,
                commit_hash,
                parent_hash,
                language: language.unwrap(),
            }
        )
    }

    pub fn get_cve_id(&self) -> &str {
        &self.cve_id
    }

    pub fn get_repo_name(&self) -> &str {
        &self.repo_name
    }

    pub fn get_commit_hash(&self) -> &str {
        &self.commit_hash
    }

    pub fn get_parent_hash(&self) -> &str {
        &self.parent_hash
    }

    pub fn get_language(&self) -> &Language {
        &self.language
    }
}

fn read_to_string_wrapper<P: AsRef<Path>>(path: P) -> Result<String, CveMeatadataErrors> {
    let path = path.as_ref();
    match std::fs::read_to_string(path) {
        Ok(s) => Ok(s),
        Err(e) => Err(CveMeatadataErrors::IoError(e, path.to_string_lossy().to_string())),
    }
}


#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_from_cve_folder_on_data() {
        let data_path = Path::new("data/");
        let entries : Result<Vec<_>, _> = std::fs::read_dir(data_path).unwrap().collect();
        let mut entries = entries.unwrap();
        entries.sort_by(|a, b| a.path().file_name().cmp(&b.path().file_name()));

        
        for entry in entries {
            let cve_folder = entry.path();
            println!("cve_folder: {:?}", cve_folder);
            let cve_metadata = CveMetadata::from_cve_folder(&cve_folder);
            if cve_metadata.is_err() {
                match cve_metadata.unwrap_err() {
                    CveMeatadataErrors::IoError(e, s) => {
                        panic!("Error: {}: {}", s, e); // this error should not happen
                    }
                    _ => {
                        // skip the cve
                    }
                }
            }
            
        }
    }
}