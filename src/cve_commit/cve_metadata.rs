use std::io;
use std::path::Path;

use crate::language::Language;



#[derive(Debug, Clone, PartialEq, Eq)]
pub struct CveMetadata {
    cve_id: String,
    repo_name: String,
    commit_hash: String,
    parent_hash: String,
    language: Language,
}

impl CveMetadata {
    pub fn from_cve_folder<P : AsRef<Path>>(cve_folder: P) -> Result<Option<Self>, io::Error> {
        let cve_folder = cve_folder.as_ref();
        let cve_id = cve_folder.file_name().unwrap().to_str().unwrap().to_string();
        
        // get the commit_infos file (return None if it does not exist)
        let commit_infos_path = cve_folder.join("commit_infos.json");
        if !commit_infos_path.exists() {
            return Ok(None);
        }
        let commit_infos_json: serde_json::Value = serde_json::from_str(&std::fs::read_to_string(commit_infos_path)?).unwrap();

        // read the data.json file
        let data_path = cve_folder.join("data.json");
        let data_json : serde_json::Value = serde_json::from_str(&std::fs::read_to_string(data_path)?).unwrap();

        // get the repo_url, commit_hash, parent_hash and language
        let repo_name = data_json["base"]["repo"]["full_name"].as_str().unwrap().to_string();
        let commit_hash = commit_infos_json["merged_commit_sha"].as_str().unwrap().to_string();
        let parent_hash = commit_infos_json["parents_commit_sha"][0].as_str().unwrap().to_string();

        // test if the language is null
        let language_value = &data_json["base"]["repo"]["language"];
        if language_value.is_null() {
            return Ok(None);
        }

        let language_github = data_json["base"]["repo"]["language"].as_str().unwrap();
        println!("language: {:?}", language_github);
        let language = Language::new_from_github_language(language_github);
        if language.is_none() {
            return Ok(None);
        }
        Ok(
            Some(
                CveMetadata {
                    cve_id,
                    repo_name,
                    commit_hash,
                    parent_hash,
                    language: language.unwrap(),
                }
            )
        )
    }
}


#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_from_cve_folder_on_data() {
        let data_path = Path::new("data/");
        let entries : Result<Vec<_>, _> = std::fs::read_dir(data_path).unwrap().collect();
        let mut entries = entries.unwrap();
        entries.sort_by(|a, b| a.path().file_name().cmp(&b.path().file_name()));

        
        for entry in entries {
            let cve_folder = entry.path();
            println!("cve_folder: {:?}", cve_folder);
            let cve_metadata = CveMetadata::from_cve_folder(&cve_folder);
            assert!(cve_metadata.is_ok());
            
        }
    }
}