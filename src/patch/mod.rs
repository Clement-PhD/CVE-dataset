use std::fs;
use std::path::Path;

use regex::Regex;



/// This class represent a subpatch of a patch file.
/// A subpatch is a part of a patch file which is delimited by the `@@ -x,y +x,y @@` lines (hunk).
#[derive(Clone, Debug)]
pub struct SubPatch {
    pub lines: Vec<String>,
    pub hunk: String,

    pub start_original_line_number: usize,
    pub number_of_affected_original_lines: usize,
    pub start_new_line_number: usize,
    pub number_of_affected_new_lines: usize,
}

impl SubPatch {
    pub fn new(lines: Vec<String>) -> SubPatch {
        let hunk = lines[0].clone();
        let start_original_line_number;
        let number_of_affected_original_lines;
        let start_new_line_number;
        let number_of_affected_new_lines;

        if let Some((a, b, c, d)) = SubPatch::extract_hunk_numbers(&hunk) {
            start_original_line_number = a;
            number_of_affected_original_lines = b;
            start_new_line_number = c;
            number_of_affected_new_lines = d;
        }else{
            panic!("Error while parsing the hunk header: {}", hunk);
        }

        SubPatch {
            lines,
            hunk,
            start_original_line_number,
            number_of_affected_original_lines,
            start_new_line_number,
            number_of_affected_new_lines,
        }
    }

    fn extract_hunk_numbers(hunk_header: &str) -> Option<(usize, usize, usize, usize)> {
        let pattern = Regex::new(r"@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@").unwrap();
        pattern.captures(hunk_header).map(|cap| {
            let a = cap[1].parse::<usize>().unwrap();
            // If the second number (b) is not present, default to 1
            let b = cap.get(2).map_or(1, |m| m.as_str().parse::<usize>().unwrap());
            let c = cap[3].parse::<usize>().unwrap();
            // If the fourth number (d) is not present, default to 1
            let d = cap.get(4).map_or(1, |m| m.as_str().parse::<usize>().unwrap());
            (a, b, c, d)
        })
    }

    pub fn is_added(&self) -> bool {
        self.start_original_line_number == 0 && self.number_of_affected_original_lines == 0
    }

    pub fn is_removed(&self) -> bool {
        self.start_new_line_number == 0 && self.number_of_affected_new_lines == 0
    }

    pub fn is_modified(&self) -> bool {
        !self.is_added() && !self.is_removed()
    }
}


/// This class represent the file containing the patch diff to apply to a file to fix a file of a cve.
#[derive(Debug, Clone)]
pub struct Patch {
    /// The path to the patch inside the patch folder
    pub inside_patch_path: String,

    /// The lines of the patch file
    pub lines: Vec<String>,
    /// The subpatchs of the patch file
    pub subpatchs: Vec<SubPatch>,
}


impl Patch {
    pub fn new_from_content(patch_inside_path : &str, patch_content : &str) -> Patch {
        let lines: Vec<String> = patch_content.lines().map(|s| s.to_string()).collect();
        let mut subpatchs: Vec<SubPatch> = vec![];
        let mut current_subpatch_lines: Vec<String> = vec![];

        for line in &lines {
            if line.starts_with("@@") {
                if !current_subpatch_lines.is_empty() {
                    subpatchs.push(SubPatch::new(current_subpatch_lines));
                    current_subpatch_lines = vec![];
                }
            }
            current_subpatch_lines.push(line.clone());
        }

        if !current_subpatch_lines.is_empty() {
            subpatchs.push(SubPatch::new(current_subpatch_lines));
        }

        assert!(!subpatchs.is_empty(), "Error while parsing the patch file (subpatchs are empty): {}", patch_inside_path);

        Patch {
            inside_patch_path: patch_inside_path.to_string(),
            lines,
            subpatchs,
        }
    }


    pub fn new<P: AsRef<Path>>(full_patch_path : P) -> Patch {
        let contents = fs::read_to_string(&full_patch_path)
            .expect("Error reading the patch file");

        let full_patch_path_str = full_patch_path.as_ref().to_str().unwrap();
        let inside_patch_path = full_patch_path_str.split("/patch/").last().unwrap();

        Patch::new_from_content(inside_patch_path, &contents)
    }

    pub fn is_added(&self) -> bool {
        self.subpatchs.len() == 1 && self.subpatchs[0].is_added()
    }

    pub fn is_removed(&self) -> bool {
        self.subpatchs.len() == 1 && self.subpatchs[0].is_removed()
    }

    pub fn is_modified(&self) -> bool {
        self.subpatchs.len() > 1 || self.subpatchs[0].is_modified()
    }
}

#[cfg(test)]
mod tests {
    use crate::params::{TEST_COMPLEXE_PATCH_PATH, TEST_PATCH_REAL_1_PATH, TEST_PATCH_REAL_2_PATH, TEST_PATCH_WITH_ONLY_2_NUMBER_PATH, TEST_SIMPLE_PATCH_PATH};

    use super::*;

    

    fn test_hunk_number(
        subpatch_to_test : &SubPatch, 
        expected_start_original_line_number : usize, 
        expected_number_of_affected_original_lines : usize, 
        expected_start_new_line_number : usize, 
        expected_number_of_affected_new_lines : usize
    ) {
        assert_eq!(subpatch_to_test.start_original_line_number, expected_start_original_line_number);
        assert_eq!(subpatch_to_test.number_of_affected_original_lines, expected_number_of_affected_original_lines);
        assert_eq!(subpatch_to_test.start_new_line_number, expected_start_new_line_number);
        assert_eq!(subpatch_to_test.number_of_affected_new_lines, expected_number_of_affected_new_lines);
    }

    #[test]
    fn test_simple_patch() {
        let patch = Patch::new(TEST_SIMPLE_PATCH_PATH);
        assert_eq!(patch.lines.len(), 8);
        assert_eq!(patch.subpatchs.len(), 1);
        assert_eq!(patch.subpatchs[0].lines.len(), 8);
        test_hunk_number(&patch.subpatchs[0], 36, 7, 36, 7);
        assert!(patch.is_modified(), "The patch should be modified");
    }


    #[test]
    fn test_complexe_patch() {
        let patch = Patch::new(TEST_COMPLEXE_PATCH_PATH);
        assert_eq!(patch.lines.len(), 157);
        assert_eq!(patch.subpatchs.len(), 11);
        for subpatch in &patch.subpatchs {
            assert!(!subpatch.lines.is_empty());
            assert!(subpatch.is_modified());
        }

        assert!(patch.subpatchs[3].lines.len() == 31);

        test_hunk_number(&patch.subpatchs[0], 11, 6, 11, 14);
        test_hunk_number(&patch.subpatchs[4], 130, 15, 143, 15);
    }


    #[test]
    fn test_with_only_2_number_hunk_patch() {
        let patch = Patch::new(TEST_PATCH_WITH_ONLY_2_NUMBER_PATH);
        assert_eq!(patch.lines.len(), 5);
        assert_eq!(patch.subpatchs.len(), 1);
        assert_eq!(patch.subpatchs[0].lines.len(), 5);
        test_hunk_number(&patch.subpatchs[0], 1, 1, 1, 1);

        assert!(patch.is_modified(), "The patch should be modified");
    }


    #[test]
    fn real_test1 () {
        let patch = Patch::new(TEST_PATCH_REAL_1_PATH);
        assert!(!patch.is_added(), "The patch should not be added");
        assert!(!patch.is_removed(), "The patch should not be removed");
        assert!(patch.is_modified(), "The patch should be modified");
    }

    #[test]
    fn real_test2 () {
        let patch = Patch::new(TEST_PATCH_REAL_2_PATH);
        assert!(!patch.is_added(), "The patch should not be added");
        assert!(!patch.is_removed(), "The patch should not be removed");
        assert!(patch.is_modified(), "The patch should be modified");
    }
}